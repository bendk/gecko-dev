// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

"use strict";

var EXPORTED_SYMBOLS = [];


// Write/Read data to/from an ArrayBuffer
class ArrayBufferDataStream {
    constructor(arrayBuffer) {
      this.dataView = new DataView(arrayBuffer);
      this.pos = 0;
    }
  
    readFloat64() {
      let rv = this.dataView.getFloat64(this.pos);
      this.pos += 8;
      return rv;
    }
  
    writeFloat64(value) {
      this.dataView.setFloat64(this.pos, value);
      this.pos += 8;
    }
  
    readUint8() {
      let rv = this.dataView.getUint8(this.pos);
      this.pos += 1;
      return rv;
    }
  
  
    // TODO: write more methods
  }


  function makeRustCall(callback, liftErrCallback) {
    let status = new UniFFIRustCallStatus();
    let rv = callback(status);
    switch (status.code) {
      case UniFFIRustCallStatus.CALL_SUCCESS:
        return rv;
  
      case UniFFIRustCallStatus.CALL_ERROR:
        throw liftErrCallback(status.getArrayBuffer());
  
      case UniFFIRustCallStatus.CALL_PANIC:
        // Theoretical code to handle Rust panics.  It's theoretical at
        // this point because gecko sets the panic=abort flag for rustc,
        // which prevents the UniFFI panic catching code from running.
  
        // Try to get the panic message
        let errorBuf = status.getArrayBuffer();
        if (errorBuf.byteLength > 0) {
          throw UniFFIPanic(liftString(errorBuf));
        } else {
          throw UniFFIPanic("Unknown panic in Rust code");
        }
  
      default:
        throw UniFFIError(`Unexpected status code: ${status.code}`);
    }
  }
  
  class UniFFIError {
    constructor(message) {
      this.message = message;
    }
  }
  class UniFFIPanic extends UniFFIError {}

class FfiConverterDouble {
    static lift(value) {
        return value;
    }
    static lower(value) {
        return value;
    }
    static computeSize() {
        return 8;
    }
    static write(dataStream, double) {
        dataStream.writeFloat64(double)
    }

    static read(dataStream) {
        return dataStream.readFloat64()
    }
}




class Point {
    constructor(coordX,coordY) {
        this.coordX = coordX;
        this.coordY = coordY;
    }
}

class FfiConverterPoint {
    static lift(buf) {
        return this.read(new ArrayBufferDataStream(buf));
    }
    static lower(value) {
        const buf = new ArrayBuffer(this.computeSize());
        const dataStream = new ArrayBufferDataStream(buf);
        this.write(dataStream, value);
        return buf;
    }
    static read(dataStream) {
        return new Point(
            FfiConverterDouble.read(dataStream), 
            FfiConverterDouble.read(dataStream) 
        );
    }
    static write(dataStream, value) {
        FfiConverterDouble.write(dataStream, value.coordX);
        FfiConverterDouble.write(dataStream, value.coordY);
    }

    static computeSize() {
        let totalSize = 0;
        totalSize += FfiConverterDouble.computeSize();
        totalSize += FfiConverterDouble.computeSize();
        return totalSize
    }
}

class FfiConverterOptionalPoint {
    static lift(buf) {
        return this.read(new ArrayBufferDataStream(buf));
    }

    static lower(value) {
        const buf = new ArrayBuffer(this.computeSize());
        const dataStream = new ArrayBufferDataStream(buf);
        this.write(dataStream, value);
        return buf;
    }

    static read(dataStream) {
        const code = dataStream.readUint8(0);
        switch (code) {
            case 0:
                return null
            case 1:
                return FfiConverterPoint.read(dataStream);
            default:
                throw UniFFIError(`Unexpected code: ${code}`);
        }
    }

    static write(dataStream, value) {
        if (!value) {
            dataStream.writeUint8(0);
            return buf;
        }
        dataStream.writeUint8(1);
        FfiConverterPoint.write(dataStream, value);
        return buf;
    }

    static computeSize() {
        return 1 + FfiConverterPoint.computeSize();
    }
}

EXPORTED_SYMBOLS.push("Point");

class Line {
    constructor(start,end) {
        this.start = start;
        this.end = end;
    }
}

class FfiConverterLine {
    static lift(buf) {
        return this.read(new ArrayBufferDataStream(buf));
    }
    static lower(value) {
        const buf = new ArrayBuffer(this.computeSize());
        const dataStream = new ArrayBufferDataStream(buf);
        this.write(dataStream, value);
        return buf;
    }
    static read(dataStream) {
        return new Line(
            FfiConverterPoint.read(dataStream), 
            FfiConverterPoint.read(dataStream) 
        );
    }
    static write(dataStream, value) {
        FfiConverterPoint.write(dataStream, value.start);
        FfiConverterPoint.write(dataStream, value.end);
    }

    static computeSize() {
        let totalSize = 0;
        totalSize += FfiConverterPoint.computeSize();
        totalSize += FfiConverterPoint.computeSize();
        return totalSize
    }
}

class FfiConverterOptionalLine {
    static lift(buf) {
        return this.read(new ArrayBufferDataStream(buf));
    }

    static lower(value) {
        const buf = new ArrayBuffer(this.computeSize());
        const dataStream = new ArrayBufferDataStream(buf);
        this.write(dataStream, value);
        return buf;
    }

    static read(dataStream) {
        const code = dataStream.readUint8(0);
        switch (code) {
            case 0:
                return null
            case 1:
                return FfiConverterLine.read(dataStream);
            default:
                throw UniFFIError(`Unexpected code: ${code}`);
        }
    }

    static write(dataStream, value) {
        if (!value) {
            dataStream.writeUint8(0);
            return buf;
        }
        dataStream.writeUint8(1);
        FfiConverterLine.write(dataStream, value);
        return buf;
    }

    static computeSize() {
        return 1 + FfiConverterLine.computeSize();
    }
}

EXPORTED_SYMBOLS.push("Line");


function gradient(ln) {
    return FfiConverterDouble.lift(
        makeRustCall((status) => GeometryScaffolding.geometryEb69Gradient(FfiConverterLine.lower(ln),
            status
        )
    ))
}

EXPORTED_SYMBOLS.push("gradient");
function intersection(ln1,ln2) {
    return FfiConverterOptionalPoint.lift(
        makeRustCall((status) => GeometryScaffolding.geometryEb69Intersection(FfiConverterLine.lower(ln1),FfiConverterLine.lower(ln2),
            status
        )
    ))
}

EXPORTED_SYMBOLS.push("intersection");