// This file was autogenerated by some hot garbage in the `uniffi-bindgen-gecko-js` crate.
// Trust me, you don't want to mess with it!

#include "mozilla/dom/{{ ci.scaffolding_name() }}.h"
#include "mozilla/dom/OwnedRustBuffer.h"

namespace mozilla::dom {

{%- for func in ci.iter_user_ffi_function_definitions() %}

{{ func.cpp_return_type() }} {{ ci.scaffolding_name() }}::{{ func.cpp_name() }}({{ func.cpp_arg_list() }}) {
  {#- Perform any argument conversions needed before sending the them to rust #}

  {%- for arg in func.arguments() %}
  {%- if arg.is_rust_buffer() %}
  {{ arg.cpp_name() }}.ComputeState();
  OwnedRustBuffer {{ arg.cpp_name() }}Converted({{ arg.cpp_name() }}, {{ func.cpp_error_arg_name() }});
  if (!{{ arg.cpp_name() }}Converted.isValid()) {
    {{ func.cpp_error_return_statement() }}
  }
  {%- endif %}
  {%- endfor %}

  // Call the Rust function
  RustCallStatus callStatus = {};
  {{ func.rust_return_type() }} rustResult = {{ func.rust_name() }}(
    {%- for arg in func.arguments() -%}
    {%- if arg.is_rust_buffer() %}
    {{ arg.cpp_name() }}Converted.intoRustBuffer(),
    {%- else %}
    {{ arg.cpp_name() }},
    {%- endif %}
    {%- endfor %}
    &callStatus);
  {{ func.cpp_status_arg_name() }}.update(callStatus);

  {%- if func.returns_rust_buffer() %}
  // Convert result RustBuffer into an ArrayBuffer and set the out param
  {{ func.cpp_out_param_name() }}.set(JS::RootedObject(
    {{ func.cpp_global_arg_name() }}.Context(),
    OwnedRustBuffer(rustResult).intoArrayBuffer({{ func.cpp_global_arg_name() }}.Context())));
  {%- else %}
  // Return the result directly
  return rustResult;
  {%- endif %}
}

{%- endfor %}

}  // namespace mozilla::dom

