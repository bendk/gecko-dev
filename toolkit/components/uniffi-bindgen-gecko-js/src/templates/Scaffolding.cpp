// This file was autogenerated by some hot garbage in the `uniffi-bindgen-gecko-js` crate.
// Trust me, you don't want to mess with it!

#include "mozilla/dom/{{ ci.scaffolding_name() }}.h"
#include "mozilla/dom/OwnedRustBuffer.h"

namespace mozilla::dom {

{%- for func in ci.iter_user_ffi_function_definitions() %}

{{ func.cpp_return_type() }} {{ ci.scaffolding_name() }}::{{ func.cpp_name() }}({{ func.cpp_arg_list() }}) {

  {#- Perform any argument conversions needed before sending the them to rust #}

  {%- for arg in func.arguments() %}
  {%- if arg.is_rust_buffer() %}
  {{ arg.cpp_name() }}.ComputeState();
  OwnedRustBuffer {{ arg.cpp_name() }}Converted({{ arg.cpp_name() }}, {{ func.cpp_error_arg_name() }});
  if ({{ func.cpp_error_arg_name() }}.Failed()) {
      return;
  }
  {%- endif %}
  {%- endfor %}

  // Call the Rust function
  RustCallStatus callStatus = {};
  {{ func.rust_return_type() }} rustResult = {{ func.rust_name() }}(
    {%- for arg in func.arguments() -%}
    {%- if arg.is_rust_buffer() %}
    {{ arg.cpp_name() }}Converted.intoRustBuffer(),
    {%- else %}
    {{ arg.cpp_name() }},
    {%- endif %}
    {%- endfor %}
    &callStatus);

  {{ func.cpp_out_param_name() }}.mCode = callStatus.code;
  if (callStatus.code == uniffi::CALL_SUCCESS) {
      {%- if func.returns_rust_buffer() %}
      // Convert result RustBuffer into an ArrayBuffer and set the data field
      {{ func.cpp_out_param_name() }}.mData.setObjectOrNull(
        OwnedRustBuffer(rustResult).intoArrayBuffer({{ func.cpp_global_arg_name() }}.Context())
       );
      {%- else %}
      // All other return values (ints, floats, pointers) are handled as a JS number value
      {{ func.cpp_out_param_name() }}.mData.setNumber(rustResult);
      {%- endif %}
  }
}

{%- endfor %}

}  // namespace mozilla::dom

