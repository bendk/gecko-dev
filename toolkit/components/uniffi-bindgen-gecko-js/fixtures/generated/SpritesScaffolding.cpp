// This file was autogenerated by some hot garbage in the `uniffi-bindgen-gecko-js` crate.
// Trust me, you don't want to mess with it!

#include "nsIGlobalObject.h"
#include "mozilla/MozPromise.h"
#include "mozilla/dom/SpritesScaffolding.h"
#include "mozilla/dom/OwnedRustBuffer.h"
#include "mozilla/dom/Promise.h"

namespace uniffi::sprites {
// For each Rust scaffolding function, define types and functions for calling it
namespace ffi_sprites_850_sprite_object_free {
using namespace mozilla::dom;
// Arguments to pass to the scaffolding function
struct Args {
    void * ptr;
};

// Return values from the scaffolding function
struct Result {
    RustCallStatus mCallStatus = {};
};

// Convert the arguments we get from JS to arguments to pass to Rust.
//
// On error, an error code will be stored in result.  Make sure to check this before
// passing the args to Invoke().
//
// For async calls this should be called in the main thread, since the GC can
// move the ArrayBuffer pointers while the background task is waiting.
Args PrepareArgs(const JS::Handle<JS::Value>& ptr,
    mozilla::ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args
    Args uniFFIArgs;
    // Extract the pointer from the JS::Value using `toPrivate`.
    uniFFIArgs.ptr = ptr.toPrivate();

    return uniFFIArgs;
}

// Call the scaffolding function
//
// For async calls this should be called in the worker thread
Result Invoke(Args& aArgs) {
    Result result = {};::ffi_sprites_850_Sprite_object_free(
         aArgs.ptr,
         &result.mCallStatus
     );
    return result;
}

// Return the result of the scaffolding call back to JS
void ReturnResult(JSContext* aContext, const Result& aCallResult, RootedDictionary<UniFFIRustCallResult>& aReturnValue) {
    switch (aCallResult.mCallStatus.code) {
        case uniffi::CALL_SUCCESS:
            // Successful call.  Populate data with the return value
            aReturnValue.mCode = uniffi::CALL_SUCCESS;
            // Void return
            break;

        case uniffi::CALL_ERROR:
            // Rust Err() value.  Populate data with the `RustBuffer` containing the error
            aReturnValue.mCode = uniffi::CALL_ERROR;
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mCallStatus.error_buf).intoArrayBuffer(aContext));
            break;

        default:
            // This indicates a RustError, which shouldn't happen in practice since FF sets panic=abort
            aReturnValue.mCode = uniffi::CALL_INTERNAL_ERROR;
            aReturnValue.mInternalErrorMessage.AssignLiteral(u"Unexpected Error");
            break;
    }
}
}
// For each Rust scaffolding function, define types and functions for calling it
namespace sprites_850_sprite_new {
using namespace mozilla::dom;
// Arguments to pass to the scaffolding function
struct Args {
    // RustBuffer arguments are stored as OwnedRustBuffer instances.  That class takes care of
    // freeing the buffer if the arguments don't get passed to Rust (i.e. intoRustBuffer()
    // isn't called).  This can happen if some of the ArrayBuffer arguments are succuessfully
    // converted, but one fails to convert.
    mozilla::dom::OwnedRustBuffer initialPosition;
};

// Return values from the scaffolding function
struct Result {
    void * mReturnValue;
    RustCallStatus mCallStatus = {};
};

// Convert the arguments we get from JS to arguments to pass to Rust.
//
// On error, an error code will be stored in result.  Make sure to check this before
// passing the args to Invoke().
//
// For async calls this should be called in the main thread, since the GC can
// move the ArrayBuffer pointers while the background task is waiting.
Args PrepareArgs(const ArrayBuffer& initialPosition,
    mozilla::ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args
    Args uniFFIArgs;
    // Convert the ArrayBuffer we get from JS to an OwnedRustBuffer
    initialPosition.ComputeState();
    uniFFIArgs.initialPosition = OwnedRustBuffer(initialPosition, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return uniFFIArgs;
    }

    return uniFFIArgs;
}

// Call the scaffolding function
//
// For async calls this should be called in the worker thread
Result Invoke(Args& aArgs) {
    Result result = {};result.mReturnValue =::sprites_850_Sprite_new(
         // Call intoRustBuffer() to get a `RustBuffer` from an OwnedRustBuffer.  This transfers ownership to Rust,
         // OwnedRustBuffer will no longer try to free it
         aArgs.initialPosition.intoRustBuffer(),
         &result.mCallStatus
     );
    return result;
}

// Return the result of the scaffolding call back to JS
void ReturnResult(JSContext* aContext, const Result& aCallResult, RootedDictionary<UniFFIRustCallResult>& aReturnValue) {
    switch (aCallResult.mCallStatus.code) {
        case uniffi::CALL_SUCCESS:
            // Successful call.  Populate data with the return value
            aReturnValue.mCode = uniffi::CALL_SUCCESS;
            // Pointer return, use `JS::Value::setPrivate()` to store it
            aReturnValue.mData.setPrivate(aCallResult.mReturnValue);
            break;

        case uniffi::CALL_ERROR:
            // Rust Err() value.  Populate data with the `RustBuffer` containing the error
            aReturnValue.mCode = uniffi::CALL_ERROR;
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mCallStatus.error_buf).intoArrayBuffer(aContext));
            break;

        default:
            // This indicates a RustError, which shouldn't happen in practice since FF sets panic=abort
            aReturnValue.mCode = uniffi::CALL_INTERNAL_ERROR;
            aReturnValue.mInternalErrorMessage.AssignLiteral(u"Unexpected Error");
            break;
    }
}
}
// For each Rust scaffolding function, define types and functions for calling it
namespace sprites_850_sprite_new_relative_to {
using namespace mozilla::dom;
// Arguments to pass to the scaffolding function
struct Args {
    // RustBuffer arguments are stored as OwnedRustBuffer instances.  That class takes care of
    // freeing the buffer if the arguments don't get passed to Rust (i.e. intoRustBuffer()
    // isn't called).  This can happen if some of the ArrayBuffer arguments are succuessfully
    // converted, but one fails to convert.
    mozilla::dom::OwnedRustBuffer reference;
    // RustBuffer arguments are stored as OwnedRustBuffer instances.  That class takes care of
    // freeing the buffer if the arguments don't get passed to Rust (i.e. intoRustBuffer()
    // isn't called).  This can happen if some of the ArrayBuffer arguments are succuessfully
    // converted, but one fails to convert.
    mozilla::dom::OwnedRustBuffer direction;
};

// Return values from the scaffolding function
struct Result {
    void * mReturnValue;
    RustCallStatus mCallStatus = {};
};

// Convert the arguments we get from JS to arguments to pass to Rust.
//
// On error, an error code will be stored in result.  Make sure to check this before
// passing the args to Invoke().
//
// For async calls this should be called in the main thread, since the GC can
// move the ArrayBuffer pointers while the background task is waiting.
Args PrepareArgs(const ArrayBuffer& reference, const ArrayBuffer& direction,
    mozilla::ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args
    Args uniFFIArgs;
    // Convert the ArrayBuffer we get from JS to an OwnedRustBuffer
    reference.ComputeState();
    uniFFIArgs.reference = OwnedRustBuffer(reference, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return uniFFIArgs;
    }
    // Convert the ArrayBuffer we get from JS to an OwnedRustBuffer
    direction.ComputeState();
    uniFFIArgs.direction = OwnedRustBuffer(direction, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return uniFFIArgs;
    }

    return uniFFIArgs;
}

// Call the scaffolding function
//
// For async calls this should be called in the worker thread
Result Invoke(Args& aArgs) {
    Result result = {};result.mReturnValue =::sprites_850_Sprite_new_relative_to(
         // Call intoRustBuffer() to get a `RustBuffer` from an OwnedRustBuffer.  This transfers ownership to Rust,
         // OwnedRustBuffer will no longer try to free it
         aArgs.reference.intoRustBuffer(),
         // Call intoRustBuffer() to get a `RustBuffer` from an OwnedRustBuffer.  This transfers ownership to Rust,
         // OwnedRustBuffer will no longer try to free it
         aArgs.direction.intoRustBuffer(),
         &result.mCallStatus
     );
    return result;
}

// Return the result of the scaffolding call back to JS
void ReturnResult(JSContext* aContext, const Result& aCallResult, RootedDictionary<UniFFIRustCallResult>& aReturnValue) {
    switch (aCallResult.mCallStatus.code) {
        case uniffi::CALL_SUCCESS:
            // Successful call.  Populate data with the return value
            aReturnValue.mCode = uniffi::CALL_SUCCESS;
            // Pointer return, use `JS::Value::setPrivate()` to store it
            aReturnValue.mData.setPrivate(aCallResult.mReturnValue);
            break;

        case uniffi::CALL_ERROR:
            // Rust Err() value.  Populate data with the `RustBuffer` containing the error
            aReturnValue.mCode = uniffi::CALL_ERROR;
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mCallStatus.error_buf).intoArrayBuffer(aContext));
            break;

        default:
            // This indicates a RustError, which shouldn't happen in practice since FF sets panic=abort
            aReturnValue.mCode = uniffi::CALL_INTERNAL_ERROR;
            aReturnValue.mInternalErrorMessage.AssignLiteral(u"Unexpected Error");
            break;
    }
}
}
// For each Rust scaffolding function, define types and functions for calling it
namespace sprites_850_sprite_get_position {
using namespace mozilla::dom;
// Arguments to pass to the scaffolding function
struct Args {
    void * ptr;
};

// Return values from the scaffolding function
struct Result {
    RustBuffer mReturnValue;
    RustCallStatus mCallStatus = {};
};

// Convert the arguments we get from JS to arguments to pass to Rust.
//
// On error, an error code will be stored in result.  Make sure to check this before
// passing the args to Invoke().
//
// For async calls this should be called in the main thread, since the GC can
// move the ArrayBuffer pointers while the background task is waiting.
Args PrepareArgs(const JS::Handle<JS::Value>& ptr,
    mozilla::ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args
    Args uniFFIArgs;
    // Extract the pointer from the JS::Value using `toPrivate`.
    uniFFIArgs.ptr = ptr.toPrivate();

    return uniFFIArgs;
}

// Call the scaffolding function
//
// For async calls this should be called in the worker thread
Result Invoke(Args& aArgs) {
    Result result = {};result.mReturnValue =::sprites_850_Sprite_get_position(
         aArgs.ptr,
         &result.mCallStatus
     );
    return result;
}

// Return the result of the scaffolding call back to JS
void ReturnResult(JSContext* aContext, const Result& aCallResult, RootedDictionary<UniFFIRustCallResult>& aReturnValue) {
    switch (aCallResult.mCallStatus.code) {
        case uniffi::CALL_SUCCESS:
            // Successful call.  Populate data with the return value
            aReturnValue.mCode = uniffi::CALL_SUCCESS;
            // RustBuffer return, convert it to an ArrayBuffer
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mReturnValue).intoArrayBuffer(aContext));
            break;

        case uniffi::CALL_ERROR:
            // Rust Err() value.  Populate data with the `RustBuffer` containing the error
            aReturnValue.mCode = uniffi::CALL_ERROR;
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mCallStatus.error_buf).intoArrayBuffer(aContext));
            break;

        default:
            // This indicates a RustError, which shouldn't happen in practice since FF sets panic=abort
            aReturnValue.mCode = uniffi::CALL_INTERNAL_ERROR;
            aReturnValue.mInternalErrorMessage.AssignLiteral(u"Unexpected Error");
            break;
    }
}
}
// For each Rust scaffolding function, define types and functions for calling it
namespace sprites_850_sprite_move_to {
using namespace mozilla::dom;
// Arguments to pass to the scaffolding function
struct Args {
    void * ptr;
    // RustBuffer arguments are stored as OwnedRustBuffer instances.  That class takes care of
    // freeing the buffer if the arguments don't get passed to Rust (i.e. intoRustBuffer()
    // isn't called).  This can happen if some of the ArrayBuffer arguments are succuessfully
    // converted, but one fails to convert.
    mozilla::dom::OwnedRustBuffer position;
};

// Return values from the scaffolding function
struct Result {
    RustCallStatus mCallStatus = {};
};

// Convert the arguments we get from JS to arguments to pass to Rust.
//
// On error, an error code will be stored in result.  Make sure to check this before
// passing the args to Invoke().
//
// For async calls this should be called in the main thread, since the GC can
// move the ArrayBuffer pointers while the background task is waiting.
Args PrepareArgs(const JS::Handle<JS::Value>& ptr, const ArrayBuffer& position,
    mozilla::ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args
    Args uniFFIArgs;
    // Extract the pointer from the JS::Value using `toPrivate`.
    uniFFIArgs.ptr = ptr.toPrivate();
    // Convert the ArrayBuffer we get from JS to an OwnedRustBuffer
    position.ComputeState();
    uniFFIArgs.position = OwnedRustBuffer(position, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return uniFFIArgs;
    }

    return uniFFIArgs;
}

// Call the scaffolding function
//
// For async calls this should be called in the worker thread
Result Invoke(Args& aArgs) {
    Result result = {};::sprites_850_Sprite_move_to(
         aArgs.ptr,
         // Call intoRustBuffer() to get a `RustBuffer` from an OwnedRustBuffer.  This transfers ownership to Rust,
         // OwnedRustBuffer will no longer try to free it
         aArgs.position.intoRustBuffer(),
         &result.mCallStatus
     );
    return result;
}

// Return the result of the scaffolding call back to JS
void ReturnResult(JSContext* aContext, const Result& aCallResult, RootedDictionary<UniFFIRustCallResult>& aReturnValue) {
    switch (aCallResult.mCallStatus.code) {
        case uniffi::CALL_SUCCESS:
            // Successful call.  Populate data with the return value
            aReturnValue.mCode = uniffi::CALL_SUCCESS;
            // Void return
            break;

        case uniffi::CALL_ERROR:
            // Rust Err() value.  Populate data with the `RustBuffer` containing the error
            aReturnValue.mCode = uniffi::CALL_ERROR;
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mCallStatus.error_buf).intoArrayBuffer(aContext));
            break;

        default:
            // This indicates a RustError, which shouldn't happen in practice since FF sets panic=abort
            aReturnValue.mCode = uniffi::CALL_INTERNAL_ERROR;
            aReturnValue.mInternalErrorMessage.AssignLiteral(u"Unexpected Error");
            break;
    }
}
}
// For each Rust scaffolding function, define types and functions for calling it
namespace sprites_850_sprite_move_by {
using namespace mozilla::dom;
// Arguments to pass to the scaffolding function
struct Args {
    void * ptr;
    // RustBuffer arguments are stored as OwnedRustBuffer instances.  That class takes care of
    // freeing the buffer if the arguments don't get passed to Rust (i.e. intoRustBuffer()
    // isn't called).  This can happen if some of the ArrayBuffer arguments are succuessfully
    // converted, but one fails to convert.
    mozilla::dom::OwnedRustBuffer direction;
};

// Return values from the scaffolding function
struct Result {
    RustCallStatus mCallStatus = {};
};

// Convert the arguments we get from JS to arguments to pass to Rust.
//
// On error, an error code will be stored in result.  Make sure to check this before
// passing the args to Invoke().
//
// For async calls this should be called in the main thread, since the GC can
// move the ArrayBuffer pointers while the background task is waiting.
Args PrepareArgs(const JS::Handle<JS::Value>& ptr, const ArrayBuffer& direction,
    mozilla::ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args
    Args uniFFIArgs;
    // Extract the pointer from the JS::Value using `toPrivate`.
    uniFFIArgs.ptr = ptr.toPrivate();
    // Convert the ArrayBuffer we get from JS to an OwnedRustBuffer
    direction.ComputeState();
    uniFFIArgs.direction = OwnedRustBuffer(direction, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return uniFFIArgs;
    }

    return uniFFIArgs;
}

// Call the scaffolding function
//
// For async calls this should be called in the worker thread
Result Invoke(Args& aArgs) {
    Result result = {};::sprites_850_Sprite_move_by(
         aArgs.ptr,
         // Call intoRustBuffer() to get a `RustBuffer` from an OwnedRustBuffer.  This transfers ownership to Rust,
         // OwnedRustBuffer will no longer try to free it
         aArgs.direction.intoRustBuffer(),
         &result.mCallStatus
     );
    return result;
}

// Return the result of the scaffolding call back to JS
void ReturnResult(JSContext* aContext, const Result& aCallResult, RootedDictionary<UniFFIRustCallResult>& aReturnValue) {
    switch (aCallResult.mCallStatus.code) {
        case uniffi::CALL_SUCCESS:
            // Successful call.  Populate data with the return value
            aReturnValue.mCode = uniffi::CALL_SUCCESS;
            // Void return
            break;

        case uniffi::CALL_ERROR:
            // Rust Err() value.  Populate data with the `RustBuffer` containing the error
            aReturnValue.mCode = uniffi::CALL_ERROR;
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mCallStatus.error_buf).intoArrayBuffer(aContext));
            break;

        default:
            // This indicates a RustError, which shouldn't happen in practice since FF sets panic=abort
            aReturnValue.mCode = uniffi::CALL_INTERNAL_ERROR;
            aReturnValue.mInternalErrorMessage.AssignLiteral(u"Unexpected Error");
            break;
    }
}
}
// For each Rust scaffolding function, define types and functions for calling it
namespace sprites_850_translate {
using namespace mozilla::dom;
// Arguments to pass to the scaffolding function
struct Args {
    // RustBuffer arguments are stored as OwnedRustBuffer instances.  That class takes care of
    // freeing the buffer if the arguments don't get passed to Rust (i.e. intoRustBuffer()
    // isn't called).  This can happen if some of the ArrayBuffer arguments are succuessfully
    // converted, but one fails to convert.
    mozilla::dom::OwnedRustBuffer position;
    // RustBuffer arguments are stored as OwnedRustBuffer instances.  That class takes care of
    // freeing the buffer if the arguments don't get passed to Rust (i.e. intoRustBuffer()
    // isn't called).  This can happen if some of the ArrayBuffer arguments are succuessfully
    // converted, but one fails to convert.
    mozilla::dom::OwnedRustBuffer direction;
};

// Return values from the scaffolding function
struct Result {
    RustBuffer mReturnValue;
    RustCallStatus mCallStatus = {};
};

// Convert the arguments we get from JS to arguments to pass to Rust.
//
// On error, an error code will be stored in result.  Make sure to check this before
// passing the args to Invoke().
//
// For async calls this should be called in the main thread, since the GC can
// move the ArrayBuffer pointers while the background task is waiting.
Args PrepareArgs(const ArrayBuffer& position, const ArrayBuffer& direction,
    mozilla::ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args
    Args uniFFIArgs;
    // Convert the ArrayBuffer we get from JS to an OwnedRustBuffer
    position.ComputeState();
    uniFFIArgs.position = OwnedRustBuffer(position, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return uniFFIArgs;
    }
    // Convert the ArrayBuffer we get from JS to an OwnedRustBuffer
    direction.ComputeState();
    uniFFIArgs.direction = OwnedRustBuffer(direction, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return uniFFIArgs;
    }

    return uniFFIArgs;
}

// Call the scaffolding function
//
// For async calls this should be called in the worker thread
Result Invoke(Args& aArgs) {
    Result result = {};result.mReturnValue =::sprites_850_translate(
         // Call intoRustBuffer() to get a `RustBuffer` from an OwnedRustBuffer.  This transfers ownership to Rust,
         // OwnedRustBuffer will no longer try to free it
         aArgs.position.intoRustBuffer(),
         // Call intoRustBuffer() to get a `RustBuffer` from an OwnedRustBuffer.  This transfers ownership to Rust,
         // OwnedRustBuffer will no longer try to free it
         aArgs.direction.intoRustBuffer(),
         &result.mCallStatus
     );
    return result;
}

// Return the result of the scaffolding call back to JS
void ReturnResult(JSContext* aContext, const Result& aCallResult, RootedDictionary<UniFFIRustCallResult>& aReturnValue) {
    switch (aCallResult.mCallStatus.code) {
        case uniffi::CALL_SUCCESS:
            // Successful call.  Populate data with the return value
            aReturnValue.mCode = uniffi::CALL_SUCCESS;
            // RustBuffer return, convert it to an ArrayBuffer
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mReturnValue).intoArrayBuffer(aContext));
            break;

        case uniffi::CALL_ERROR:
            // Rust Err() value.  Populate data with the `RustBuffer` containing the error
            aReturnValue.mCode = uniffi::CALL_ERROR;
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mCallStatus.error_buf).intoArrayBuffer(aContext));
            break;

        default:
            // This indicates a RustError, which shouldn't happen in practice since FF sets panic=abort
            aReturnValue.mCode = uniffi::CALL_INTERNAL_ERROR;
            aReturnValue.mInternalErrorMessage.AssignLiteral(u"Unexpected Error");
            break;
    }
}
}
}

namespace mozilla::dom {
using namespace uniffi::sprites;
already_AddRefed<Promise> SpritesScaffolding::FfiSprites850SpriteObjectFree(const GlobalObject& aUniFFIGlobal,const JS::Handle<JS::Value>& ptr,
 ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args

    // Create the promise that we return to JS
    nsCOMPtr<nsIGlobalObject> uniFFIXPCOMGlobal = do_QueryInterface(aUniFFIGlobal.GetAsSupports());
    RefPtr<Promise> uniFFIReturnPromise = Promise::Create(uniFFIXPCOMGlobal, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Prepare arguments to pass to Rust
    auto uniFFIArgs = ffi_sprites_850_sprite_object_free::PrepareArgs(ptr, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Create a second promise that gets resolved by a background task that calls the scaffolding function
    using UniFFITaskPromise = MozPromise<ffi_sprites_850_sprite_object_free::Result, nsresult, true>;
    RefPtr uniFFITaskPromise = new UniFFITaskPromise::Private(__func__);
    nsresult uniFFIDispatchResult = NS_DispatchBackgroundTask(
            NS_NewRunnableFunction(
                "SpritesScaffolding::FfiSprites850SpriteObjectFree",
                [args = std::move(uniFFIArgs), uniFFITaskPromise]() mutable {
                auto result = ffi_sprites_850_sprite_object_free::Invoke(args);
                uniFFITaskPromise->Resolve(std::move(result), __func__);
            }),
            NS_DISPATCH_EVENT_MAY_BLOCK);
    if (NS_FAILED(uniFFIDispatchResult)) {
        uniFFITaskPromise->Reject(uniFFIDispatchResult, __func__);
    }

    // When the background task promise completes, resolve the JS promise
    uniFFITaskPromise->Then(GetCurrentSerialEventTarget(), __func__,
            [uniFFIXPCOMGlobal, uniFFIReturnPromise](UniFFITaskPromise::ResolveOrRejectValue&& aResult) {
            if (!aResult.IsResolve()) {
                uniFFIReturnPromise->MaybeRejectWithUnknownError("SpritesScaffolding::FfiSprites850SpriteObjectFree task dispatch failed");
                return;
            }

            AutoEntryScript aes(uniFFIXPCOMGlobal, "SpritesScaffolding::FfiSprites850SpriteObjectFree call resolve");
            RootedDictionary<UniFFIRustCallResult> returnValue(aes.cx());

            ffi_sprites_850_sprite_object_free::ReturnResult(aes.cx(), aResult.ResolveValue(), returnValue);
            uniFFIReturnPromise->MaybeResolve(returnValue);
            }
    );

    // Return the JS promise, using forget() to convert it to already_AddRefed
    return uniFFIReturnPromise.forget();
}
using namespace uniffi::sprites;
already_AddRefed<Promise> SpritesScaffolding::Sprites850SpriteNew(const GlobalObject& aUniFFIGlobal,const ArrayBuffer& initialPosition,
 ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args

    // Create the promise that we return to JS
    nsCOMPtr<nsIGlobalObject> uniFFIXPCOMGlobal = do_QueryInterface(aUniFFIGlobal.GetAsSupports());
    RefPtr<Promise> uniFFIReturnPromise = Promise::Create(uniFFIXPCOMGlobal, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Prepare arguments to pass to Rust
    auto uniFFIArgs = sprites_850_sprite_new::PrepareArgs(initialPosition, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Create a second promise that gets resolved by a background task that calls the scaffolding function
    using UniFFITaskPromise = MozPromise<sprites_850_sprite_new::Result, nsresult, true>;
    RefPtr uniFFITaskPromise = new UniFFITaskPromise::Private(__func__);
    nsresult uniFFIDispatchResult = NS_DispatchBackgroundTask(
            NS_NewRunnableFunction(
                "SpritesScaffolding::Sprites850SpriteNew",
                [args = std::move(uniFFIArgs), uniFFITaskPromise]() mutable {
                auto result = sprites_850_sprite_new::Invoke(args);
                uniFFITaskPromise->Resolve(std::move(result), __func__);
            }),
            NS_DISPATCH_EVENT_MAY_BLOCK);
    if (NS_FAILED(uniFFIDispatchResult)) {
        uniFFITaskPromise->Reject(uniFFIDispatchResult, __func__);
    }

    // When the background task promise completes, resolve the JS promise
    uniFFITaskPromise->Then(GetCurrentSerialEventTarget(), __func__,
            [uniFFIXPCOMGlobal, uniFFIReturnPromise](UniFFITaskPromise::ResolveOrRejectValue&& aResult) {
            if (!aResult.IsResolve()) {
                uniFFIReturnPromise->MaybeRejectWithUnknownError("SpritesScaffolding::Sprites850SpriteNew task dispatch failed");
                return;
            }

            AutoEntryScript aes(uniFFIXPCOMGlobal, "SpritesScaffolding::Sprites850SpriteNew call resolve");
            RootedDictionary<UniFFIRustCallResult> returnValue(aes.cx());

            sprites_850_sprite_new::ReturnResult(aes.cx(), aResult.ResolveValue(), returnValue);
            uniFFIReturnPromise->MaybeResolve(returnValue);
            }
    );

    // Return the JS promise, using forget() to convert it to already_AddRefed
    return uniFFIReturnPromise.forget();
}
using namespace uniffi::sprites;
already_AddRefed<Promise> SpritesScaffolding::Sprites850SpriteNewRelativeTo(const GlobalObject& aUniFFIGlobal,const ArrayBuffer& reference, const ArrayBuffer& direction,
 ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args

    // Create the promise that we return to JS
    nsCOMPtr<nsIGlobalObject> uniFFIXPCOMGlobal = do_QueryInterface(aUniFFIGlobal.GetAsSupports());
    RefPtr<Promise> uniFFIReturnPromise = Promise::Create(uniFFIXPCOMGlobal, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Prepare arguments to pass to Rust
    auto uniFFIArgs = sprites_850_sprite_new_relative_to::PrepareArgs(reference, direction, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Create a second promise that gets resolved by a background task that calls the scaffolding function
    using UniFFITaskPromise = MozPromise<sprites_850_sprite_new_relative_to::Result, nsresult, true>;
    RefPtr uniFFITaskPromise = new UniFFITaskPromise::Private(__func__);
    nsresult uniFFIDispatchResult = NS_DispatchBackgroundTask(
            NS_NewRunnableFunction(
                "SpritesScaffolding::Sprites850SpriteNewRelativeTo",
                [args = std::move(uniFFIArgs), uniFFITaskPromise]() mutable {
                auto result = sprites_850_sprite_new_relative_to::Invoke(args);
                uniFFITaskPromise->Resolve(std::move(result), __func__);
            }),
            NS_DISPATCH_EVENT_MAY_BLOCK);
    if (NS_FAILED(uniFFIDispatchResult)) {
        uniFFITaskPromise->Reject(uniFFIDispatchResult, __func__);
    }

    // When the background task promise completes, resolve the JS promise
    uniFFITaskPromise->Then(GetCurrentSerialEventTarget(), __func__,
            [uniFFIXPCOMGlobal, uniFFIReturnPromise](UniFFITaskPromise::ResolveOrRejectValue&& aResult) {
            if (!aResult.IsResolve()) {
                uniFFIReturnPromise->MaybeRejectWithUnknownError("SpritesScaffolding::Sprites850SpriteNewRelativeTo task dispatch failed");
                return;
            }

            AutoEntryScript aes(uniFFIXPCOMGlobal, "SpritesScaffolding::Sprites850SpriteNewRelativeTo call resolve");
            RootedDictionary<UniFFIRustCallResult> returnValue(aes.cx());

            sprites_850_sprite_new_relative_to::ReturnResult(aes.cx(), aResult.ResolveValue(), returnValue);
            uniFFIReturnPromise->MaybeResolve(returnValue);
            }
    );

    // Return the JS promise, using forget() to convert it to already_AddRefed
    return uniFFIReturnPromise.forget();
}
using namespace uniffi::sprites;
already_AddRefed<Promise> SpritesScaffolding::Sprites850SpriteGetPosition(const GlobalObject& aUniFFIGlobal,const JS::Handle<JS::Value>& ptr,
 ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args

    // Create the promise that we return to JS
    nsCOMPtr<nsIGlobalObject> uniFFIXPCOMGlobal = do_QueryInterface(aUniFFIGlobal.GetAsSupports());
    RefPtr<Promise> uniFFIReturnPromise = Promise::Create(uniFFIXPCOMGlobal, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Prepare arguments to pass to Rust
    auto uniFFIArgs = sprites_850_sprite_get_position::PrepareArgs(ptr, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Create a second promise that gets resolved by a background task that calls the scaffolding function
    using UniFFITaskPromise = MozPromise<sprites_850_sprite_get_position::Result, nsresult, true>;
    RefPtr uniFFITaskPromise = new UniFFITaskPromise::Private(__func__);
    nsresult uniFFIDispatchResult = NS_DispatchBackgroundTask(
            NS_NewRunnableFunction(
                "SpritesScaffolding::Sprites850SpriteGetPosition",
                [args = std::move(uniFFIArgs), uniFFITaskPromise]() mutable {
                auto result = sprites_850_sprite_get_position::Invoke(args);
                uniFFITaskPromise->Resolve(std::move(result), __func__);
            }),
            NS_DISPATCH_EVENT_MAY_BLOCK);
    if (NS_FAILED(uniFFIDispatchResult)) {
        uniFFITaskPromise->Reject(uniFFIDispatchResult, __func__);
    }

    // When the background task promise completes, resolve the JS promise
    uniFFITaskPromise->Then(GetCurrentSerialEventTarget(), __func__,
            [uniFFIXPCOMGlobal, uniFFIReturnPromise](UniFFITaskPromise::ResolveOrRejectValue&& aResult) {
            if (!aResult.IsResolve()) {
                uniFFIReturnPromise->MaybeRejectWithUnknownError("SpritesScaffolding::Sprites850SpriteGetPosition task dispatch failed");
                return;
            }

            AutoEntryScript aes(uniFFIXPCOMGlobal, "SpritesScaffolding::Sprites850SpriteGetPosition call resolve");
            RootedDictionary<UniFFIRustCallResult> returnValue(aes.cx());

            sprites_850_sprite_get_position::ReturnResult(aes.cx(), aResult.ResolveValue(), returnValue);
            uniFFIReturnPromise->MaybeResolve(returnValue);
            }
    );

    // Return the JS promise, using forget() to convert it to already_AddRefed
    return uniFFIReturnPromise.forget();
}
using namespace uniffi::sprites;
already_AddRefed<Promise> SpritesScaffolding::Sprites850SpriteMoveTo(const GlobalObject& aUniFFIGlobal,const JS::Handle<JS::Value>& ptr, const ArrayBuffer& position,
 ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args

    // Create the promise that we return to JS
    nsCOMPtr<nsIGlobalObject> uniFFIXPCOMGlobal = do_QueryInterface(aUniFFIGlobal.GetAsSupports());
    RefPtr<Promise> uniFFIReturnPromise = Promise::Create(uniFFIXPCOMGlobal, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Prepare arguments to pass to Rust
    auto uniFFIArgs = sprites_850_sprite_move_to::PrepareArgs(ptr, position, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Create a second promise that gets resolved by a background task that calls the scaffolding function
    using UniFFITaskPromise = MozPromise<sprites_850_sprite_move_to::Result, nsresult, true>;
    RefPtr uniFFITaskPromise = new UniFFITaskPromise::Private(__func__);
    nsresult uniFFIDispatchResult = NS_DispatchBackgroundTask(
            NS_NewRunnableFunction(
                "SpritesScaffolding::Sprites850SpriteMoveTo",
                [args = std::move(uniFFIArgs), uniFFITaskPromise]() mutable {
                auto result = sprites_850_sprite_move_to::Invoke(args);
                uniFFITaskPromise->Resolve(std::move(result), __func__);
            }),
            NS_DISPATCH_EVENT_MAY_BLOCK);
    if (NS_FAILED(uniFFIDispatchResult)) {
        uniFFITaskPromise->Reject(uniFFIDispatchResult, __func__);
    }

    // When the background task promise completes, resolve the JS promise
    uniFFITaskPromise->Then(GetCurrentSerialEventTarget(), __func__,
            [uniFFIXPCOMGlobal, uniFFIReturnPromise](UniFFITaskPromise::ResolveOrRejectValue&& aResult) {
            if (!aResult.IsResolve()) {
                uniFFIReturnPromise->MaybeRejectWithUnknownError("SpritesScaffolding::Sprites850SpriteMoveTo task dispatch failed");
                return;
            }

            AutoEntryScript aes(uniFFIXPCOMGlobal, "SpritesScaffolding::Sprites850SpriteMoveTo call resolve");
            RootedDictionary<UniFFIRustCallResult> returnValue(aes.cx());

            sprites_850_sprite_move_to::ReturnResult(aes.cx(), aResult.ResolveValue(), returnValue);
            uniFFIReturnPromise->MaybeResolve(returnValue);
            }
    );

    // Return the JS promise, using forget() to convert it to already_AddRefed
    return uniFFIReturnPromise.forget();
}
using namespace uniffi::sprites;
already_AddRefed<Promise> SpritesScaffolding::Sprites850SpriteMoveBy(const GlobalObject& aUniFFIGlobal,const JS::Handle<JS::Value>& ptr, const ArrayBuffer& direction,
 ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args

    // Create the promise that we return to JS
    nsCOMPtr<nsIGlobalObject> uniFFIXPCOMGlobal = do_QueryInterface(aUniFFIGlobal.GetAsSupports());
    RefPtr<Promise> uniFFIReturnPromise = Promise::Create(uniFFIXPCOMGlobal, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Prepare arguments to pass to Rust
    auto uniFFIArgs = sprites_850_sprite_move_by::PrepareArgs(ptr, direction, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Create a second promise that gets resolved by a background task that calls the scaffolding function
    using UniFFITaskPromise = MozPromise<sprites_850_sprite_move_by::Result, nsresult, true>;
    RefPtr uniFFITaskPromise = new UniFFITaskPromise::Private(__func__);
    nsresult uniFFIDispatchResult = NS_DispatchBackgroundTask(
            NS_NewRunnableFunction(
                "SpritesScaffolding::Sprites850SpriteMoveBy",
                [args = std::move(uniFFIArgs), uniFFITaskPromise]() mutable {
                auto result = sprites_850_sprite_move_by::Invoke(args);
                uniFFITaskPromise->Resolve(std::move(result), __func__);
            }),
            NS_DISPATCH_EVENT_MAY_BLOCK);
    if (NS_FAILED(uniFFIDispatchResult)) {
        uniFFITaskPromise->Reject(uniFFIDispatchResult, __func__);
    }

    // When the background task promise completes, resolve the JS promise
    uniFFITaskPromise->Then(GetCurrentSerialEventTarget(), __func__,
            [uniFFIXPCOMGlobal, uniFFIReturnPromise](UniFFITaskPromise::ResolveOrRejectValue&& aResult) {
            if (!aResult.IsResolve()) {
                uniFFIReturnPromise->MaybeRejectWithUnknownError("SpritesScaffolding::Sprites850SpriteMoveBy task dispatch failed");
                return;
            }

            AutoEntryScript aes(uniFFIXPCOMGlobal, "SpritesScaffolding::Sprites850SpriteMoveBy call resolve");
            RootedDictionary<UniFFIRustCallResult> returnValue(aes.cx());

            sprites_850_sprite_move_by::ReturnResult(aes.cx(), aResult.ResolveValue(), returnValue);
            uniFFIReturnPromise->MaybeResolve(returnValue);
            }
    );

    // Return the JS promise, using forget() to convert it to already_AddRefed
    return uniFFIReturnPromise.forget();
}
using namespace uniffi::sprites;
already_AddRefed<Promise> SpritesScaffolding::Sprites850Translate(const GlobalObject& aUniFFIGlobal,const ArrayBuffer& position, const ArrayBuffer& direction,
 ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args

    // Create the promise that we return to JS
    nsCOMPtr<nsIGlobalObject> uniFFIXPCOMGlobal = do_QueryInterface(aUniFFIGlobal.GetAsSupports());
    RefPtr<Promise> uniFFIReturnPromise = Promise::Create(uniFFIXPCOMGlobal, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Prepare arguments to pass to Rust
    auto uniFFIArgs = sprites_850_translate::PrepareArgs(position, direction, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Create a second promise that gets resolved by a background task that calls the scaffolding function
    using UniFFITaskPromise = MozPromise<sprites_850_translate::Result, nsresult, true>;
    RefPtr uniFFITaskPromise = new UniFFITaskPromise::Private(__func__);
    nsresult uniFFIDispatchResult = NS_DispatchBackgroundTask(
            NS_NewRunnableFunction(
                "SpritesScaffolding::Sprites850Translate",
                [args = std::move(uniFFIArgs), uniFFITaskPromise]() mutable {
                auto result = sprites_850_translate::Invoke(args);
                uniFFITaskPromise->Resolve(std::move(result), __func__);
            }),
            NS_DISPATCH_EVENT_MAY_BLOCK);
    if (NS_FAILED(uniFFIDispatchResult)) {
        uniFFITaskPromise->Reject(uniFFIDispatchResult, __func__);
    }

    // When the background task promise completes, resolve the JS promise
    uniFFITaskPromise->Then(GetCurrentSerialEventTarget(), __func__,
            [uniFFIXPCOMGlobal, uniFFIReturnPromise](UniFFITaskPromise::ResolveOrRejectValue&& aResult) {
            if (!aResult.IsResolve()) {
                uniFFIReturnPromise->MaybeRejectWithUnknownError("SpritesScaffolding::Sprites850Translate task dispatch failed");
                return;
            }

            AutoEntryScript aes(uniFFIXPCOMGlobal, "SpritesScaffolding::Sprites850Translate call resolve");
            RootedDictionary<UniFFIRustCallResult> returnValue(aes.cx());

            sprites_850_translate::ReturnResult(aes.cx(), aResult.ResolveValue(), returnValue);
            uniFFIReturnPromise->MaybeResolve(returnValue);
            }
    );

    // Return the JS promise, using forget() to convert it to already_AddRefed
    return uniFFIReturnPromise.forget();
}

}  // namespace mozilla::dom