// This file was autogenerated by some hot garbage in the `uniffi-bindgen-gecko-js` crate.
// Trust me, you don't want to mess with it!

#include "nsIGlobalObject.h"
#include "mozilla/MozPromise.h"
#include "mozilla/dom/TodolistScaffolding.h"
#include "mozilla/dom/OwnedRustBuffer.h"
#include "mozilla/dom/Promise.h"
#include "mozilla/Logging.h"
#include "mozilla/EndianUtils.h"

static mozilla::LazyLogModule sUniFFITodolistScaffoldingLogger("uniffi_logger");


namespace uniffi::todolist {
// For each Rust scaffolding function, define types and functions for calling it
namespace ffi_todolist_126_todo_list_object_free {
using namespace mozilla::dom;
// Arguments to pass to the scaffolding function
struct Args {
    void * ptr;
};

// Return values from the scaffolding function
struct Result {
    RustCallStatus mCallStatus = {};
};

// Convert the arguments we get from JS to arguments to pass to Rust.
//
// On error, an error code will be stored in result.  Make sure to check this before
// passing the args to Invoke().
//
// For async calls this should be called in the main thread, since the GC can
// move the ArrayBuffer pointers while the background task is waiting.
Args PrepareArgs(const UniFFIPointer& ptr,
    mozilla::ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args
    Args uniFFIArgs;
    // We check if the pointer in the argument passed has the same type expected by this
    // function
    if (!ptr.IsSamePtrType(&TodoListPointerType::getInstance())) {
        aUniFFIError.ThrowTypeError("pointer ptr is not of type TodoList");
        return uniFFIArgs;
    }
    uniFFIArgs.ptr = ptr.GetPtr();

    return uniFFIArgs;
}

// Call the scaffolding function
//
// For async calls this should be called in the worker thread
Result Invoke(Args& aArgs) {
    Result result = {};::ffi_todolist_126_TodoList_object_free(
         aArgs.ptr,
         &result.mCallStatus
     );
    return result;
}

// Return the result of the scaffolding call back to JS
void ReturnResult(JSContext* aContext, const Result& aCallResult, RootedDictionary<UniFFIRustCallResult>& aReturnValue) {
    switch (aCallResult.mCallStatus.code) {
        case uniffi::CALL_SUCCESS: {
            // Successful call.  Populate data with the return value
            aReturnValue.mCode = uniffi::CALL_SUCCESS;
            // Void return
            break;
        }

        case uniffi::CALL_ERROR:
            // Rust Err() value.  Populate data with the `RustBuffer` containing the error
            aReturnValue.mCode = uniffi::CALL_ERROR;
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mCallStatus.error_buf).intoArrayBuffer(aContext));
            break;

        default:
            // This indicates a RustError, which shouldn't happen in practice since FF sets panic=abort
            aReturnValue.mCode = uniffi::CALL_INTERNAL_ERROR;
            aReturnValue.mInternalErrorMessage.AssignLiteral(u"Unexpected Error");
            break;
    }
}
}
// For each Rust scaffolding function, define types and functions for calling it
namespace todolist_126_todo_list_new {
using namespace mozilla::dom;
// Arguments to pass to the scaffolding function
struct Args {
};

// Return values from the scaffolding function
struct Result {
    void * mReturnValue;
    RustCallStatus mCallStatus = {};
};

// Convert the arguments we get from JS to arguments to pass to Rust.
//
// On error, an error code will be stored in result.  Make sure to check this before
// passing the args to Invoke().
//
// For async calls this should be called in the main thread, since the GC can
// move the ArrayBuffer pointers while the background task is waiting.
Args PrepareArgs(
    mozilla::ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args
    Args uniFFIArgs;

    return uniFFIArgs;
}

// Call the scaffolding function
//
// For async calls this should be called in the worker thread
Result Invoke(Args& aArgs) {
    Result result = {};result.mReturnValue =::todolist_126_TodoList_new(
         &result.mCallStatus
     );
    return result;
}

// Return the result of the scaffolding call back to JS
void ReturnResult(JSContext* aContext, const Result& aCallResult, RootedDictionary<UniFFIRustCallResult>& aReturnValue) {
    switch (aCallResult.mCallStatus.code) {
        case uniffi::CALL_SUCCESS: {
            // Successful call.  Populate data with the return value
            aReturnValue.mCode = uniffi::CALL_SUCCESS;
            RefPtr<UniFFIPointer> uniFFIPtr = UniFFIPointer::Create(aCallResult.mReturnValue, &TodoListPointerType::getInstance() );
            aReturnValue.mData.setObjectOrNull(uniFFIPtr->WrapObject(aContext, nullptr));
            break;
        }

        case uniffi::CALL_ERROR:
            // Rust Err() value.  Populate data with the `RustBuffer` containing the error
            aReturnValue.mCode = uniffi::CALL_ERROR;
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mCallStatus.error_buf).intoArrayBuffer(aContext));
            break;

        default:
            // This indicates a RustError, which shouldn't happen in practice since FF sets panic=abort
            aReturnValue.mCode = uniffi::CALL_INTERNAL_ERROR;
            aReturnValue.mInternalErrorMessage.AssignLiteral(u"Unexpected Error");
            break;
    }
}
}
// For each Rust scaffolding function, define types and functions for calling it
namespace todolist_126_todo_list_add_item {
using namespace mozilla::dom;
// Arguments to pass to the scaffolding function
struct Args {
    void * ptr;
    // RustBuffer arguments are stored as OwnedRustBuffer instances.  That class takes care of
    // freeing the buffer if the arguments don't get passed to Rust (i.e. intoRustBuffer()
    // isn't called).  This can happen if some of the ArrayBuffer arguments are succuessfully
    // converted, but one fails to convert.
    mozilla::dom::OwnedRustBuffer todo;
};

// Return values from the scaffolding function
struct Result {
    RustCallStatus mCallStatus = {};
};

// Convert the arguments we get from JS to arguments to pass to Rust.
//
// On error, an error code will be stored in result.  Make sure to check this before
// passing the args to Invoke().
//
// For async calls this should be called in the main thread, since the GC can
// move the ArrayBuffer pointers while the background task is waiting.
Args PrepareArgs(const UniFFIPointer& ptr, const ArrayBuffer& todo,
    mozilla::ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args
    Args uniFFIArgs;
    // We check if the pointer in the argument passed has the same type expected by this
    // function
    if (!ptr.IsSamePtrType(&TodoListPointerType::getInstance())) {
        aUniFFIError.ThrowTypeError("pointer ptr is not of type TodoList");
        return uniFFIArgs;
    }
    uniFFIArgs.ptr = ptr.GetPtr();
    // Convert the ArrayBuffer we get from JS to an OwnedRustBuffer
    todo.ComputeState();
    uniFFIArgs.todo = OwnedRustBuffer(todo, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return uniFFIArgs;
    }

    return uniFFIArgs;
}

// Call the scaffolding function
//
// For async calls this should be called in the worker thread
Result Invoke(Args& aArgs) {
    Result result = {};::todolist_126_TodoList_add_item(
         aArgs.ptr,
         // Call intoRustBuffer() to get a `RustBuffer` from an OwnedRustBuffer.  This transfers ownership to Rust,
         // OwnedRustBuffer will no longer try to free it
         aArgs.todo.intoRustBuffer(),
         &result.mCallStatus
     );
    return result;
}

// Return the result of the scaffolding call back to JS
void ReturnResult(JSContext* aContext, const Result& aCallResult, RootedDictionary<UniFFIRustCallResult>& aReturnValue) {
    switch (aCallResult.mCallStatus.code) {
        case uniffi::CALL_SUCCESS: {
            // Successful call.  Populate data with the return value
            aReturnValue.mCode = uniffi::CALL_SUCCESS;
            // Void return
            break;
        }

        case uniffi::CALL_ERROR:
            // Rust Err() value.  Populate data with the `RustBuffer` containing the error
            aReturnValue.mCode = uniffi::CALL_ERROR;
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mCallStatus.error_buf).intoArrayBuffer(aContext));
            break;

        default:
            // This indicates a RustError, which shouldn't happen in practice since FF sets panic=abort
            aReturnValue.mCode = uniffi::CALL_INTERNAL_ERROR;
            aReturnValue.mInternalErrorMessage.AssignLiteral(u"Unexpected Error");
            break;
    }
}
}
// For each Rust scaffolding function, define types and functions for calling it
namespace todolist_126_todo_list_add_entry {
using namespace mozilla::dom;
// Arguments to pass to the scaffolding function
struct Args {
    void * ptr;
    // RustBuffer arguments are stored as OwnedRustBuffer instances.  That class takes care of
    // freeing the buffer if the arguments don't get passed to Rust (i.e. intoRustBuffer()
    // isn't called).  This can happen if some of the ArrayBuffer arguments are succuessfully
    // converted, but one fails to convert.
    mozilla::dom::OwnedRustBuffer entry;
};

// Return values from the scaffolding function
struct Result {
    RustCallStatus mCallStatus = {};
};

// Convert the arguments we get from JS to arguments to pass to Rust.
//
// On error, an error code will be stored in result.  Make sure to check this before
// passing the args to Invoke().
//
// For async calls this should be called in the main thread, since the GC can
// move the ArrayBuffer pointers while the background task is waiting.
Args PrepareArgs(const UniFFIPointer& ptr, const ArrayBuffer& entry,
    mozilla::ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args
    Args uniFFIArgs;
    // We check if the pointer in the argument passed has the same type expected by this
    // function
    if (!ptr.IsSamePtrType(&TodoListPointerType::getInstance())) {
        aUniFFIError.ThrowTypeError("pointer ptr is not of type TodoList");
        return uniFFIArgs;
    }
    uniFFIArgs.ptr = ptr.GetPtr();
    // Convert the ArrayBuffer we get from JS to an OwnedRustBuffer
    entry.ComputeState();
    uniFFIArgs.entry = OwnedRustBuffer(entry, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return uniFFIArgs;
    }

    return uniFFIArgs;
}

// Call the scaffolding function
//
// For async calls this should be called in the worker thread
Result Invoke(Args& aArgs) {
    Result result = {};::todolist_126_TodoList_add_entry(
         aArgs.ptr,
         // Call intoRustBuffer() to get a `RustBuffer` from an OwnedRustBuffer.  This transfers ownership to Rust,
         // OwnedRustBuffer will no longer try to free it
         aArgs.entry.intoRustBuffer(),
         &result.mCallStatus
     );
    return result;
}

// Return the result of the scaffolding call back to JS
void ReturnResult(JSContext* aContext, const Result& aCallResult, RootedDictionary<UniFFIRustCallResult>& aReturnValue) {
    switch (aCallResult.mCallStatus.code) {
        case uniffi::CALL_SUCCESS: {
            // Successful call.  Populate data with the return value
            aReturnValue.mCode = uniffi::CALL_SUCCESS;
            // Void return
            break;
        }

        case uniffi::CALL_ERROR:
            // Rust Err() value.  Populate data with the `RustBuffer` containing the error
            aReturnValue.mCode = uniffi::CALL_ERROR;
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mCallStatus.error_buf).intoArrayBuffer(aContext));
            break;

        default:
            // This indicates a RustError, which shouldn't happen in practice since FF sets panic=abort
            aReturnValue.mCode = uniffi::CALL_INTERNAL_ERROR;
            aReturnValue.mInternalErrorMessage.AssignLiteral(u"Unexpected Error");
            break;
    }
}
}
// For each Rust scaffolding function, define types and functions for calling it
namespace todolist_126_todo_list_get_entries {
using namespace mozilla::dom;
// Arguments to pass to the scaffolding function
struct Args {
    void * ptr;
};

// Return values from the scaffolding function
struct Result {
    RustBuffer mReturnValue;
    RustCallStatus mCallStatus = {};
};

// Convert the arguments we get from JS to arguments to pass to Rust.
//
// On error, an error code will be stored in result.  Make sure to check this before
// passing the args to Invoke().
//
// For async calls this should be called in the main thread, since the GC can
// move the ArrayBuffer pointers while the background task is waiting.
Args PrepareArgs(const UniFFIPointer& ptr,
    mozilla::ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args
    Args uniFFIArgs;
    // We check if the pointer in the argument passed has the same type expected by this
    // function
    if (!ptr.IsSamePtrType(&TodoListPointerType::getInstance())) {
        aUniFFIError.ThrowTypeError("pointer ptr is not of type TodoList");
        return uniFFIArgs;
    }
    uniFFIArgs.ptr = ptr.GetPtr();

    return uniFFIArgs;
}

// Call the scaffolding function
//
// For async calls this should be called in the worker thread
Result Invoke(Args& aArgs) {
    Result result = {};result.mReturnValue =::todolist_126_TodoList_get_entries(
         aArgs.ptr,
         &result.mCallStatus
     );
    return result;
}

// Return the result of the scaffolding call back to JS
void ReturnResult(JSContext* aContext, const Result& aCallResult, RootedDictionary<UniFFIRustCallResult>& aReturnValue) {
    switch (aCallResult.mCallStatus.code) {
        case uniffi::CALL_SUCCESS: {
            // Successful call.  Populate data with the return value
            aReturnValue.mCode = uniffi::CALL_SUCCESS;
            // RustBuffer return, convert it to an ArrayBuffer
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mReturnValue).intoArrayBuffer(aContext));
            break;
        }

        case uniffi::CALL_ERROR:
            // Rust Err() value.  Populate data with the `RustBuffer` containing the error
            aReturnValue.mCode = uniffi::CALL_ERROR;
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mCallStatus.error_buf).intoArrayBuffer(aContext));
            break;

        default:
            // This indicates a RustError, which shouldn't happen in practice since FF sets panic=abort
            aReturnValue.mCode = uniffi::CALL_INTERNAL_ERROR;
            aReturnValue.mInternalErrorMessage.AssignLiteral(u"Unexpected Error");
            break;
    }
}
}
// For each Rust scaffolding function, define types and functions for calling it
namespace todolist_126_todo_list_get_items {
using namespace mozilla::dom;
// Arguments to pass to the scaffolding function
struct Args {
    void * ptr;
};

// Return values from the scaffolding function
struct Result {
    RustBuffer mReturnValue;
    RustCallStatus mCallStatus = {};
};

// Convert the arguments we get from JS to arguments to pass to Rust.
//
// On error, an error code will be stored in result.  Make sure to check this before
// passing the args to Invoke().
//
// For async calls this should be called in the main thread, since the GC can
// move the ArrayBuffer pointers while the background task is waiting.
Args PrepareArgs(const UniFFIPointer& ptr,
    mozilla::ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args
    Args uniFFIArgs;
    // We check if the pointer in the argument passed has the same type expected by this
    // function
    if (!ptr.IsSamePtrType(&TodoListPointerType::getInstance())) {
        aUniFFIError.ThrowTypeError("pointer ptr is not of type TodoList");
        return uniFFIArgs;
    }
    uniFFIArgs.ptr = ptr.GetPtr();

    return uniFFIArgs;
}

// Call the scaffolding function
//
// For async calls this should be called in the worker thread
Result Invoke(Args& aArgs) {
    Result result = {};result.mReturnValue =::todolist_126_TodoList_get_items(
         aArgs.ptr,
         &result.mCallStatus
     );
    return result;
}

// Return the result of the scaffolding call back to JS
void ReturnResult(JSContext* aContext, const Result& aCallResult, RootedDictionary<UniFFIRustCallResult>& aReturnValue) {
    switch (aCallResult.mCallStatus.code) {
        case uniffi::CALL_SUCCESS: {
            // Successful call.  Populate data with the return value
            aReturnValue.mCode = uniffi::CALL_SUCCESS;
            // RustBuffer return, convert it to an ArrayBuffer
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mReturnValue).intoArrayBuffer(aContext));
            break;
        }

        case uniffi::CALL_ERROR:
            // Rust Err() value.  Populate data with the `RustBuffer` containing the error
            aReturnValue.mCode = uniffi::CALL_ERROR;
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mCallStatus.error_buf).intoArrayBuffer(aContext));
            break;

        default:
            // This indicates a RustError, which shouldn't happen in practice since FF sets panic=abort
            aReturnValue.mCode = uniffi::CALL_INTERNAL_ERROR;
            aReturnValue.mInternalErrorMessage.AssignLiteral(u"Unexpected Error");
            break;
    }
}
}
// For each Rust scaffolding function, define types and functions for calling it
namespace todolist_126_todo_list_add_entries {
using namespace mozilla::dom;
// Arguments to pass to the scaffolding function
struct Args {
    void * ptr;
    // RustBuffer arguments are stored as OwnedRustBuffer instances.  That class takes care of
    // freeing the buffer if the arguments don't get passed to Rust (i.e. intoRustBuffer()
    // isn't called).  This can happen if some of the ArrayBuffer arguments are succuessfully
    // converted, but one fails to convert.
    mozilla::dom::OwnedRustBuffer entries;
};

// Return values from the scaffolding function
struct Result {
    RustCallStatus mCallStatus = {};
};

// Convert the arguments we get from JS to arguments to pass to Rust.
//
// On error, an error code will be stored in result.  Make sure to check this before
// passing the args to Invoke().
//
// For async calls this should be called in the main thread, since the GC can
// move the ArrayBuffer pointers while the background task is waiting.
Args PrepareArgs(const UniFFIPointer& ptr, const ArrayBuffer& entries,
    mozilla::ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args
    Args uniFFIArgs;
    // We check if the pointer in the argument passed has the same type expected by this
    // function
    if (!ptr.IsSamePtrType(&TodoListPointerType::getInstance())) {
        aUniFFIError.ThrowTypeError("pointer ptr is not of type TodoList");
        return uniFFIArgs;
    }
    uniFFIArgs.ptr = ptr.GetPtr();
    // Convert the ArrayBuffer we get from JS to an OwnedRustBuffer
    entries.ComputeState();
    uniFFIArgs.entries = OwnedRustBuffer(entries, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return uniFFIArgs;
    }

    return uniFFIArgs;
}

// Call the scaffolding function
//
// For async calls this should be called in the worker thread
Result Invoke(Args& aArgs) {
    Result result = {};::todolist_126_TodoList_add_entries(
         aArgs.ptr,
         // Call intoRustBuffer() to get a `RustBuffer` from an OwnedRustBuffer.  This transfers ownership to Rust,
         // OwnedRustBuffer will no longer try to free it
         aArgs.entries.intoRustBuffer(),
         &result.mCallStatus
     );
    return result;
}

// Return the result of the scaffolding call back to JS
void ReturnResult(JSContext* aContext, const Result& aCallResult, RootedDictionary<UniFFIRustCallResult>& aReturnValue) {
    switch (aCallResult.mCallStatus.code) {
        case uniffi::CALL_SUCCESS: {
            // Successful call.  Populate data with the return value
            aReturnValue.mCode = uniffi::CALL_SUCCESS;
            // Void return
            break;
        }

        case uniffi::CALL_ERROR:
            // Rust Err() value.  Populate data with the `RustBuffer` containing the error
            aReturnValue.mCode = uniffi::CALL_ERROR;
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mCallStatus.error_buf).intoArrayBuffer(aContext));
            break;

        default:
            // This indicates a RustError, which shouldn't happen in practice since FF sets panic=abort
            aReturnValue.mCode = uniffi::CALL_INTERNAL_ERROR;
            aReturnValue.mInternalErrorMessage.AssignLiteral(u"Unexpected Error");
            break;
    }
}
}
// For each Rust scaffolding function, define types and functions for calling it
namespace todolist_126_todo_list_add_items {
using namespace mozilla::dom;
// Arguments to pass to the scaffolding function
struct Args {
    void * ptr;
    // RustBuffer arguments are stored as OwnedRustBuffer instances.  That class takes care of
    // freeing the buffer if the arguments don't get passed to Rust (i.e. intoRustBuffer()
    // isn't called).  This can happen if some of the ArrayBuffer arguments are succuessfully
    // converted, but one fails to convert.
    mozilla::dom::OwnedRustBuffer items;
};

// Return values from the scaffolding function
struct Result {
    RustCallStatus mCallStatus = {};
};

// Convert the arguments we get from JS to arguments to pass to Rust.
//
// On error, an error code will be stored in result.  Make sure to check this before
// passing the args to Invoke().
//
// For async calls this should be called in the main thread, since the GC can
// move the ArrayBuffer pointers while the background task is waiting.
Args PrepareArgs(const UniFFIPointer& ptr, const ArrayBuffer& items,
    mozilla::ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args
    Args uniFFIArgs;
    // We check if the pointer in the argument passed has the same type expected by this
    // function
    if (!ptr.IsSamePtrType(&TodoListPointerType::getInstance())) {
        aUniFFIError.ThrowTypeError("pointer ptr is not of type TodoList");
        return uniFFIArgs;
    }
    uniFFIArgs.ptr = ptr.GetPtr();
    // Convert the ArrayBuffer we get from JS to an OwnedRustBuffer
    items.ComputeState();
    uniFFIArgs.items = OwnedRustBuffer(items, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return uniFFIArgs;
    }

    return uniFFIArgs;
}

// Call the scaffolding function
//
// For async calls this should be called in the worker thread
Result Invoke(Args& aArgs) {
    Result result = {};::todolist_126_TodoList_add_items(
         aArgs.ptr,
         // Call intoRustBuffer() to get a `RustBuffer` from an OwnedRustBuffer.  This transfers ownership to Rust,
         // OwnedRustBuffer will no longer try to free it
         aArgs.items.intoRustBuffer(),
         &result.mCallStatus
     );
    return result;
}

// Return the result of the scaffolding call back to JS
void ReturnResult(JSContext* aContext, const Result& aCallResult, RootedDictionary<UniFFIRustCallResult>& aReturnValue) {
    switch (aCallResult.mCallStatus.code) {
        case uniffi::CALL_SUCCESS: {
            // Successful call.  Populate data with the return value
            aReturnValue.mCode = uniffi::CALL_SUCCESS;
            // Void return
            break;
        }

        case uniffi::CALL_ERROR:
            // Rust Err() value.  Populate data with the `RustBuffer` containing the error
            aReturnValue.mCode = uniffi::CALL_ERROR;
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mCallStatus.error_buf).intoArrayBuffer(aContext));
            break;

        default:
            // This indicates a RustError, which shouldn't happen in practice since FF sets panic=abort
            aReturnValue.mCode = uniffi::CALL_INTERNAL_ERROR;
            aReturnValue.mInternalErrorMessage.AssignLiteral(u"Unexpected Error");
            break;
    }
}
}
// For each Rust scaffolding function, define types and functions for calling it
namespace todolist_126_todo_list_get_last_entry {
using namespace mozilla::dom;
// Arguments to pass to the scaffolding function
struct Args {
    void * ptr;
};

// Return values from the scaffolding function
struct Result {
    RustBuffer mReturnValue;
    RustCallStatus mCallStatus = {};
};

// Convert the arguments we get from JS to arguments to pass to Rust.
//
// On error, an error code will be stored in result.  Make sure to check this before
// passing the args to Invoke().
//
// For async calls this should be called in the main thread, since the GC can
// move the ArrayBuffer pointers while the background task is waiting.
Args PrepareArgs(const UniFFIPointer& ptr,
    mozilla::ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args
    Args uniFFIArgs;
    // We check if the pointer in the argument passed has the same type expected by this
    // function
    if (!ptr.IsSamePtrType(&TodoListPointerType::getInstance())) {
        aUniFFIError.ThrowTypeError("pointer ptr is not of type TodoList");
        return uniFFIArgs;
    }
    uniFFIArgs.ptr = ptr.GetPtr();

    return uniFFIArgs;
}

// Call the scaffolding function
//
// For async calls this should be called in the worker thread
Result Invoke(Args& aArgs) {
    Result result = {};result.mReturnValue =::todolist_126_TodoList_get_last_entry(
         aArgs.ptr,
         &result.mCallStatus
     );
    return result;
}

// Return the result of the scaffolding call back to JS
void ReturnResult(JSContext* aContext, const Result& aCallResult, RootedDictionary<UniFFIRustCallResult>& aReturnValue) {
    switch (aCallResult.mCallStatus.code) {
        case uniffi::CALL_SUCCESS: {
            // Successful call.  Populate data with the return value
            aReturnValue.mCode = uniffi::CALL_SUCCESS;
            // RustBuffer return, convert it to an ArrayBuffer
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mReturnValue).intoArrayBuffer(aContext));
            break;
        }

        case uniffi::CALL_ERROR:
            // Rust Err() value.  Populate data with the `RustBuffer` containing the error
            aReturnValue.mCode = uniffi::CALL_ERROR;
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mCallStatus.error_buf).intoArrayBuffer(aContext));
            break;

        default:
            // This indicates a RustError, which shouldn't happen in practice since FF sets panic=abort
            aReturnValue.mCode = uniffi::CALL_INTERNAL_ERROR;
            aReturnValue.mInternalErrorMessage.AssignLiteral(u"Unexpected Error");
            break;
    }
}
}
// For each Rust scaffolding function, define types and functions for calling it
namespace todolist_126_todo_list_get_last {
using namespace mozilla::dom;
// Arguments to pass to the scaffolding function
struct Args {
    void * ptr;
};

// Return values from the scaffolding function
struct Result {
    RustBuffer mReturnValue;
    RustCallStatus mCallStatus = {};
};

// Convert the arguments we get from JS to arguments to pass to Rust.
//
// On error, an error code will be stored in result.  Make sure to check this before
// passing the args to Invoke().
//
// For async calls this should be called in the main thread, since the GC can
// move the ArrayBuffer pointers while the background task is waiting.
Args PrepareArgs(const UniFFIPointer& ptr,
    mozilla::ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args
    Args uniFFIArgs;
    // We check if the pointer in the argument passed has the same type expected by this
    // function
    if (!ptr.IsSamePtrType(&TodoListPointerType::getInstance())) {
        aUniFFIError.ThrowTypeError("pointer ptr is not of type TodoList");
        return uniFFIArgs;
    }
    uniFFIArgs.ptr = ptr.GetPtr();

    return uniFFIArgs;
}

// Call the scaffolding function
//
// For async calls this should be called in the worker thread
Result Invoke(Args& aArgs) {
    Result result = {};result.mReturnValue =::todolist_126_TodoList_get_last(
         aArgs.ptr,
         &result.mCallStatus
     );
    return result;
}

// Return the result of the scaffolding call back to JS
void ReturnResult(JSContext* aContext, const Result& aCallResult, RootedDictionary<UniFFIRustCallResult>& aReturnValue) {
    switch (aCallResult.mCallStatus.code) {
        case uniffi::CALL_SUCCESS: {
            // Successful call.  Populate data with the return value
            aReturnValue.mCode = uniffi::CALL_SUCCESS;
            // RustBuffer return, convert it to an ArrayBuffer
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mReturnValue).intoArrayBuffer(aContext));
            break;
        }

        case uniffi::CALL_ERROR:
            // Rust Err() value.  Populate data with the `RustBuffer` containing the error
            aReturnValue.mCode = uniffi::CALL_ERROR;
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mCallStatus.error_buf).intoArrayBuffer(aContext));
            break;

        default:
            // This indicates a RustError, which shouldn't happen in practice since FF sets panic=abort
            aReturnValue.mCode = uniffi::CALL_INTERNAL_ERROR;
            aReturnValue.mInternalErrorMessage.AssignLiteral(u"Unexpected Error");
            break;
    }
}
}
// For each Rust scaffolding function, define types and functions for calling it
namespace todolist_126_todo_list_get_first {
using namespace mozilla::dom;
// Arguments to pass to the scaffolding function
struct Args {
    void * ptr;
};

// Return values from the scaffolding function
struct Result {
    RustBuffer mReturnValue;
    RustCallStatus mCallStatus = {};
};

// Convert the arguments we get from JS to arguments to pass to Rust.
//
// On error, an error code will be stored in result.  Make sure to check this before
// passing the args to Invoke().
//
// For async calls this should be called in the main thread, since the GC can
// move the ArrayBuffer pointers while the background task is waiting.
Args PrepareArgs(const UniFFIPointer& ptr,
    mozilla::ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args
    Args uniFFIArgs;
    // We check if the pointer in the argument passed has the same type expected by this
    // function
    if (!ptr.IsSamePtrType(&TodoListPointerType::getInstance())) {
        aUniFFIError.ThrowTypeError("pointer ptr is not of type TodoList");
        return uniFFIArgs;
    }
    uniFFIArgs.ptr = ptr.GetPtr();

    return uniFFIArgs;
}

// Call the scaffolding function
//
// For async calls this should be called in the worker thread
Result Invoke(Args& aArgs) {
    Result result = {};result.mReturnValue =::todolist_126_TodoList_get_first(
         aArgs.ptr,
         &result.mCallStatus
     );
    return result;
}

// Return the result of the scaffolding call back to JS
void ReturnResult(JSContext* aContext, const Result& aCallResult, RootedDictionary<UniFFIRustCallResult>& aReturnValue) {
    switch (aCallResult.mCallStatus.code) {
        case uniffi::CALL_SUCCESS: {
            // Successful call.  Populate data with the return value
            aReturnValue.mCode = uniffi::CALL_SUCCESS;
            // RustBuffer return, convert it to an ArrayBuffer
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mReturnValue).intoArrayBuffer(aContext));
            break;
        }

        case uniffi::CALL_ERROR:
            // Rust Err() value.  Populate data with the `RustBuffer` containing the error
            aReturnValue.mCode = uniffi::CALL_ERROR;
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mCallStatus.error_buf).intoArrayBuffer(aContext));
            break;

        default:
            // This indicates a RustError, which shouldn't happen in practice since FF sets panic=abort
            aReturnValue.mCode = uniffi::CALL_INTERNAL_ERROR;
            aReturnValue.mInternalErrorMessage.AssignLiteral(u"Unexpected Error");
            break;
    }
}
}
// For each Rust scaffolding function, define types and functions for calling it
namespace todolist_126_todo_list_clear_item {
using namespace mozilla::dom;
// Arguments to pass to the scaffolding function
struct Args {
    void * ptr;
    // RustBuffer arguments are stored as OwnedRustBuffer instances.  That class takes care of
    // freeing the buffer if the arguments don't get passed to Rust (i.e. intoRustBuffer()
    // isn't called).  This can happen if some of the ArrayBuffer arguments are succuessfully
    // converted, but one fails to convert.
    mozilla::dom::OwnedRustBuffer todo;
};

// Return values from the scaffolding function
struct Result {
    RustCallStatus mCallStatus = {};
};

// Convert the arguments we get from JS to arguments to pass to Rust.
//
// On error, an error code will be stored in result.  Make sure to check this before
// passing the args to Invoke().
//
// For async calls this should be called in the main thread, since the GC can
// move the ArrayBuffer pointers while the background task is waiting.
Args PrepareArgs(const UniFFIPointer& ptr, const ArrayBuffer& todo,
    mozilla::ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args
    Args uniFFIArgs;
    // We check if the pointer in the argument passed has the same type expected by this
    // function
    if (!ptr.IsSamePtrType(&TodoListPointerType::getInstance())) {
        aUniFFIError.ThrowTypeError("pointer ptr is not of type TodoList");
        return uniFFIArgs;
    }
    uniFFIArgs.ptr = ptr.GetPtr();
    // Convert the ArrayBuffer we get from JS to an OwnedRustBuffer
    todo.ComputeState();
    uniFFIArgs.todo = OwnedRustBuffer(todo, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return uniFFIArgs;
    }

    return uniFFIArgs;
}

// Call the scaffolding function
//
// For async calls this should be called in the worker thread
Result Invoke(Args& aArgs) {
    Result result = {};::todolist_126_TodoList_clear_item(
         aArgs.ptr,
         // Call intoRustBuffer() to get a `RustBuffer` from an OwnedRustBuffer.  This transfers ownership to Rust,
         // OwnedRustBuffer will no longer try to free it
         aArgs.todo.intoRustBuffer(),
         &result.mCallStatus
     );
    return result;
}

// Return the result of the scaffolding call back to JS
void ReturnResult(JSContext* aContext, const Result& aCallResult, RootedDictionary<UniFFIRustCallResult>& aReturnValue) {
    switch (aCallResult.mCallStatus.code) {
        case uniffi::CALL_SUCCESS: {
            // Successful call.  Populate data with the return value
            aReturnValue.mCode = uniffi::CALL_SUCCESS;
            // Void return
            break;
        }

        case uniffi::CALL_ERROR:
            // Rust Err() value.  Populate data with the `RustBuffer` containing the error
            aReturnValue.mCode = uniffi::CALL_ERROR;
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mCallStatus.error_buf).intoArrayBuffer(aContext));
            break;

        default:
            // This indicates a RustError, which shouldn't happen in practice since FF sets panic=abort
            aReturnValue.mCode = uniffi::CALL_INTERNAL_ERROR;
            aReturnValue.mInternalErrorMessage.AssignLiteral(u"Unexpected Error");
            break;
    }
}
}
// For each Rust scaffolding function, define types and functions for calling it
namespace todolist_126_todo_list_make_default {
using namespace mozilla::dom;
// Arguments to pass to the scaffolding function
struct Args {
    void * ptr;
};

// Return values from the scaffolding function
struct Result {
    RustCallStatus mCallStatus = {};
};

// Convert the arguments we get from JS to arguments to pass to Rust.
//
// On error, an error code will be stored in result.  Make sure to check this before
// passing the args to Invoke().
//
// For async calls this should be called in the main thread, since the GC can
// move the ArrayBuffer pointers while the background task is waiting.
Args PrepareArgs(const UniFFIPointer& ptr,
    mozilla::ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args
    Args uniFFIArgs;
    // We check if the pointer in the argument passed has the same type expected by this
    // function
    if (!ptr.IsSamePtrType(&TodoListPointerType::getInstance())) {
        aUniFFIError.ThrowTypeError("pointer ptr is not of type TodoList");
        return uniFFIArgs;
    }
    uniFFIArgs.ptr = ptr.GetPtr();

    return uniFFIArgs;
}

// Call the scaffolding function
//
// For async calls this should be called in the worker thread
Result Invoke(Args& aArgs) {
    Result result = {};::todolist_126_TodoList_make_default(
         aArgs.ptr,
         &result.mCallStatus
     );
    return result;
}

// Return the result of the scaffolding call back to JS
void ReturnResult(JSContext* aContext, const Result& aCallResult, RootedDictionary<UniFFIRustCallResult>& aReturnValue) {
    switch (aCallResult.mCallStatus.code) {
        case uniffi::CALL_SUCCESS: {
            // Successful call.  Populate data with the return value
            aReturnValue.mCode = uniffi::CALL_SUCCESS;
            // Void return
            break;
        }

        case uniffi::CALL_ERROR:
            // Rust Err() value.  Populate data with the `RustBuffer` containing the error
            aReturnValue.mCode = uniffi::CALL_ERROR;
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mCallStatus.error_buf).intoArrayBuffer(aContext));
            break;

        default:
            // This indicates a RustError, which shouldn't happen in practice since FF sets panic=abort
            aReturnValue.mCode = uniffi::CALL_INTERNAL_ERROR;
            aReturnValue.mInternalErrorMessage.AssignLiteral(u"Unexpected Error");
            break;
    }
}
}
// For each Rust scaffolding function, define types and functions for calling it
namespace todolist_126_get_default_list {
using namespace mozilla::dom;
// Arguments to pass to the scaffolding function
struct Args {
};

// Return values from the scaffolding function
struct Result {
    RustBuffer mReturnValue;
    RustCallStatus mCallStatus = {};
};

// Convert the arguments we get from JS to arguments to pass to Rust.
//
// On error, an error code will be stored in result.  Make sure to check this before
// passing the args to Invoke().
//
// For async calls this should be called in the main thread, since the GC can
// move the ArrayBuffer pointers while the background task is waiting.
Args PrepareArgs(
    mozilla::ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args
    Args uniFFIArgs;

    return uniFFIArgs;
}

// Call the scaffolding function
//
// For async calls this should be called in the worker thread
Result Invoke(Args& aArgs) {
    Result result = {};result.mReturnValue =::todolist_126_get_default_list(
         &result.mCallStatus
     );
    return result;
}

// Return the result of the scaffolding call back to JS
void ReturnResult(JSContext* aContext, const Result& aCallResult, RootedDictionary<UniFFIRustCallResult>& aReturnValue) {
    switch (aCallResult.mCallStatus.code) {
        case uniffi::CALL_SUCCESS: {
            // Successful call.  Populate data with the return value
            aReturnValue.mCode = uniffi::CALL_SUCCESS;
            // RustBuffer return, convert it to an ArrayBuffer
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mReturnValue).intoArrayBuffer(aContext));
            break;
        }

        case uniffi::CALL_ERROR:
            // Rust Err() value.  Populate data with the `RustBuffer` containing the error
            aReturnValue.mCode = uniffi::CALL_ERROR;
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mCallStatus.error_buf).intoArrayBuffer(aContext));
            break;

        default:
            // This indicates a RustError, which shouldn't happen in practice since FF sets panic=abort
            aReturnValue.mCode = uniffi::CALL_INTERNAL_ERROR;
            aReturnValue.mInternalErrorMessage.AssignLiteral(u"Unexpected Error");
            break;
    }
}
}
// For each Rust scaffolding function, define types and functions for calling it
namespace todolist_126_set_default_list {
using namespace mozilla::dom;
// Arguments to pass to the scaffolding function
struct Args {
    void * list;
};

// Return values from the scaffolding function
struct Result {
    RustCallStatus mCallStatus = {};
};

// Convert the arguments we get from JS to arguments to pass to Rust.
//
// On error, an error code will be stored in result.  Make sure to check this before
// passing the args to Invoke().
//
// For async calls this should be called in the main thread, since the GC can
// move the ArrayBuffer pointers while the background task is waiting.
Args PrepareArgs(const UniFFIPointer& list,
    mozilla::ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args
    Args uniFFIArgs;
    // We check if the pointer in the argument passed has the same type expected by this
    // function
    if (!list.IsSamePtrType(&TodoListPointerType::getInstance())) {
        aUniFFIError.ThrowTypeError("pointer list is not of type TodoList");
        return uniFFIArgs;
    }
    uniFFIArgs.list = list.GetPtr();

    return uniFFIArgs;
}

// Call the scaffolding function
//
// For async calls this should be called in the worker thread
Result Invoke(Args& aArgs) {
    Result result = {};::todolist_126_set_default_list(
         aArgs.list,
         &result.mCallStatus
     );
    return result;
}

// Return the result of the scaffolding call back to JS
void ReturnResult(JSContext* aContext, const Result& aCallResult, RootedDictionary<UniFFIRustCallResult>& aReturnValue) {
    switch (aCallResult.mCallStatus.code) {
        case uniffi::CALL_SUCCESS: {
            // Successful call.  Populate data with the return value
            aReturnValue.mCode = uniffi::CALL_SUCCESS;
            // Void return
            break;
        }

        case uniffi::CALL_ERROR:
            // Rust Err() value.  Populate data with the `RustBuffer` containing the error
            aReturnValue.mCode = uniffi::CALL_ERROR;
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mCallStatus.error_buf).intoArrayBuffer(aContext));
            break;

        default:
            // This indicates a RustError, which shouldn't happen in practice since FF sets panic=abort
            aReturnValue.mCode = uniffi::CALL_INTERNAL_ERROR;
            aReturnValue.mInternalErrorMessage.AssignLiteral(u"Unexpected Error");
            break;
    }
}
}
// For each Rust scaffolding function, define types and functions for calling it
namespace todolist_126_create_entry_with {
using namespace mozilla::dom;
// Arguments to pass to the scaffolding function
struct Args {
    // RustBuffer arguments are stored as OwnedRustBuffer instances.  That class takes care of
    // freeing the buffer if the arguments don't get passed to Rust (i.e. intoRustBuffer()
    // isn't called).  This can happen if some of the ArrayBuffer arguments are succuessfully
    // converted, but one fails to convert.
    mozilla::dom::OwnedRustBuffer todo;
};

// Return values from the scaffolding function
struct Result {
    RustBuffer mReturnValue;
    RustCallStatus mCallStatus = {};
};

// Convert the arguments we get from JS to arguments to pass to Rust.
//
// On error, an error code will be stored in result.  Make sure to check this before
// passing the args to Invoke().
//
// For async calls this should be called in the main thread, since the GC can
// move the ArrayBuffer pointers while the background task is waiting.
Args PrepareArgs(const ArrayBuffer& todo,
    mozilla::ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args
    Args uniFFIArgs;
    // Convert the ArrayBuffer we get from JS to an OwnedRustBuffer
    todo.ComputeState();
    uniFFIArgs.todo = OwnedRustBuffer(todo, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return uniFFIArgs;
    }

    return uniFFIArgs;
}

// Call the scaffolding function
//
// For async calls this should be called in the worker thread
Result Invoke(Args& aArgs) {
    Result result = {};result.mReturnValue =::todolist_126_create_entry_with(
         // Call intoRustBuffer() to get a `RustBuffer` from an OwnedRustBuffer.  This transfers ownership to Rust,
         // OwnedRustBuffer will no longer try to free it
         aArgs.todo.intoRustBuffer(),
         &result.mCallStatus
     );
    return result;
}

// Return the result of the scaffolding call back to JS
void ReturnResult(JSContext* aContext, const Result& aCallResult, RootedDictionary<UniFFIRustCallResult>& aReturnValue) {
    switch (aCallResult.mCallStatus.code) {
        case uniffi::CALL_SUCCESS: {
            // Successful call.  Populate data with the return value
            aReturnValue.mCode = uniffi::CALL_SUCCESS;
            // RustBuffer return, convert it to an ArrayBuffer
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mReturnValue).intoArrayBuffer(aContext));
            break;
        }

        case uniffi::CALL_ERROR:
            // Rust Err() value.  Populate data with the `RustBuffer` containing the error
            aReturnValue.mCode = uniffi::CALL_ERROR;
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mCallStatus.error_buf).intoArrayBuffer(aContext));
            break;

        default:
            // This indicates a RustError, which shouldn't happen in practice since FF sets panic=abort
            aReturnValue.mCode = uniffi::CALL_INTERNAL_ERROR;
            aReturnValue.mInternalErrorMessage.AssignLiteral(u"Unexpected Error");
            break;
    }
}
}
}

namespace mozilla::dom {
using namespace uniffi::todolist;
already_AddRefed<Promise> TodolistScaffolding::FfiTodolist126TodoListObjectFree(const GlobalObject& aUniFFIGlobal,const UniFFIPointer& ptr,
 ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args

    // Create the promise that we return to JS
    nsCOMPtr<nsIGlobalObject> uniFFIXPCOMGlobal = do_QueryInterface(aUniFFIGlobal.GetAsSupports());
    RefPtr<Promise> uniFFIReturnPromise = Promise::Create(uniFFIXPCOMGlobal, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Prepare arguments to pass to Rust
    auto uniFFIArgs = ffi_todolist_126_todo_list_object_free::PrepareArgs(ptr, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Create a second promise that gets resolved by a background task that calls the scaffolding function
    using UniFFITaskPromise = MozPromise<ffi_todolist_126_todo_list_object_free::Result, nsresult, true>;
    RefPtr uniFFITaskPromise = new UniFFITaskPromise::Private(__func__);
    nsresult uniFFIDispatchResult = NS_DispatchBackgroundTask(
            NS_NewRunnableFunction(
                "TodolistScaffolding::FfiTodolist126TodoListObjectFree",
                [args = std::move(uniFFIArgs), uniFFITaskPromise]() mutable {
                auto result = ffi_todolist_126_todo_list_object_free::Invoke(args);
                uniFFITaskPromise->Resolve(std::move(result), __func__);
            }),
            NS_DISPATCH_EVENT_MAY_BLOCK);
    if (NS_FAILED(uniFFIDispatchResult)) {
        uniFFITaskPromise->Reject(uniFFIDispatchResult, __func__);
    }

    // When the background task promise completes, resolve the JS promise
    uniFFITaskPromise->Then(GetCurrentSerialEventTarget(), __func__,
            [uniFFIXPCOMGlobal, uniFFIReturnPromise](UniFFITaskPromise::ResolveOrRejectValue&& aResult) {
            if (!aResult.IsResolve()) {
                uniFFIReturnPromise->MaybeRejectWithUnknownError("TodolistScaffolding::FfiTodolist126TodoListObjectFree task dispatch failed");
                return;
            }

            AutoEntryScript aes(uniFFIXPCOMGlobal, "TodolistScaffolding::FfiTodolist126TodoListObjectFree call resolve");
            RootedDictionary<UniFFIRustCallResult> returnValue(aes.cx());

            ffi_todolist_126_todo_list_object_free::ReturnResult(aes.cx(), aResult.ResolveValue(), returnValue);
            uniFFIReturnPromise->MaybeResolve(returnValue);
            }
    );

    // Return the JS promise, using forget() to convert it to already_AddRefed
    return uniFFIReturnPromise.forget();
}
using namespace uniffi::todolist;
already_AddRefed<Promise> TodolistScaffolding::Todolist126TodoListNew(const GlobalObject& aUniFFIGlobal,
 ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args

    // Create the promise that we return to JS
    nsCOMPtr<nsIGlobalObject> uniFFIXPCOMGlobal = do_QueryInterface(aUniFFIGlobal.GetAsSupports());
    RefPtr<Promise> uniFFIReturnPromise = Promise::Create(uniFFIXPCOMGlobal, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Prepare arguments to pass to Rust
    auto uniFFIArgs = todolist_126_todo_list_new::PrepareArgs(aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Create a second promise that gets resolved by a background task that calls the scaffolding function
    using UniFFITaskPromise = MozPromise<todolist_126_todo_list_new::Result, nsresult, true>;
    RefPtr uniFFITaskPromise = new UniFFITaskPromise::Private(__func__);
    nsresult uniFFIDispatchResult = NS_DispatchBackgroundTask(
            NS_NewRunnableFunction(
                "TodolistScaffolding::Todolist126TodoListNew",
                [args = std::move(uniFFIArgs), uniFFITaskPromise]() mutable {
                auto result = todolist_126_todo_list_new::Invoke(args);
                uniFFITaskPromise->Resolve(std::move(result), __func__);
            }),
            NS_DISPATCH_EVENT_MAY_BLOCK);
    if (NS_FAILED(uniFFIDispatchResult)) {
        uniFFITaskPromise->Reject(uniFFIDispatchResult, __func__);
    }

    // When the background task promise completes, resolve the JS promise
    uniFFITaskPromise->Then(GetCurrentSerialEventTarget(), __func__,
            [uniFFIXPCOMGlobal, uniFFIReturnPromise](UniFFITaskPromise::ResolveOrRejectValue&& aResult) {
            if (!aResult.IsResolve()) {
                uniFFIReturnPromise->MaybeRejectWithUnknownError("TodolistScaffolding::Todolist126TodoListNew task dispatch failed");
                return;
            }

            AutoEntryScript aes(uniFFIXPCOMGlobal, "TodolistScaffolding::Todolist126TodoListNew call resolve");
            RootedDictionary<UniFFIRustCallResult> returnValue(aes.cx());

            todolist_126_todo_list_new::ReturnResult(aes.cx(), aResult.ResolveValue(), returnValue);
            uniFFIReturnPromise->MaybeResolve(returnValue);
            }
    );

    // Return the JS promise, using forget() to convert it to already_AddRefed
    return uniFFIReturnPromise.forget();
}
using namespace uniffi::todolist;
already_AddRefed<Promise> TodolistScaffolding::Todolist126TodoListAddItem(const GlobalObject& aUniFFIGlobal,const UniFFIPointer& ptr, const ArrayBuffer& todo,
 ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args

    // Create the promise that we return to JS
    nsCOMPtr<nsIGlobalObject> uniFFIXPCOMGlobal = do_QueryInterface(aUniFFIGlobal.GetAsSupports());
    RefPtr<Promise> uniFFIReturnPromise = Promise::Create(uniFFIXPCOMGlobal, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Prepare arguments to pass to Rust
    auto uniFFIArgs = todolist_126_todo_list_add_item::PrepareArgs(ptr, todo, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Create a second promise that gets resolved by a background task that calls the scaffolding function
    using UniFFITaskPromise = MozPromise<todolist_126_todo_list_add_item::Result, nsresult, true>;
    RefPtr uniFFITaskPromise = new UniFFITaskPromise::Private(__func__);
    nsresult uniFFIDispatchResult = NS_DispatchBackgroundTask(
            NS_NewRunnableFunction(
                "TodolistScaffolding::Todolist126TodoListAddItem",
                [args = std::move(uniFFIArgs), uniFFITaskPromise]() mutable {
                auto result = todolist_126_todo_list_add_item::Invoke(args);
                uniFFITaskPromise->Resolve(std::move(result), __func__);
            }),
            NS_DISPATCH_EVENT_MAY_BLOCK);
    if (NS_FAILED(uniFFIDispatchResult)) {
        uniFFITaskPromise->Reject(uniFFIDispatchResult, __func__);
    }

    // When the background task promise completes, resolve the JS promise
    uniFFITaskPromise->Then(GetCurrentSerialEventTarget(), __func__,
            [uniFFIXPCOMGlobal, uniFFIReturnPromise](UniFFITaskPromise::ResolveOrRejectValue&& aResult) {
            if (!aResult.IsResolve()) {
                uniFFIReturnPromise->MaybeRejectWithUnknownError("TodolistScaffolding::Todolist126TodoListAddItem task dispatch failed");
                return;
            }

            AutoEntryScript aes(uniFFIXPCOMGlobal, "TodolistScaffolding::Todolist126TodoListAddItem call resolve");
            RootedDictionary<UniFFIRustCallResult> returnValue(aes.cx());

            todolist_126_todo_list_add_item::ReturnResult(aes.cx(), aResult.ResolveValue(), returnValue);
            uniFFIReturnPromise->MaybeResolve(returnValue);
            }
    );

    // Return the JS promise, using forget() to convert it to already_AddRefed
    return uniFFIReturnPromise.forget();
}
using namespace uniffi::todolist;
already_AddRefed<Promise> TodolistScaffolding::Todolist126TodoListAddEntry(const GlobalObject& aUniFFIGlobal,const UniFFIPointer& ptr, const ArrayBuffer& entry,
 ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args

    // Create the promise that we return to JS
    nsCOMPtr<nsIGlobalObject> uniFFIXPCOMGlobal = do_QueryInterface(aUniFFIGlobal.GetAsSupports());
    RefPtr<Promise> uniFFIReturnPromise = Promise::Create(uniFFIXPCOMGlobal, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Prepare arguments to pass to Rust
    auto uniFFIArgs = todolist_126_todo_list_add_entry::PrepareArgs(ptr, entry, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Create a second promise that gets resolved by a background task that calls the scaffolding function
    using UniFFITaskPromise = MozPromise<todolist_126_todo_list_add_entry::Result, nsresult, true>;
    RefPtr uniFFITaskPromise = new UniFFITaskPromise::Private(__func__);
    nsresult uniFFIDispatchResult = NS_DispatchBackgroundTask(
            NS_NewRunnableFunction(
                "TodolistScaffolding::Todolist126TodoListAddEntry",
                [args = std::move(uniFFIArgs), uniFFITaskPromise]() mutable {
                auto result = todolist_126_todo_list_add_entry::Invoke(args);
                uniFFITaskPromise->Resolve(std::move(result), __func__);
            }),
            NS_DISPATCH_EVENT_MAY_BLOCK);
    if (NS_FAILED(uniFFIDispatchResult)) {
        uniFFITaskPromise->Reject(uniFFIDispatchResult, __func__);
    }

    // When the background task promise completes, resolve the JS promise
    uniFFITaskPromise->Then(GetCurrentSerialEventTarget(), __func__,
            [uniFFIXPCOMGlobal, uniFFIReturnPromise](UniFFITaskPromise::ResolveOrRejectValue&& aResult) {
            if (!aResult.IsResolve()) {
                uniFFIReturnPromise->MaybeRejectWithUnknownError("TodolistScaffolding::Todolist126TodoListAddEntry task dispatch failed");
                return;
            }

            AutoEntryScript aes(uniFFIXPCOMGlobal, "TodolistScaffolding::Todolist126TodoListAddEntry call resolve");
            RootedDictionary<UniFFIRustCallResult> returnValue(aes.cx());

            todolist_126_todo_list_add_entry::ReturnResult(aes.cx(), aResult.ResolveValue(), returnValue);
            uniFFIReturnPromise->MaybeResolve(returnValue);
            }
    );

    // Return the JS promise, using forget() to convert it to already_AddRefed
    return uniFFIReturnPromise.forget();
}
using namespace uniffi::todolist;
already_AddRefed<Promise> TodolistScaffolding::Todolist126TodoListGetEntries(const GlobalObject& aUniFFIGlobal,const UniFFIPointer& ptr,
 ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args

    // Create the promise that we return to JS
    nsCOMPtr<nsIGlobalObject> uniFFIXPCOMGlobal = do_QueryInterface(aUniFFIGlobal.GetAsSupports());
    RefPtr<Promise> uniFFIReturnPromise = Promise::Create(uniFFIXPCOMGlobal, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Prepare arguments to pass to Rust
    auto uniFFIArgs = todolist_126_todo_list_get_entries::PrepareArgs(ptr, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Create a second promise that gets resolved by a background task that calls the scaffolding function
    using UniFFITaskPromise = MozPromise<todolist_126_todo_list_get_entries::Result, nsresult, true>;
    RefPtr uniFFITaskPromise = new UniFFITaskPromise::Private(__func__);
    nsresult uniFFIDispatchResult = NS_DispatchBackgroundTask(
            NS_NewRunnableFunction(
                "TodolistScaffolding::Todolist126TodoListGetEntries",
                [args = std::move(uniFFIArgs), uniFFITaskPromise]() mutable {
                auto result = todolist_126_todo_list_get_entries::Invoke(args);
                uniFFITaskPromise->Resolve(std::move(result), __func__);
            }),
            NS_DISPATCH_EVENT_MAY_BLOCK);
    if (NS_FAILED(uniFFIDispatchResult)) {
        uniFFITaskPromise->Reject(uniFFIDispatchResult, __func__);
    }

    // When the background task promise completes, resolve the JS promise
    uniFFITaskPromise->Then(GetCurrentSerialEventTarget(), __func__,
            [uniFFIXPCOMGlobal, uniFFIReturnPromise](UniFFITaskPromise::ResolveOrRejectValue&& aResult) {
            if (!aResult.IsResolve()) {
                uniFFIReturnPromise->MaybeRejectWithUnknownError("TodolistScaffolding::Todolist126TodoListGetEntries task dispatch failed");
                return;
            }

            AutoEntryScript aes(uniFFIXPCOMGlobal, "TodolistScaffolding::Todolist126TodoListGetEntries call resolve");
            RootedDictionary<UniFFIRustCallResult> returnValue(aes.cx());

            todolist_126_todo_list_get_entries::ReturnResult(aes.cx(), aResult.ResolveValue(), returnValue);
            uniFFIReturnPromise->MaybeResolve(returnValue);
            }
    );

    // Return the JS promise, using forget() to convert it to already_AddRefed
    return uniFFIReturnPromise.forget();
}
using namespace uniffi::todolist;
already_AddRefed<Promise> TodolistScaffolding::Todolist126TodoListGetItems(const GlobalObject& aUniFFIGlobal,const UniFFIPointer& ptr,
 ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args

    // Create the promise that we return to JS
    nsCOMPtr<nsIGlobalObject> uniFFIXPCOMGlobal = do_QueryInterface(aUniFFIGlobal.GetAsSupports());
    RefPtr<Promise> uniFFIReturnPromise = Promise::Create(uniFFIXPCOMGlobal, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Prepare arguments to pass to Rust
    auto uniFFIArgs = todolist_126_todo_list_get_items::PrepareArgs(ptr, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Create a second promise that gets resolved by a background task that calls the scaffolding function
    using UniFFITaskPromise = MozPromise<todolist_126_todo_list_get_items::Result, nsresult, true>;
    RefPtr uniFFITaskPromise = new UniFFITaskPromise::Private(__func__);
    nsresult uniFFIDispatchResult = NS_DispatchBackgroundTask(
            NS_NewRunnableFunction(
                "TodolistScaffolding::Todolist126TodoListGetItems",
                [args = std::move(uniFFIArgs), uniFFITaskPromise]() mutable {
                auto result = todolist_126_todo_list_get_items::Invoke(args);
                uniFFITaskPromise->Resolve(std::move(result), __func__);
            }),
            NS_DISPATCH_EVENT_MAY_BLOCK);
    if (NS_FAILED(uniFFIDispatchResult)) {
        uniFFITaskPromise->Reject(uniFFIDispatchResult, __func__);
    }

    // When the background task promise completes, resolve the JS promise
    uniFFITaskPromise->Then(GetCurrentSerialEventTarget(), __func__,
            [uniFFIXPCOMGlobal, uniFFIReturnPromise](UniFFITaskPromise::ResolveOrRejectValue&& aResult) {
            if (!aResult.IsResolve()) {
                uniFFIReturnPromise->MaybeRejectWithUnknownError("TodolistScaffolding::Todolist126TodoListGetItems task dispatch failed");
                return;
            }

            AutoEntryScript aes(uniFFIXPCOMGlobal, "TodolistScaffolding::Todolist126TodoListGetItems call resolve");
            RootedDictionary<UniFFIRustCallResult> returnValue(aes.cx());

            todolist_126_todo_list_get_items::ReturnResult(aes.cx(), aResult.ResolveValue(), returnValue);
            uniFFIReturnPromise->MaybeResolve(returnValue);
            }
    );

    // Return the JS promise, using forget() to convert it to already_AddRefed
    return uniFFIReturnPromise.forget();
}
using namespace uniffi::todolist;
already_AddRefed<Promise> TodolistScaffolding::Todolist126TodoListAddEntries(const GlobalObject& aUniFFIGlobal,const UniFFIPointer& ptr, const ArrayBuffer& entries,
 ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args

    // Create the promise that we return to JS
    nsCOMPtr<nsIGlobalObject> uniFFIXPCOMGlobal = do_QueryInterface(aUniFFIGlobal.GetAsSupports());
    RefPtr<Promise> uniFFIReturnPromise = Promise::Create(uniFFIXPCOMGlobal, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Prepare arguments to pass to Rust
    auto uniFFIArgs = todolist_126_todo_list_add_entries::PrepareArgs(ptr, entries, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Create a second promise that gets resolved by a background task that calls the scaffolding function
    using UniFFITaskPromise = MozPromise<todolist_126_todo_list_add_entries::Result, nsresult, true>;
    RefPtr uniFFITaskPromise = new UniFFITaskPromise::Private(__func__);
    nsresult uniFFIDispatchResult = NS_DispatchBackgroundTask(
            NS_NewRunnableFunction(
                "TodolistScaffolding::Todolist126TodoListAddEntries",
                [args = std::move(uniFFIArgs), uniFFITaskPromise]() mutable {
                auto result = todolist_126_todo_list_add_entries::Invoke(args);
                uniFFITaskPromise->Resolve(std::move(result), __func__);
            }),
            NS_DISPATCH_EVENT_MAY_BLOCK);
    if (NS_FAILED(uniFFIDispatchResult)) {
        uniFFITaskPromise->Reject(uniFFIDispatchResult, __func__);
    }

    // When the background task promise completes, resolve the JS promise
    uniFFITaskPromise->Then(GetCurrentSerialEventTarget(), __func__,
            [uniFFIXPCOMGlobal, uniFFIReturnPromise](UniFFITaskPromise::ResolveOrRejectValue&& aResult) {
            if (!aResult.IsResolve()) {
                uniFFIReturnPromise->MaybeRejectWithUnknownError("TodolistScaffolding::Todolist126TodoListAddEntries task dispatch failed");
                return;
            }

            AutoEntryScript aes(uniFFIXPCOMGlobal, "TodolistScaffolding::Todolist126TodoListAddEntries call resolve");
            RootedDictionary<UniFFIRustCallResult> returnValue(aes.cx());

            todolist_126_todo_list_add_entries::ReturnResult(aes.cx(), aResult.ResolveValue(), returnValue);
            uniFFIReturnPromise->MaybeResolve(returnValue);
            }
    );

    // Return the JS promise, using forget() to convert it to already_AddRefed
    return uniFFIReturnPromise.forget();
}
using namespace uniffi::todolist;
already_AddRefed<Promise> TodolistScaffolding::Todolist126TodoListAddItems(const GlobalObject& aUniFFIGlobal,const UniFFIPointer& ptr, const ArrayBuffer& items,
 ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args

    // Create the promise that we return to JS
    nsCOMPtr<nsIGlobalObject> uniFFIXPCOMGlobal = do_QueryInterface(aUniFFIGlobal.GetAsSupports());
    RefPtr<Promise> uniFFIReturnPromise = Promise::Create(uniFFIXPCOMGlobal, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Prepare arguments to pass to Rust
    auto uniFFIArgs = todolist_126_todo_list_add_items::PrepareArgs(ptr, items, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Create a second promise that gets resolved by a background task that calls the scaffolding function
    using UniFFITaskPromise = MozPromise<todolist_126_todo_list_add_items::Result, nsresult, true>;
    RefPtr uniFFITaskPromise = new UniFFITaskPromise::Private(__func__);
    nsresult uniFFIDispatchResult = NS_DispatchBackgroundTask(
            NS_NewRunnableFunction(
                "TodolistScaffolding::Todolist126TodoListAddItems",
                [args = std::move(uniFFIArgs), uniFFITaskPromise]() mutable {
                auto result = todolist_126_todo_list_add_items::Invoke(args);
                uniFFITaskPromise->Resolve(std::move(result), __func__);
            }),
            NS_DISPATCH_EVENT_MAY_BLOCK);
    if (NS_FAILED(uniFFIDispatchResult)) {
        uniFFITaskPromise->Reject(uniFFIDispatchResult, __func__);
    }

    // When the background task promise completes, resolve the JS promise
    uniFFITaskPromise->Then(GetCurrentSerialEventTarget(), __func__,
            [uniFFIXPCOMGlobal, uniFFIReturnPromise](UniFFITaskPromise::ResolveOrRejectValue&& aResult) {
            if (!aResult.IsResolve()) {
                uniFFIReturnPromise->MaybeRejectWithUnknownError("TodolistScaffolding::Todolist126TodoListAddItems task dispatch failed");
                return;
            }

            AutoEntryScript aes(uniFFIXPCOMGlobal, "TodolistScaffolding::Todolist126TodoListAddItems call resolve");
            RootedDictionary<UniFFIRustCallResult> returnValue(aes.cx());

            todolist_126_todo_list_add_items::ReturnResult(aes.cx(), aResult.ResolveValue(), returnValue);
            uniFFIReturnPromise->MaybeResolve(returnValue);
            }
    );

    // Return the JS promise, using forget() to convert it to already_AddRefed
    return uniFFIReturnPromise.forget();
}
using namespace uniffi::todolist;
already_AddRefed<Promise> TodolistScaffolding::Todolist126TodoListGetLastEntry(const GlobalObject& aUniFFIGlobal,const UniFFIPointer& ptr,
 ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args

    // Create the promise that we return to JS
    nsCOMPtr<nsIGlobalObject> uniFFIXPCOMGlobal = do_QueryInterface(aUniFFIGlobal.GetAsSupports());
    RefPtr<Promise> uniFFIReturnPromise = Promise::Create(uniFFIXPCOMGlobal, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Prepare arguments to pass to Rust
    auto uniFFIArgs = todolist_126_todo_list_get_last_entry::PrepareArgs(ptr, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Create a second promise that gets resolved by a background task that calls the scaffolding function
    using UniFFITaskPromise = MozPromise<todolist_126_todo_list_get_last_entry::Result, nsresult, true>;
    RefPtr uniFFITaskPromise = new UniFFITaskPromise::Private(__func__);
    nsresult uniFFIDispatchResult = NS_DispatchBackgroundTask(
            NS_NewRunnableFunction(
                "TodolistScaffolding::Todolist126TodoListGetLastEntry",
                [args = std::move(uniFFIArgs), uniFFITaskPromise]() mutable {
                auto result = todolist_126_todo_list_get_last_entry::Invoke(args);
                uniFFITaskPromise->Resolve(std::move(result), __func__);
            }),
            NS_DISPATCH_EVENT_MAY_BLOCK);
    if (NS_FAILED(uniFFIDispatchResult)) {
        uniFFITaskPromise->Reject(uniFFIDispatchResult, __func__);
    }

    // When the background task promise completes, resolve the JS promise
    uniFFITaskPromise->Then(GetCurrentSerialEventTarget(), __func__,
            [uniFFIXPCOMGlobal, uniFFIReturnPromise](UniFFITaskPromise::ResolveOrRejectValue&& aResult) {
            if (!aResult.IsResolve()) {
                uniFFIReturnPromise->MaybeRejectWithUnknownError("TodolistScaffolding::Todolist126TodoListGetLastEntry task dispatch failed");
                return;
            }

            AutoEntryScript aes(uniFFIXPCOMGlobal, "TodolistScaffolding::Todolist126TodoListGetLastEntry call resolve");
            RootedDictionary<UniFFIRustCallResult> returnValue(aes.cx());

            todolist_126_todo_list_get_last_entry::ReturnResult(aes.cx(), aResult.ResolveValue(), returnValue);
            uniFFIReturnPromise->MaybeResolve(returnValue);
            }
    );

    // Return the JS promise, using forget() to convert it to already_AddRefed
    return uniFFIReturnPromise.forget();
}
using namespace uniffi::todolist;
already_AddRefed<Promise> TodolistScaffolding::Todolist126TodoListGetLast(const GlobalObject& aUniFFIGlobal,const UniFFIPointer& ptr,
 ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args

    // Create the promise that we return to JS
    nsCOMPtr<nsIGlobalObject> uniFFIXPCOMGlobal = do_QueryInterface(aUniFFIGlobal.GetAsSupports());
    RefPtr<Promise> uniFFIReturnPromise = Promise::Create(uniFFIXPCOMGlobal, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Prepare arguments to pass to Rust
    auto uniFFIArgs = todolist_126_todo_list_get_last::PrepareArgs(ptr, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Create a second promise that gets resolved by a background task that calls the scaffolding function
    using UniFFITaskPromise = MozPromise<todolist_126_todo_list_get_last::Result, nsresult, true>;
    RefPtr uniFFITaskPromise = new UniFFITaskPromise::Private(__func__);
    nsresult uniFFIDispatchResult = NS_DispatchBackgroundTask(
            NS_NewRunnableFunction(
                "TodolistScaffolding::Todolist126TodoListGetLast",
                [args = std::move(uniFFIArgs), uniFFITaskPromise]() mutable {
                auto result = todolist_126_todo_list_get_last::Invoke(args);
                uniFFITaskPromise->Resolve(std::move(result), __func__);
            }),
            NS_DISPATCH_EVENT_MAY_BLOCK);
    if (NS_FAILED(uniFFIDispatchResult)) {
        uniFFITaskPromise->Reject(uniFFIDispatchResult, __func__);
    }

    // When the background task promise completes, resolve the JS promise
    uniFFITaskPromise->Then(GetCurrentSerialEventTarget(), __func__,
            [uniFFIXPCOMGlobal, uniFFIReturnPromise](UniFFITaskPromise::ResolveOrRejectValue&& aResult) {
            if (!aResult.IsResolve()) {
                uniFFIReturnPromise->MaybeRejectWithUnknownError("TodolistScaffolding::Todolist126TodoListGetLast task dispatch failed");
                return;
            }

            AutoEntryScript aes(uniFFIXPCOMGlobal, "TodolistScaffolding::Todolist126TodoListGetLast call resolve");
            RootedDictionary<UniFFIRustCallResult> returnValue(aes.cx());

            todolist_126_todo_list_get_last::ReturnResult(aes.cx(), aResult.ResolveValue(), returnValue);
            uniFFIReturnPromise->MaybeResolve(returnValue);
            }
    );

    // Return the JS promise, using forget() to convert it to already_AddRefed
    return uniFFIReturnPromise.forget();
}
using namespace uniffi::todolist;
already_AddRefed<Promise> TodolistScaffolding::Todolist126TodoListGetFirst(const GlobalObject& aUniFFIGlobal,const UniFFIPointer& ptr,
 ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args

    // Create the promise that we return to JS
    nsCOMPtr<nsIGlobalObject> uniFFIXPCOMGlobal = do_QueryInterface(aUniFFIGlobal.GetAsSupports());
    RefPtr<Promise> uniFFIReturnPromise = Promise::Create(uniFFIXPCOMGlobal, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Prepare arguments to pass to Rust
    auto uniFFIArgs = todolist_126_todo_list_get_first::PrepareArgs(ptr, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Create a second promise that gets resolved by a background task that calls the scaffolding function
    using UniFFITaskPromise = MozPromise<todolist_126_todo_list_get_first::Result, nsresult, true>;
    RefPtr uniFFITaskPromise = new UniFFITaskPromise::Private(__func__);
    nsresult uniFFIDispatchResult = NS_DispatchBackgroundTask(
            NS_NewRunnableFunction(
                "TodolistScaffolding::Todolist126TodoListGetFirst",
                [args = std::move(uniFFIArgs), uniFFITaskPromise]() mutable {
                auto result = todolist_126_todo_list_get_first::Invoke(args);
                uniFFITaskPromise->Resolve(std::move(result), __func__);
            }),
            NS_DISPATCH_EVENT_MAY_BLOCK);
    if (NS_FAILED(uniFFIDispatchResult)) {
        uniFFITaskPromise->Reject(uniFFIDispatchResult, __func__);
    }

    // When the background task promise completes, resolve the JS promise
    uniFFITaskPromise->Then(GetCurrentSerialEventTarget(), __func__,
            [uniFFIXPCOMGlobal, uniFFIReturnPromise](UniFFITaskPromise::ResolveOrRejectValue&& aResult) {
            if (!aResult.IsResolve()) {
                uniFFIReturnPromise->MaybeRejectWithUnknownError("TodolistScaffolding::Todolist126TodoListGetFirst task dispatch failed");
                return;
            }

            AutoEntryScript aes(uniFFIXPCOMGlobal, "TodolistScaffolding::Todolist126TodoListGetFirst call resolve");
            RootedDictionary<UniFFIRustCallResult> returnValue(aes.cx());

            todolist_126_todo_list_get_first::ReturnResult(aes.cx(), aResult.ResolveValue(), returnValue);
            uniFFIReturnPromise->MaybeResolve(returnValue);
            }
    );

    // Return the JS promise, using forget() to convert it to already_AddRefed
    return uniFFIReturnPromise.forget();
}
using namespace uniffi::todolist;
already_AddRefed<Promise> TodolistScaffolding::Todolist126TodoListClearItem(const GlobalObject& aUniFFIGlobal,const UniFFIPointer& ptr, const ArrayBuffer& todo,
 ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args

    // Create the promise that we return to JS
    nsCOMPtr<nsIGlobalObject> uniFFIXPCOMGlobal = do_QueryInterface(aUniFFIGlobal.GetAsSupports());
    RefPtr<Promise> uniFFIReturnPromise = Promise::Create(uniFFIXPCOMGlobal, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Prepare arguments to pass to Rust
    auto uniFFIArgs = todolist_126_todo_list_clear_item::PrepareArgs(ptr, todo, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Create a second promise that gets resolved by a background task that calls the scaffolding function
    using UniFFITaskPromise = MozPromise<todolist_126_todo_list_clear_item::Result, nsresult, true>;
    RefPtr uniFFITaskPromise = new UniFFITaskPromise::Private(__func__);
    nsresult uniFFIDispatchResult = NS_DispatchBackgroundTask(
            NS_NewRunnableFunction(
                "TodolistScaffolding::Todolist126TodoListClearItem",
                [args = std::move(uniFFIArgs), uniFFITaskPromise]() mutable {
                auto result = todolist_126_todo_list_clear_item::Invoke(args);
                uniFFITaskPromise->Resolve(std::move(result), __func__);
            }),
            NS_DISPATCH_EVENT_MAY_BLOCK);
    if (NS_FAILED(uniFFIDispatchResult)) {
        uniFFITaskPromise->Reject(uniFFIDispatchResult, __func__);
    }

    // When the background task promise completes, resolve the JS promise
    uniFFITaskPromise->Then(GetCurrentSerialEventTarget(), __func__,
            [uniFFIXPCOMGlobal, uniFFIReturnPromise](UniFFITaskPromise::ResolveOrRejectValue&& aResult) {
            if (!aResult.IsResolve()) {
                uniFFIReturnPromise->MaybeRejectWithUnknownError("TodolistScaffolding::Todolist126TodoListClearItem task dispatch failed");
                return;
            }

            AutoEntryScript aes(uniFFIXPCOMGlobal, "TodolistScaffolding::Todolist126TodoListClearItem call resolve");
            RootedDictionary<UniFFIRustCallResult> returnValue(aes.cx());

            todolist_126_todo_list_clear_item::ReturnResult(aes.cx(), aResult.ResolveValue(), returnValue);
            uniFFIReturnPromise->MaybeResolve(returnValue);
            }
    );

    // Return the JS promise, using forget() to convert it to already_AddRefed
    return uniFFIReturnPromise.forget();
}
using namespace uniffi::todolist;
already_AddRefed<Promise> TodolistScaffolding::Todolist126TodoListMakeDefault(const GlobalObject& aUniFFIGlobal,const UniFFIPointer& ptr,
 ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args

    // Create the promise that we return to JS
    nsCOMPtr<nsIGlobalObject> uniFFIXPCOMGlobal = do_QueryInterface(aUniFFIGlobal.GetAsSupports());
    RefPtr<Promise> uniFFIReturnPromise = Promise::Create(uniFFIXPCOMGlobal, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Prepare arguments to pass to Rust
    auto uniFFIArgs = todolist_126_todo_list_make_default::PrepareArgs(ptr, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Create a second promise that gets resolved by a background task that calls the scaffolding function
    using UniFFITaskPromise = MozPromise<todolist_126_todo_list_make_default::Result, nsresult, true>;
    RefPtr uniFFITaskPromise = new UniFFITaskPromise::Private(__func__);
    nsresult uniFFIDispatchResult = NS_DispatchBackgroundTask(
            NS_NewRunnableFunction(
                "TodolistScaffolding::Todolist126TodoListMakeDefault",
                [args = std::move(uniFFIArgs), uniFFITaskPromise]() mutable {
                auto result = todolist_126_todo_list_make_default::Invoke(args);
                uniFFITaskPromise->Resolve(std::move(result), __func__);
            }),
            NS_DISPATCH_EVENT_MAY_BLOCK);
    if (NS_FAILED(uniFFIDispatchResult)) {
        uniFFITaskPromise->Reject(uniFFIDispatchResult, __func__);
    }

    // When the background task promise completes, resolve the JS promise
    uniFFITaskPromise->Then(GetCurrentSerialEventTarget(), __func__,
            [uniFFIXPCOMGlobal, uniFFIReturnPromise](UniFFITaskPromise::ResolveOrRejectValue&& aResult) {
            if (!aResult.IsResolve()) {
                uniFFIReturnPromise->MaybeRejectWithUnknownError("TodolistScaffolding::Todolist126TodoListMakeDefault task dispatch failed");
                return;
            }

            AutoEntryScript aes(uniFFIXPCOMGlobal, "TodolistScaffolding::Todolist126TodoListMakeDefault call resolve");
            RootedDictionary<UniFFIRustCallResult> returnValue(aes.cx());

            todolist_126_todo_list_make_default::ReturnResult(aes.cx(), aResult.ResolveValue(), returnValue);
            uniFFIReturnPromise->MaybeResolve(returnValue);
            }
    );

    // Return the JS promise, using forget() to convert it to already_AddRefed
    return uniFFIReturnPromise.forget();
}
using namespace uniffi::todolist;
already_AddRefed<Promise> TodolistScaffolding::Todolist126GetDefaultList(const GlobalObject& aUniFFIGlobal,
 ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args

    // Create the promise that we return to JS
    nsCOMPtr<nsIGlobalObject> uniFFIXPCOMGlobal = do_QueryInterface(aUniFFIGlobal.GetAsSupports());
    RefPtr<Promise> uniFFIReturnPromise = Promise::Create(uniFFIXPCOMGlobal, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Prepare arguments to pass to Rust
    auto uniFFIArgs = todolist_126_get_default_list::PrepareArgs(aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Create a second promise that gets resolved by a background task that calls the scaffolding function
    using UniFFITaskPromise = MozPromise<todolist_126_get_default_list::Result, nsresult, true>;
    RefPtr uniFFITaskPromise = new UniFFITaskPromise::Private(__func__);
    nsresult uniFFIDispatchResult = NS_DispatchBackgroundTask(
            NS_NewRunnableFunction(
                "TodolistScaffolding::Todolist126GetDefaultList",
                [args = std::move(uniFFIArgs), uniFFITaskPromise]() mutable {
                auto result = todolist_126_get_default_list::Invoke(args);
                uniFFITaskPromise->Resolve(std::move(result), __func__);
            }),
            NS_DISPATCH_EVENT_MAY_BLOCK);
    if (NS_FAILED(uniFFIDispatchResult)) {
        uniFFITaskPromise->Reject(uniFFIDispatchResult, __func__);
    }

    // When the background task promise completes, resolve the JS promise
    uniFFITaskPromise->Then(GetCurrentSerialEventTarget(), __func__,
            [uniFFIXPCOMGlobal, uniFFIReturnPromise](UniFFITaskPromise::ResolveOrRejectValue&& aResult) {
            if (!aResult.IsResolve()) {
                uniFFIReturnPromise->MaybeRejectWithUnknownError("TodolistScaffolding::Todolist126GetDefaultList task dispatch failed");
                return;
            }

            AutoEntryScript aes(uniFFIXPCOMGlobal, "TodolistScaffolding::Todolist126GetDefaultList call resolve");
            RootedDictionary<UniFFIRustCallResult> returnValue(aes.cx());

            todolist_126_get_default_list::ReturnResult(aes.cx(), aResult.ResolveValue(), returnValue);
            uniFFIReturnPromise->MaybeResolve(returnValue);
            }
    );

    // Return the JS promise, using forget() to convert it to already_AddRefed
    return uniFFIReturnPromise.forget();
}
using namespace uniffi::todolist;
already_AddRefed<Promise> TodolistScaffolding::Todolist126SetDefaultList(const GlobalObject& aUniFFIGlobal,const UniFFIPointer& list,
 ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args

    // Create the promise that we return to JS
    nsCOMPtr<nsIGlobalObject> uniFFIXPCOMGlobal = do_QueryInterface(aUniFFIGlobal.GetAsSupports());
    RefPtr<Promise> uniFFIReturnPromise = Promise::Create(uniFFIXPCOMGlobal, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Prepare arguments to pass to Rust
    auto uniFFIArgs = todolist_126_set_default_list::PrepareArgs(list, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Create a second promise that gets resolved by a background task that calls the scaffolding function
    using UniFFITaskPromise = MozPromise<todolist_126_set_default_list::Result, nsresult, true>;
    RefPtr uniFFITaskPromise = new UniFFITaskPromise::Private(__func__);
    nsresult uniFFIDispatchResult = NS_DispatchBackgroundTask(
            NS_NewRunnableFunction(
                "TodolistScaffolding::Todolist126SetDefaultList",
                [args = std::move(uniFFIArgs), uniFFITaskPromise]() mutable {
                auto result = todolist_126_set_default_list::Invoke(args);
                uniFFITaskPromise->Resolve(std::move(result), __func__);
            }),
            NS_DISPATCH_EVENT_MAY_BLOCK);
    if (NS_FAILED(uniFFIDispatchResult)) {
        uniFFITaskPromise->Reject(uniFFIDispatchResult, __func__);
    }

    // When the background task promise completes, resolve the JS promise
    uniFFITaskPromise->Then(GetCurrentSerialEventTarget(), __func__,
            [uniFFIXPCOMGlobal, uniFFIReturnPromise](UniFFITaskPromise::ResolveOrRejectValue&& aResult) {
            if (!aResult.IsResolve()) {
                uniFFIReturnPromise->MaybeRejectWithUnknownError("TodolistScaffolding::Todolist126SetDefaultList task dispatch failed");
                return;
            }

            AutoEntryScript aes(uniFFIXPCOMGlobal, "TodolistScaffolding::Todolist126SetDefaultList call resolve");
            RootedDictionary<UniFFIRustCallResult> returnValue(aes.cx());

            todolist_126_set_default_list::ReturnResult(aes.cx(), aResult.ResolveValue(), returnValue);
            uniFFIReturnPromise->MaybeResolve(returnValue);
            }
    );

    // Return the JS promise, using forget() to convert it to already_AddRefed
    return uniFFIReturnPromise.forget();
}
using namespace uniffi::todolist;
already_AddRefed<Promise> TodolistScaffolding::Todolist126CreateEntryWith(const GlobalObject& aUniFFIGlobal,const ArrayBuffer& todo,
 ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args

    // Create the promise that we return to JS
    nsCOMPtr<nsIGlobalObject> uniFFIXPCOMGlobal = do_QueryInterface(aUniFFIGlobal.GetAsSupports());
    RefPtr<Promise> uniFFIReturnPromise = Promise::Create(uniFFIXPCOMGlobal, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Prepare arguments to pass to Rust
    auto uniFFIArgs = todolist_126_create_entry_with::PrepareArgs(todo, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Create a second promise that gets resolved by a background task that calls the scaffolding function
    using UniFFITaskPromise = MozPromise<todolist_126_create_entry_with::Result, nsresult, true>;
    RefPtr uniFFITaskPromise = new UniFFITaskPromise::Private(__func__);
    nsresult uniFFIDispatchResult = NS_DispatchBackgroundTask(
            NS_NewRunnableFunction(
                "TodolistScaffolding::Todolist126CreateEntryWith",
                [args = std::move(uniFFIArgs), uniFFITaskPromise]() mutable {
                auto result = todolist_126_create_entry_with::Invoke(args);
                uniFFITaskPromise->Resolve(std::move(result), __func__);
            }),
            NS_DISPATCH_EVENT_MAY_BLOCK);
    if (NS_FAILED(uniFFIDispatchResult)) {
        uniFFITaskPromise->Reject(uniFFIDispatchResult, __func__);
    }

    // When the background task promise completes, resolve the JS promise
    uniFFITaskPromise->Then(GetCurrentSerialEventTarget(), __func__,
            [uniFFIXPCOMGlobal, uniFFIReturnPromise](UniFFITaskPromise::ResolveOrRejectValue&& aResult) {
            if (!aResult.IsResolve()) {
                uniFFIReturnPromise->MaybeRejectWithUnknownError("TodolistScaffolding::Todolist126CreateEntryWith task dispatch failed");
                return;
            }

            AutoEntryScript aes(uniFFIXPCOMGlobal, "TodolistScaffolding::Todolist126CreateEntryWith call resolve");
            RootedDictionary<UniFFIRustCallResult> returnValue(aes.cx());

            todolist_126_create_entry_with::ReturnResult(aes.cx(), aResult.ResolveValue(), returnValue);
            uniFFIReturnPromise->MaybeResolve(returnValue);
            }
    );

    // Return the JS promise, using forget() to convert it to already_AddRefed
    return uniFFIReturnPromise.forget();
}
  already_AddRefed<UniFFIPointer> TodolistScaffolding::ReadPointerTodoList(const GlobalObject& aUniFFIGlobal, const ArrayBuffer& aArrayBuff, long aPosition) {
      MOZ_LOG(sUniFFITodolistScaffoldingLogger, LogLevel::Info, ("[UniFFI] Reading Pointer from buffer"));
      aArrayBuff.ComputeState();

      // in Rust and in the write function, a pointer is converted to a void* then written as u64 BigEndian
      // we do the reverse here
      uint8_t* data_ptr = aArrayBuff.Data() + aPosition; // Pointer arithmetic, move by position bytes
      void* ptr = (void*)mozilla::BigEndian::readUint64(data_ptr);
      return UniFFIPointer::Create(ptr, &TodoListPointerType::getInstance());
  }
  void TodolistScaffolding::WritePointerTodoList(const GlobalObject& aUniFFIGlobal, const UniFFIPointer& aPtr, const ArrayBuffer& aArrayBuff, long aPosition) {
      MOZ_LOG(sUniFFITodolistScaffoldingLogger, LogLevel::Info, ("[UniFFI] Writing Pointer to buffer"));
      aArrayBuff.ComputeState();

      // in Rust and in the read function, a u64 is read as BigEndian and then converted to a pointer
      // we do the reverse here
      uint8_t* data_ptr = aArrayBuff.Data() + aPosition; // Pointer arithmetic, move by position bytes
      mozilla::BigEndian::writeUint64(data_ptr, (uint64_t)aPtr.GetPtr());
  }

  
}  // namespace mozilla::dom