// This file was autogenerated by some hot garbage in the `uniffi-bindgen-gecko-js` crate.
// Trust me, you don't want to mess with it!

#include "nsIGlobalObject.h"
#include "mozilla/MozPromise.h"
#include "mozilla/dom/RondpointScaffolding.h"
#include "mozilla/dom/OwnedRustBuffer.h"
#include "mozilla/dom/Promise.h"
#include "mozilla/Logging.h"
#include "mozilla/EndianUtils.h"

static mozilla::LazyLogModule sUniFFIRondpointScaffoldingLogger("uniffi_logger");


namespace uniffi::rondpoint {
// For each Rust scaffolding function, define types and functions for calling it
namespace ffi_rondpoint_9336_retourneur_object_free {
using namespace mozilla::dom;
// Arguments to pass to the scaffolding function
struct Args {
    void * ptr;
};

// Return values from the scaffolding function
struct Result {
    RustCallStatus mCallStatus = {};
};

// Convert the arguments we get from JS to arguments to pass to Rust.
//
// On error, an error code will be stored in result.  Make sure to check this before
// passing the args to Invoke().
//
// For async calls this should be called in the main thread, since the GC can
// move the ArrayBuffer pointers while the background task is waiting.
Args PrepareArgs(const UniFFIPointer& ptr,
    mozilla::ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args
    Args uniFFIArgs;
    // We check if the pointer in the argument passed has the same type expected by this
    // function
    if (!ptr.isSamePtrType(&RetourneurPointerType::getInstance())) {
        aUniFFIError.ThrowTypeError("pointer ptr is not of type Retourneur");
        return uniFFIArgs;
    }
    uniFFIArgs.ptr = ptr.getPtr();

    return uniFFIArgs;
}

// Call the scaffolding function
//
// For async calls this should be called in the worker thread
Result Invoke(Args& aArgs) {
    Result result = {};::ffi_rondpoint_9336_Retourneur_object_free(
         aArgs.ptr,
         &result.mCallStatus
     );
    return result;
}

// Return the result of the scaffolding call back to JS
void ReturnResult(JSContext* aContext, const Result& aCallResult, RootedDictionary<UniFFIRustCallResult>& aReturnValue) {
    switch (aCallResult.mCallStatus.code) {
        case uniffi::CALL_SUCCESS: {
            // Successful call.  Populate data with the return value
            aReturnValue.mCode = uniffi::CALL_SUCCESS;
            // Void return
            break;
        }

        case uniffi::CALL_ERROR:
            // Rust Err() value.  Populate data with the `RustBuffer` containing the error
            aReturnValue.mCode = uniffi::CALL_ERROR;
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mCallStatus.error_buf).intoArrayBuffer(aContext));
            break;

        default:
            // This indicates a RustError, which shouldn't happen in practice since FF sets panic=abort
            aReturnValue.mCode = uniffi::CALL_INTERNAL_ERROR;
            aReturnValue.mInternalErrorMessage.AssignLiteral(u"Unexpected Error");
            break;
    }
}
}
// For each Rust scaffolding function, define types and functions for calling it
namespace rondpoint_9336_retourneur_new {
using namespace mozilla::dom;
// Arguments to pass to the scaffolding function
struct Args {
};

// Return values from the scaffolding function
struct Result {
    void * mReturnValue;
    RustCallStatus mCallStatus = {};
};

// Convert the arguments we get from JS to arguments to pass to Rust.
//
// On error, an error code will be stored in result.  Make sure to check this before
// passing the args to Invoke().
//
// For async calls this should be called in the main thread, since the GC can
// move the ArrayBuffer pointers while the background task is waiting.
Args PrepareArgs(
    mozilla::ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args
    Args uniFFIArgs;

    return uniFFIArgs;
}

// Call the scaffolding function
//
// For async calls this should be called in the worker thread
Result Invoke(Args& aArgs) {
    Result result = {};result.mReturnValue =::rondpoint_9336_Retourneur_new(
         &result.mCallStatus
     );
    return result;
}

// Return the result of the scaffolding call back to JS
void ReturnResult(JSContext* aContext, const Result& aCallResult, RootedDictionary<UniFFIRustCallResult>& aReturnValue) {
    switch (aCallResult.mCallStatus.code) {
        case uniffi::CALL_SUCCESS: {
            // Successful call.  Populate data with the return value
            aReturnValue.mCode = uniffi::CALL_SUCCESS;
            RefPtr<UniFFIPointer> uniFFIPtr = UniFFIPointer::Create(aCallResult.mReturnValue, &RetourneurPointerType::getInstance() );
            aReturnValue.mData.setObjectOrNull(uniFFIPtr->WrapObject(aContext, nullptr));
            break;
        }

        case uniffi::CALL_ERROR:
            // Rust Err() value.  Populate data with the `RustBuffer` containing the error
            aReturnValue.mCode = uniffi::CALL_ERROR;
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mCallStatus.error_buf).intoArrayBuffer(aContext));
            break;

        default:
            // This indicates a RustError, which shouldn't happen in practice since FF sets panic=abort
            aReturnValue.mCode = uniffi::CALL_INTERNAL_ERROR;
            aReturnValue.mInternalErrorMessage.AssignLiteral(u"Unexpected Error");
            break;
    }
}
}
// For each Rust scaffolding function, define types and functions for calling it
namespace rondpoint_9336_retourneur_identique_i8 {
using namespace mozilla::dom;
// Arguments to pass to the scaffolding function
struct Args {
    void * ptr;
    int8_t value;
};

// Return values from the scaffolding function
struct Result {
    int8_t mReturnValue;
    RustCallStatus mCallStatus = {};
};

// Convert the arguments we get from JS to arguments to pass to Rust.
//
// On error, an error code will be stored in result.  Make sure to check this before
// passing the args to Invoke().
//
// For async calls this should be called in the main thread, since the GC can
// move the ArrayBuffer pointers while the background task is waiting.
Args PrepareArgs(const UniFFIPointer& ptr, const int8_t& value,
    mozilla::ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args
    Args uniFFIArgs;
    // We check if the pointer in the argument passed has the same type expected by this
    // function
    if (!ptr.isSamePtrType(&RetourneurPointerType::getInstance())) {
        aUniFFIError.ThrowTypeError("pointer ptr is not of type Retourneur");
        return uniFFIArgs;
    }
    uniFFIArgs.ptr = ptr.getPtr();
    uniFFIArgs.value = value;

    return uniFFIArgs;
}

// Call the scaffolding function
//
// For async calls this should be called in the worker thread
Result Invoke(Args& aArgs) {
    Result result = {};result.mReturnValue =::rondpoint_9336_Retourneur_identique_i8(
         aArgs.ptr,
         aArgs.value,
         &result.mCallStatus
     );
    return result;
}

// Return the result of the scaffolding call back to JS
void ReturnResult(JSContext* aContext, const Result& aCallResult, RootedDictionary<UniFFIRustCallResult>& aReturnValue) {
    switch (aCallResult.mCallStatus.code) {
        case uniffi::CALL_SUCCESS: {
            // Successful call.  Populate data with the return value
            aReturnValue.mCode = uniffi::CALL_SUCCESS;
            // Numeric Return
            aReturnValue.mData.setNumber(aCallResult.mReturnValue);
            break;
        }

        case uniffi::CALL_ERROR:
            // Rust Err() value.  Populate data with the `RustBuffer` containing the error
            aReturnValue.mCode = uniffi::CALL_ERROR;
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mCallStatus.error_buf).intoArrayBuffer(aContext));
            break;

        default:
            // This indicates a RustError, which shouldn't happen in practice since FF sets panic=abort
            aReturnValue.mCode = uniffi::CALL_INTERNAL_ERROR;
            aReturnValue.mInternalErrorMessage.AssignLiteral(u"Unexpected Error");
            break;
    }
}
}
// For each Rust scaffolding function, define types and functions for calling it
namespace rondpoint_9336_retourneur_identique_u8 {
using namespace mozilla::dom;
// Arguments to pass to the scaffolding function
struct Args {
    void * ptr;
    uint8_t value;
};

// Return values from the scaffolding function
struct Result {
    uint8_t mReturnValue;
    RustCallStatus mCallStatus = {};
};

// Convert the arguments we get from JS to arguments to pass to Rust.
//
// On error, an error code will be stored in result.  Make sure to check this before
// passing the args to Invoke().
//
// For async calls this should be called in the main thread, since the GC can
// move the ArrayBuffer pointers while the background task is waiting.
Args PrepareArgs(const UniFFIPointer& ptr, const uint8_t& value,
    mozilla::ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args
    Args uniFFIArgs;
    // We check if the pointer in the argument passed has the same type expected by this
    // function
    if (!ptr.isSamePtrType(&RetourneurPointerType::getInstance())) {
        aUniFFIError.ThrowTypeError("pointer ptr is not of type Retourneur");
        return uniFFIArgs;
    }
    uniFFIArgs.ptr = ptr.getPtr();
    uniFFIArgs.value = value;

    return uniFFIArgs;
}

// Call the scaffolding function
//
// For async calls this should be called in the worker thread
Result Invoke(Args& aArgs) {
    Result result = {};result.mReturnValue =::rondpoint_9336_Retourneur_identique_u8(
         aArgs.ptr,
         aArgs.value,
         &result.mCallStatus
     );
    return result;
}

// Return the result of the scaffolding call back to JS
void ReturnResult(JSContext* aContext, const Result& aCallResult, RootedDictionary<UniFFIRustCallResult>& aReturnValue) {
    switch (aCallResult.mCallStatus.code) {
        case uniffi::CALL_SUCCESS: {
            // Successful call.  Populate data with the return value
            aReturnValue.mCode = uniffi::CALL_SUCCESS;
            // Numeric Return
            aReturnValue.mData.setNumber(aCallResult.mReturnValue);
            break;
        }

        case uniffi::CALL_ERROR:
            // Rust Err() value.  Populate data with the `RustBuffer` containing the error
            aReturnValue.mCode = uniffi::CALL_ERROR;
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mCallStatus.error_buf).intoArrayBuffer(aContext));
            break;

        default:
            // This indicates a RustError, which shouldn't happen in practice since FF sets panic=abort
            aReturnValue.mCode = uniffi::CALL_INTERNAL_ERROR;
            aReturnValue.mInternalErrorMessage.AssignLiteral(u"Unexpected Error");
            break;
    }
}
}
// For each Rust scaffolding function, define types and functions for calling it
namespace rondpoint_9336_retourneur_identique_i16 {
using namespace mozilla::dom;
// Arguments to pass to the scaffolding function
struct Args {
    void * ptr;
    int16_t value;
};

// Return values from the scaffolding function
struct Result {
    int16_t mReturnValue;
    RustCallStatus mCallStatus = {};
};

// Convert the arguments we get from JS to arguments to pass to Rust.
//
// On error, an error code will be stored in result.  Make sure to check this before
// passing the args to Invoke().
//
// For async calls this should be called in the main thread, since the GC can
// move the ArrayBuffer pointers while the background task is waiting.
Args PrepareArgs(const UniFFIPointer& ptr, const int16_t& value,
    mozilla::ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args
    Args uniFFIArgs;
    // We check if the pointer in the argument passed has the same type expected by this
    // function
    if (!ptr.isSamePtrType(&RetourneurPointerType::getInstance())) {
        aUniFFIError.ThrowTypeError("pointer ptr is not of type Retourneur");
        return uniFFIArgs;
    }
    uniFFIArgs.ptr = ptr.getPtr();
    uniFFIArgs.value = value;

    return uniFFIArgs;
}

// Call the scaffolding function
//
// For async calls this should be called in the worker thread
Result Invoke(Args& aArgs) {
    Result result = {};result.mReturnValue =::rondpoint_9336_Retourneur_identique_i16(
         aArgs.ptr,
         aArgs.value,
         &result.mCallStatus
     );
    return result;
}

// Return the result of the scaffolding call back to JS
void ReturnResult(JSContext* aContext, const Result& aCallResult, RootedDictionary<UniFFIRustCallResult>& aReturnValue) {
    switch (aCallResult.mCallStatus.code) {
        case uniffi::CALL_SUCCESS: {
            // Successful call.  Populate data with the return value
            aReturnValue.mCode = uniffi::CALL_SUCCESS;
            // Numeric Return
            aReturnValue.mData.setNumber(aCallResult.mReturnValue);
            break;
        }

        case uniffi::CALL_ERROR:
            // Rust Err() value.  Populate data with the `RustBuffer` containing the error
            aReturnValue.mCode = uniffi::CALL_ERROR;
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mCallStatus.error_buf).intoArrayBuffer(aContext));
            break;

        default:
            // This indicates a RustError, which shouldn't happen in practice since FF sets panic=abort
            aReturnValue.mCode = uniffi::CALL_INTERNAL_ERROR;
            aReturnValue.mInternalErrorMessage.AssignLiteral(u"Unexpected Error");
            break;
    }
}
}
// For each Rust scaffolding function, define types and functions for calling it
namespace rondpoint_9336_retourneur_identique_u16 {
using namespace mozilla::dom;
// Arguments to pass to the scaffolding function
struct Args {
    void * ptr;
    uint16_t value;
};

// Return values from the scaffolding function
struct Result {
    uint16_t mReturnValue;
    RustCallStatus mCallStatus = {};
};

// Convert the arguments we get from JS to arguments to pass to Rust.
//
// On error, an error code will be stored in result.  Make sure to check this before
// passing the args to Invoke().
//
// For async calls this should be called in the main thread, since the GC can
// move the ArrayBuffer pointers while the background task is waiting.
Args PrepareArgs(const UniFFIPointer& ptr, const uint16_t& value,
    mozilla::ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args
    Args uniFFIArgs;
    // We check if the pointer in the argument passed has the same type expected by this
    // function
    if (!ptr.isSamePtrType(&RetourneurPointerType::getInstance())) {
        aUniFFIError.ThrowTypeError("pointer ptr is not of type Retourneur");
        return uniFFIArgs;
    }
    uniFFIArgs.ptr = ptr.getPtr();
    uniFFIArgs.value = value;

    return uniFFIArgs;
}

// Call the scaffolding function
//
// For async calls this should be called in the worker thread
Result Invoke(Args& aArgs) {
    Result result = {};result.mReturnValue =::rondpoint_9336_Retourneur_identique_u16(
         aArgs.ptr,
         aArgs.value,
         &result.mCallStatus
     );
    return result;
}

// Return the result of the scaffolding call back to JS
void ReturnResult(JSContext* aContext, const Result& aCallResult, RootedDictionary<UniFFIRustCallResult>& aReturnValue) {
    switch (aCallResult.mCallStatus.code) {
        case uniffi::CALL_SUCCESS: {
            // Successful call.  Populate data with the return value
            aReturnValue.mCode = uniffi::CALL_SUCCESS;
            // Numeric Return
            aReturnValue.mData.setNumber(aCallResult.mReturnValue);
            break;
        }

        case uniffi::CALL_ERROR:
            // Rust Err() value.  Populate data with the `RustBuffer` containing the error
            aReturnValue.mCode = uniffi::CALL_ERROR;
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mCallStatus.error_buf).intoArrayBuffer(aContext));
            break;

        default:
            // This indicates a RustError, which shouldn't happen in practice since FF sets panic=abort
            aReturnValue.mCode = uniffi::CALL_INTERNAL_ERROR;
            aReturnValue.mInternalErrorMessage.AssignLiteral(u"Unexpected Error");
            break;
    }
}
}
// For each Rust scaffolding function, define types and functions for calling it
namespace rondpoint_9336_retourneur_identique_i32 {
using namespace mozilla::dom;
// Arguments to pass to the scaffolding function
struct Args {
    void * ptr;
    int32_t value;
};

// Return values from the scaffolding function
struct Result {
    int32_t mReturnValue;
    RustCallStatus mCallStatus = {};
};

// Convert the arguments we get from JS to arguments to pass to Rust.
//
// On error, an error code will be stored in result.  Make sure to check this before
// passing the args to Invoke().
//
// For async calls this should be called in the main thread, since the GC can
// move the ArrayBuffer pointers while the background task is waiting.
Args PrepareArgs(const UniFFIPointer& ptr, const int32_t& value,
    mozilla::ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args
    Args uniFFIArgs;
    // We check if the pointer in the argument passed has the same type expected by this
    // function
    if (!ptr.isSamePtrType(&RetourneurPointerType::getInstance())) {
        aUniFFIError.ThrowTypeError("pointer ptr is not of type Retourneur");
        return uniFFIArgs;
    }
    uniFFIArgs.ptr = ptr.getPtr();
    uniFFIArgs.value = value;

    return uniFFIArgs;
}

// Call the scaffolding function
//
// For async calls this should be called in the worker thread
Result Invoke(Args& aArgs) {
    Result result = {};result.mReturnValue =::rondpoint_9336_Retourneur_identique_i32(
         aArgs.ptr,
         aArgs.value,
         &result.mCallStatus
     );
    return result;
}

// Return the result of the scaffolding call back to JS
void ReturnResult(JSContext* aContext, const Result& aCallResult, RootedDictionary<UniFFIRustCallResult>& aReturnValue) {
    switch (aCallResult.mCallStatus.code) {
        case uniffi::CALL_SUCCESS: {
            // Successful call.  Populate data with the return value
            aReturnValue.mCode = uniffi::CALL_SUCCESS;
            // Numeric Return
            aReturnValue.mData.setNumber(aCallResult.mReturnValue);
            break;
        }

        case uniffi::CALL_ERROR:
            // Rust Err() value.  Populate data with the `RustBuffer` containing the error
            aReturnValue.mCode = uniffi::CALL_ERROR;
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mCallStatus.error_buf).intoArrayBuffer(aContext));
            break;

        default:
            // This indicates a RustError, which shouldn't happen in practice since FF sets panic=abort
            aReturnValue.mCode = uniffi::CALL_INTERNAL_ERROR;
            aReturnValue.mInternalErrorMessage.AssignLiteral(u"Unexpected Error");
            break;
    }
}
}
// For each Rust scaffolding function, define types and functions for calling it
namespace rondpoint_9336_retourneur_identique_u32 {
using namespace mozilla::dom;
// Arguments to pass to the scaffolding function
struct Args {
    void * ptr;
    uint32_t value;
};

// Return values from the scaffolding function
struct Result {
    uint32_t mReturnValue;
    RustCallStatus mCallStatus = {};
};

// Convert the arguments we get from JS to arguments to pass to Rust.
//
// On error, an error code will be stored in result.  Make sure to check this before
// passing the args to Invoke().
//
// For async calls this should be called in the main thread, since the GC can
// move the ArrayBuffer pointers while the background task is waiting.
Args PrepareArgs(const UniFFIPointer& ptr, const uint32_t& value,
    mozilla::ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args
    Args uniFFIArgs;
    // We check if the pointer in the argument passed has the same type expected by this
    // function
    if (!ptr.isSamePtrType(&RetourneurPointerType::getInstance())) {
        aUniFFIError.ThrowTypeError("pointer ptr is not of type Retourneur");
        return uniFFIArgs;
    }
    uniFFIArgs.ptr = ptr.getPtr();
    uniFFIArgs.value = value;

    return uniFFIArgs;
}

// Call the scaffolding function
//
// For async calls this should be called in the worker thread
Result Invoke(Args& aArgs) {
    Result result = {};result.mReturnValue =::rondpoint_9336_Retourneur_identique_u32(
         aArgs.ptr,
         aArgs.value,
         &result.mCallStatus
     );
    return result;
}

// Return the result of the scaffolding call back to JS
void ReturnResult(JSContext* aContext, const Result& aCallResult, RootedDictionary<UniFFIRustCallResult>& aReturnValue) {
    switch (aCallResult.mCallStatus.code) {
        case uniffi::CALL_SUCCESS: {
            // Successful call.  Populate data with the return value
            aReturnValue.mCode = uniffi::CALL_SUCCESS;
            // Numeric Return
            aReturnValue.mData.setNumber(aCallResult.mReturnValue);
            break;
        }

        case uniffi::CALL_ERROR:
            // Rust Err() value.  Populate data with the `RustBuffer` containing the error
            aReturnValue.mCode = uniffi::CALL_ERROR;
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mCallStatus.error_buf).intoArrayBuffer(aContext));
            break;

        default:
            // This indicates a RustError, which shouldn't happen in practice since FF sets panic=abort
            aReturnValue.mCode = uniffi::CALL_INTERNAL_ERROR;
            aReturnValue.mInternalErrorMessage.AssignLiteral(u"Unexpected Error");
            break;
    }
}
}
// For each Rust scaffolding function, define types and functions for calling it
namespace rondpoint_9336_retourneur_identique_i64 {
using namespace mozilla::dom;
// Arguments to pass to the scaffolding function
struct Args {
    void * ptr;
    int64_t value;
};

// Return values from the scaffolding function
struct Result {
    int64_t mReturnValue;
    RustCallStatus mCallStatus = {};
};

// Convert the arguments we get from JS to arguments to pass to Rust.
//
// On error, an error code will be stored in result.  Make sure to check this before
// passing the args to Invoke().
//
// For async calls this should be called in the main thread, since the GC can
// move the ArrayBuffer pointers while the background task is waiting.
Args PrepareArgs(const UniFFIPointer& ptr, const int64_t& value,
    mozilla::ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args
    Args uniFFIArgs;
    // We check if the pointer in the argument passed has the same type expected by this
    // function
    if (!ptr.isSamePtrType(&RetourneurPointerType::getInstance())) {
        aUniFFIError.ThrowTypeError("pointer ptr is not of type Retourneur");
        return uniFFIArgs;
    }
    uniFFIArgs.ptr = ptr.getPtr();
    uniFFIArgs.value = value;

    return uniFFIArgs;
}

// Call the scaffolding function
//
// For async calls this should be called in the worker thread
Result Invoke(Args& aArgs) {
    Result result = {};result.mReturnValue =::rondpoint_9336_Retourneur_identique_i64(
         aArgs.ptr,
         aArgs.value,
         &result.mCallStatus
     );
    return result;
}

// Return the result of the scaffolding call back to JS
void ReturnResult(JSContext* aContext, const Result& aCallResult, RootedDictionary<UniFFIRustCallResult>& aReturnValue) {
    switch (aCallResult.mCallStatus.code) {
        case uniffi::CALL_SUCCESS: {
            // Successful call.  Populate data with the return value
            aReturnValue.mCode = uniffi::CALL_SUCCESS;
            // Numeric Return
            aReturnValue.mData.setNumber(aCallResult.mReturnValue);
            break;
        }

        case uniffi::CALL_ERROR:
            // Rust Err() value.  Populate data with the `RustBuffer` containing the error
            aReturnValue.mCode = uniffi::CALL_ERROR;
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mCallStatus.error_buf).intoArrayBuffer(aContext));
            break;

        default:
            // This indicates a RustError, which shouldn't happen in practice since FF sets panic=abort
            aReturnValue.mCode = uniffi::CALL_INTERNAL_ERROR;
            aReturnValue.mInternalErrorMessage.AssignLiteral(u"Unexpected Error");
            break;
    }
}
}
// For each Rust scaffolding function, define types and functions for calling it
namespace rondpoint_9336_retourneur_identique_u64 {
using namespace mozilla::dom;
// Arguments to pass to the scaffolding function
struct Args {
    void * ptr;
    uint64_t value;
};

// Return values from the scaffolding function
struct Result {
    uint64_t mReturnValue;
    RustCallStatus mCallStatus = {};
};

// Convert the arguments we get from JS to arguments to pass to Rust.
//
// On error, an error code will be stored in result.  Make sure to check this before
// passing the args to Invoke().
//
// For async calls this should be called in the main thread, since the GC can
// move the ArrayBuffer pointers while the background task is waiting.
Args PrepareArgs(const UniFFIPointer& ptr, const uint64_t& value,
    mozilla::ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args
    Args uniFFIArgs;
    // We check if the pointer in the argument passed has the same type expected by this
    // function
    if (!ptr.isSamePtrType(&RetourneurPointerType::getInstance())) {
        aUniFFIError.ThrowTypeError("pointer ptr is not of type Retourneur");
        return uniFFIArgs;
    }
    uniFFIArgs.ptr = ptr.getPtr();
    uniFFIArgs.value = value;

    return uniFFIArgs;
}

// Call the scaffolding function
//
// For async calls this should be called in the worker thread
Result Invoke(Args& aArgs) {
    Result result = {};result.mReturnValue =::rondpoint_9336_Retourneur_identique_u64(
         aArgs.ptr,
         aArgs.value,
         &result.mCallStatus
     );
    return result;
}

// Return the result of the scaffolding call back to JS
void ReturnResult(JSContext* aContext, const Result& aCallResult, RootedDictionary<UniFFIRustCallResult>& aReturnValue) {
    switch (aCallResult.mCallStatus.code) {
        case uniffi::CALL_SUCCESS: {
            // Successful call.  Populate data with the return value
            aReturnValue.mCode = uniffi::CALL_SUCCESS;
            // Numeric Return
            aReturnValue.mData.setNumber(aCallResult.mReturnValue);
            break;
        }

        case uniffi::CALL_ERROR:
            // Rust Err() value.  Populate data with the `RustBuffer` containing the error
            aReturnValue.mCode = uniffi::CALL_ERROR;
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mCallStatus.error_buf).intoArrayBuffer(aContext));
            break;

        default:
            // This indicates a RustError, which shouldn't happen in practice since FF sets panic=abort
            aReturnValue.mCode = uniffi::CALL_INTERNAL_ERROR;
            aReturnValue.mInternalErrorMessage.AssignLiteral(u"Unexpected Error");
            break;
    }
}
}
// For each Rust scaffolding function, define types and functions for calling it
namespace rondpoint_9336_retourneur_identique_float {
using namespace mozilla::dom;
// Arguments to pass to the scaffolding function
struct Args {
    void * ptr;
    float value;
};

// Return values from the scaffolding function
struct Result {
    float mReturnValue;
    RustCallStatus mCallStatus = {};
};

// Convert the arguments we get from JS to arguments to pass to Rust.
//
// On error, an error code will be stored in result.  Make sure to check this before
// passing the args to Invoke().
//
// For async calls this should be called in the main thread, since the GC can
// move the ArrayBuffer pointers while the background task is waiting.
Args PrepareArgs(const UniFFIPointer& ptr, const float& value,
    mozilla::ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args
    Args uniFFIArgs;
    // We check if the pointer in the argument passed has the same type expected by this
    // function
    if (!ptr.isSamePtrType(&RetourneurPointerType::getInstance())) {
        aUniFFIError.ThrowTypeError("pointer ptr is not of type Retourneur");
        return uniFFIArgs;
    }
    uniFFIArgs.ptr = ptr.getPtr();
    uniFFIArgs.value = value;

    return uniFFIArgs;
}

// Call the scaffolding function
//
// For async calls this should be called in the worker thread
Result Invoke(Args& aArgs) {
    Result result = {};result.mReturnValue =::rondpoint_9336_Retourneur_identique_float(
         aArgs.ptr,
         aArgs.value,
         &result.mCallStatus
     );
    return result;
}

// Return the result of the scaffolding call back to JS
void ReturnResult(JSContext* aContext, const Result& aCallResult, RootedDictionary<UniFFIRustCallResult>& aReturnValue) {
    switch (aCallResult.mCallStatus.code) {
        case uniffi::CALL_SUCCESS: {
            // Successful call.  Populate data with the return value
            aReturnValue.mCode = uniffi::CALL_SUCCESS;
            // Numeric Return
            aReturnValue.mData.setNumber(aCallResult.mReturnValue);
            break;
        }

        case uniffi::CALL_ERROR:
            // Rust Err() value.  Populate data with the `RustBuffer` containing the error
            aReturnValue.mCode = uniffi::CALL_ERROR;
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mCallStatus.error_buf).intoArrayBuffer(aContext));
            break;

        default:
            // This indicates a RustError, which shouldn't happen in practice since FF sets panic=abort
            aReturnValue.mCode = uniffi::CALL_INTERNAL_ERROR;
            aReturnValue.mInternalErrorMessage.AssignLiteral(u"Unexpected Error");
            break;
    }
}
}
// For each Rust scaffolding function, define types and functions for calling it
namespace rondpoint_9336_retourneur_identique_double {
using namespace mozilla::dom;
// Arguments to pass to the scaffolding function
struct Args {
    void * ptr;
    double value;
};

// Return values from the scaffolding function
struct Result {
    double mReturnValue;
    RustCallStatus mCallStatus = {};
};

// Convert the arguments we get from JS to arguments to pass to Rust.
//
// On error, an error code will be stored in result.  Make sure to check this before
// passing the args to Invoke().
//
// For async calls this should be called in the main thread, since the GC can
// move the ArrayBuffer pointers while the background task is waiting.
Args PrepareArgs(const UniFFIPointer& ptr, const double& value,
    mozilla::ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args
    Args uniFFIArgs;
    // We check if the pointer in the argument passed has the same type expected by this
    // function
    if (!ptr.isSamePtrType(&RetourneurPointerType::getInstance())) {
        aUniFFIError.ThrowTypeError("pointer ptr is not of type Retourneur");
        return uniFFIArgs;
    }
    uniFFIArgs.ptr = ptr.getPtr();
    uniFFIArgs.value = value;

    return uniFFIArgs;
}

// Call the scaffolding function
//
// For async calls this should be called in the worker thread
Result Invoke(Args& aArgs) {
    Result result = {};result.mReturnValue =::rondpoint_9336_Retourneur_identique_double(
         aArgs.ptr,
         aArgs.value,
         &result.mCallStatus
     );
    return result;
}

// Return the result of the scaffolding call back to JS
void ReturnResult(JSContext* aContext, const Result& aCallResult, RootedDictionary<UniFFIRustCallResult>& aReturnValue) {
    switch (aCallResult.mCallStatus.code) {
        case uniffi::CALL_SUCCESS: {
            // Successful call.  Populate data with the return value
            aReturnValue.mCode = uniffi::CALL_SUCCESS;
            // Numeric Return
            aReturnValue.mData.setNumber(aCallResult.mReturnValue);
            break;
        }

        case uniffi::CALL_ERROR:
            // Rust Err() value.  Populate data with the `RustBuffer` containing the error
            aReturnValue.mCode = uniffi::CALL_ERROR;
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mCallStatus.error_buf).intoArrayBuffer(aContext));
            break;

        default:
            // This indicates a RustError, which shouldn't happen in practice since FF sets panic=abort
            aReturnValue.mCode = uniffi::CALL_INTERNAL_ERROR;
            aReturnValue.mInternalErrorMessage.AssignLiteral(u"Unexpected Error");
            break;
    }
}
}
// For each Rust scaffolding function, define types and functions for calling it
namespace rondpoint_9336_retourneur_identique_boolean {
using namespace mozilla::dom;
// Arguments to pass to the scaffolding function
struct Args {
    void * ptr;
    int8_t value;
};

// Return values from the scaffolding function
struct Result {
    int8_t mReturnValue;
    RustCallStatus mCallStatus = {};
};

// Convert the arguments we get from JS to arguments to pass to Rust.
//
// On error, an error code will be stored in result.  Make sure to check this before
// passing the args to Invoke().
//
// For async calls this should be called in the main thread, since the GC can
// move the ArrayBuffer pointers while the background task is waiting.
Args PrepareArgs(const UniFFIPointer& ptr, const int8_t& value,
    mozilla::ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args
    Args uniFFIArgs;
    // We check if the pointer in the argument passed has the same type expected by this
    // function
    if (!ptr.isSamePtrType(&RetourneurPointerType::getInstance())) {
        aUniFFIError.ThrowTypeError("pointer ptr is not of type Retourneur");
        return uniFFIArgs;
    }
    uniFFIArgs.ptr = ptr.getPtr();
    uniFFIArgs.value = value;

    return uniFFIArgs;
}

// Call the scaffolding function
//
// For async calls this should be called in the worker thread
Result Invoke(Args& aArgs) {
    Result result = {};result.mReturnValue =::rondpoint_9336_Retourneur_identique_boolean(
         aArgs.ptr,
         aArgs.value,
         &result.mCallStatus
     );
    return result;
}

// Return the result of the scaffolding call back to JS
void ReturnResult(JSContext* aContext, const Result& aCallResult, RootedDictionary<UniFFIRustCallResult>& aReturnValue) {
    switch (aCallResult.mCallStatus.code) {
        case uniffi::CALL_SUCCESS: {
            // Successful call.  Populate data with the return value
            aReturnValue.mCode = uniffi::CALL_SUCCESS;
            // Numeric Return
            aReturnValue.mData.setNumber(aCallResult.mReturnValue);
            break;
        }

        case uniffi::CALL_ERROR:
            // Rust Err() value.  Populate data with the `RustBuffer` containing the error
            aReturnValue.mCode = uniffi::CALL_ERROR;
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mCallStatus.error_buf).intoArrayBuffer(aContext));
            break;

        default:
            // This indicates a RustError, which shouldn't happen in practice since FF sets panic=abort
            aReturnValue.mCode = uniffi::CALL_INTERNAL_ERROR;
            aReturnValue.mInternalErrorMessage.AssignLiteral(u"Unexpected Error");
            break;
    }
}
}
// For each Rust scaffolding function, define types and functions for calling it
namespace rondpoint_9336_retourneur_identique_string {
using namespace mozilla::dom;
// Arguments to pass to the scaffolding function
struct Args {
    void * ptr;
    // RustBuffer arguments are stored as OwnedRustBuffer instances.  That class takes care of
    // freeing the buffer if the arguments don't get passed to Rust (i.e. intoRustBuffer()
    // isn't called).  This can happen if some of the ArrayBuffer arguments are succuessfully
    // converted, but one fails to convert.
    mozilla::dom::OwnedRustBuffer value;
};

// Return values from the scaffolding function
struct Result {
    RustBuffer mReturnValue;
    RustCallStatus mCallStatus = {};
};

// Convert the arguments we get from JS to arguments to pass to Rust.
//
// On error, an error code will be stored in result.  Make sure to check this before
// passing the args to Invoke().
//
// For async calls this should be called in the main thread, since the GC can
// move the ArrayBuffer pointers while the background task is waiting.
Args PrepareArgs(const UniFFIPointer& ptr, const ArrayBuffer& value,
    mozilla::ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args
    Args uniFFIArgs;
    // We check if the pointer in the argument passed has the same type expected by this
    // function
    if (!ptr.isSamePtrType(&RetourneurPointerType::getInstance())) {
        aUniFFIError.ThrowTypeError("pointer ptr is not of type Retourneur");
        return uniFFIArgs;
    }
    uniFFIArgs.ptr = ptr.getPtr();
    // Convert the ArrayBuffer we get from JS to an OwnedRustBuffer
    value.ComputeState();
    uniFFIArgs.value = OwnedRustBuffer(value, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return uniFFIArgs;
    }

    return uniFFIArgs;
}

// Call the scaffolding function
//
// For async calls this should be called in the worker thread
Result Invoke(Args& aArgs) {
    Result result = {};result.mReturnValue =::rondpoint_9336_Retourneur_identique_string(
         aArgs.ptr,
         // Call intoRustBuffer() to get a `RustBuffer` from an OwnedRustBuffer.  This transfers ownership to Rust,
         // OwnedRustBuffer will no longer try to free it
         aArgs.value.intoRustBuffer(),
         &result.mCallStatus
     );
    return result;
}

// Return the result of the scaffolding call back to JS
void ReturnResult(JSContext* aContext, const Result& aCallResult, RootedDictionary<UniFFIRustCallResult>& aReturnValue) {
    switch (aCallResult.mCallStatus.code) {
        case uniffi::CALL_SUCCESS: {
            // Successful call.  Populate data with the return value
            aReturnValue.mCode = uniffi::CALL_SUCCESS;
            // RustBuffer return, convert it to an ArrayBuffer
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mReturnValue).intoArrayBuffer(aContext));
            break;
        }

        case uniffi::CALL_ERROR:
            // Rust Err() value.  Populate data with the `RustBuffer` containing the error
            aReturnValue.mCode = uniffi::CALL_ERROR;
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mCallStatus.error_buf).intoArrayBuffer(aContext));
            break;

        default:
            // This indicates a RustError, which shouldn't happen in practice since FF sets panic=abort
            aReturnValue.mCode = uniffi::CALL_INTERNAL_ERROR;
            aReturnValue.mInternalErrorMessage.AssignLiteral(u"Unexpected Error");
            break;
    }
}
}
// For each Rust scaffolding function, define types and functions for calling it
namespace rondpoint_9336_retourneur_identique_nombres_signes {
using namespace mozilla::dom;
// Arguments to pass to the scaffolding function
struct Args {
    void * ptr;
    // RustBuffer arguments are stored as OwnedRustBuffer instances.  That class takes care of
    // freeing the buffer if the arguments don't get passed to Rust (i.e. intoRustBuffer()
    // isn't called).  This can happen if some of the ArrayBuffer arguments are succuessfully
    // converted, but one fails to convert.
    mozilla::dom::OwnedRustBuffer value;
};

// Return values from the scaffolding function
struct Result {
    RustBuffer mReturnValue;
    RustCallStatus mCallStatus = {};
};

// Convert the arguments we get from JS to arguments to pass to Rust.
//
// On error, an error code will be stored in result.  Make sure to check this before
// passing the args to Invoke().
//
// For async calls this should be called in the main thread, since the GC can
// move the ArrayBuffer pointers while the background task is waiting.
Args PrepareArgs(const UniFFIPointer& ptr, const ArrayBuffer& value,
    mozilla::ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args
    Args uniFFIArgs;
    // We check if the pointer in the argument passed has the same type expected by this
    // function
    if (!ptr.isSamePtrType(&RetourneurPointerType::getInstance())) {
        aUniFFIError.ThrowTypeError("pointer ptr is not of type Retourneur");
        return uniFFIArgs;
    }
    uniFFIArgs.ptr = ptr.getPtr();
    // Convert the ArrayBuffer we get from JS to an OwnedRustBuffer
    value.ComputeState();
    uniFFIArgs.value = OwnedRustBuffer(value, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return uniFFIArgs;
    }

    return uniFFIArgs;
}

// Call the scaffolding function
//
// For async calls this should be called in the worker thread
Result Invoke(Args& aArgs) {
    Result result = {};result.mReturnValue =::rondpoint_9336_Retourneur_identique_nombres_signes(
         aArgs.ptr,
         // Call intoRustBuffer() to get a `RustBuffer` from an OwnedRustBuffer.  This transfers ownership to Rust,
         // OwnedRustBuffer will no longer try to free it
         aArgs.value.intoRustBuffer(),
         &result.mCallStatus
     );
    return result;
}

// Return the result of the scaffolding call back to JS
void ReturnResult(JSContext* aContext, const Result& aCallResult, RootedDictionary<UniFFIRustCallResult>& aReturnValue) {
    switch (aCallResult.mCallStatus.code) {
        case uniffi::CALL_SUCCESS: {
            // Successful call.  Populate data with the return value
            aReturnValue.mCode = uniffi::CALL_SUCCESS;
            // RustBuffer return, convert it to an ArrayBuffer
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mReturnValue).intoArrayBuffer(aContext));
            break;
        }

        case uniffi::CALL_ERROR:
            // Rust Err() value.  Populate data with the `RustBuffer` containing the error
            aReturnValue.mCode = uniffi::CALL_ERROR;
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mCallStatus.error_buf).intoArrayBuffer(aContext));
            break;

        default:
            // This indicates a RustError, which shouldn't happen in practice since FF sets panic=abort
            aReturnValue.mCode = uniffi::CALL_INTERNAL_ERROR;
            aReturnValue.mInternalErrorMessage.AssignLiteral(u"Unexpected Error");
            break;
    }
}
}
// For each Rust scaffolding function, define types and functions for calling it
namespace rondpoint_9336_retourneur_identique_nombres {
using namespace mozilla::dom;
// Arguments to pass to the scaffolding function
struct Args {
    void * ptr;
    // RustBuffer arguments are stored as OwnedRustBuffer instances.  That class takes care of
    // freeing the buffer if the arguments don't get passed to Rust (i.e. intoRustBuffer()
    // isn't called).  This can happen if some of the ArrayBuffer arguments are succuessfully
    // converted, but one fails to convert.
    mozilla::dom::OwnedRustBuffer value;
};

// Return values from the scaffolding function
struct Result {
    RustBuffer mReturnValue;
    RustCallStatus mCallStatus = {};
};

// Convert the arguments we get from JS to arguments to pass to Rust.
//
// On error, an error code will be stored in result.  Make sure to check this before
// passing the args to Invoke().
//
// For async calls this should be called in the main thread, since the GC can
// move the ArrayBuffer pointers while the background task is waiting.
Args PrepareArgs(const UniFFIPointer& ptr, const ArrayBuffer& value,
    mozilla::ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args
    Args uniFFIArgs;
    // We check if the pointer in the argument passed has the same type expected by this
    // function
    if (!ptr.isSamePtrType(&RetourneurPointerType::getInstance())) {
        aUniFFIError.ThrowTypeError("pointer ptr is not of type Retourneur");
        return uniFFIArgs;
    }
    uniFFIArgs.ptr = ptr.getPtr();
    // Convert the ArrayBuffer we get from JS to an OwnedRustBuffer
    value.ComputeState();
    uniFFIArgs.value = OwnedRustBuffer(value, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return uniFFIArgs;
    }

    return uniFFIArgs;
}

// Call the scaffolding function
//
// For async calls this should be called in the worker thread
Result Invoke(Args& aArgs) {
    Result result = {};result.mReturnValue =::rondpoint_9336_Retourneur_identique_nombres(
         aArgs.ptr,
         // Call intoRustBuffer() to get a `RustBuffer` from an OwnedRustBuffer.  This transfers ownership to Rust,
         // OwnedRustBuffer will no longer try to free it
         aArgs.value.intoRustBuffer(),
         &result.mCallStatus
     );
    return result;
}

// Return the result of the scaffolding call back to JS
void ReturnResult(JSContext* aContext, const Result& aCallResult, RootedDictionary<UniFFIRustCallResult>& aReturnValue) {
    switch (aCallResult.mCallStatus.code) {
        case uniffi::CALL_SUCCESS: {
            // Successful call.  Populate data with the return value
            aReturnValue.mCode = uniffi::CALL_SUCCESS;
            // RustBuffer return, convert it to an ArrayBuffer
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mReturnValue).intoArrayBuffer(aContext));
            break;
        }

        case uniffi::CALL_ERROR:
            // Rust Err() value.  Populate data with the `RustBuffer` containing the error
            aReturnValue.mCode = uniffi::CALL_ERROR;
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mCallStatus.error_buf).intoArrayBuffer(aContext));
            break;

        default:
            // This indicates a RustError, which shouldn't happen in practice since FF sets panic=abort
            aReturnValue.mCode = uniffi::CALL_INTERNAL_ERROR;
            aReturnValue.mInternalErrorMessage.AssignLiteral(u"Unexpected Error");
            break;
    }
}
}
// For each Rust scaffolding function, define types and functions for calling it
namespace rondpoint_9336_retourneur_identique_optionneur_dictionnaire {
using namespace mozilla::dom;
// Arguments to pass to the scaffolding function
struct Args {
    void * ptr;
    // RustBuffer arguments are stored as OwnedRustBuffer instances.  That class takes care of
    // freeing the buffer if the arguments don't get passed to Rust (i.e. intoRustBuffer()
    // isn't called).  This can happen if some of the ArrayBuffer arguments are succuessfully
    // converted, but one fails to convert.
    mozilla::dom::OwnedRustBuffer value;
};

// Return values from the scaffolding function
struct Result {
    RustBuffer mReturnValue;
    RustCallStatus mCallStatus = {};
};

// Convert the arguments we get from JS to arguments to pass to Rust.
//
// On error, an error code will be stored in result.  Make sure to check this before
// passing the args to Invoke().
//
// For async calls this should be called in the main thread, since the GC can
// move the ArrayBuffer pointers while the background task is waiting.
Args PrepareArgs(const UniFFIPointer& ptr, const ArrayBuffer& value,
    mozilla::ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args
    Args uniFFIArgs;
    // We check if the pointer in the argument passed has the same type expected by this
    // function
    if (!ptr.isSamePtrType(&RetourneurPointerType::getInstance())) {
        aUniFFIError.ThrowTypeError("pointer ptr is not of type Retourneur");
        return uniFFIArgs;
    }
    uniFFIArgs.ptr = ptr.getPtr();
    // Convert the ArrayBuffer we get from JS to an OwnedRustBuffer
    value.ComputeState();
    uniFFIArgs.value = OwnedRustBuffer(value, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return uniFFIArgs;
    }

    return uniFFIArgs;
}

// Call the scaffolding function
//
// For async calls this should be called in the worker thread
Result Invoke(Args& aArgs) {
    Result result = {};result.mReturnValue =::rondpoint_9336_Retourneur_identique_optionneur_dictionnaire(
         aArgs.ptr,
         // Call intoRustBuffer() to get a `RustBuffer` from an OwnedRustBuffer.  This transfers ownership to Rust,
         // OwnedRustBuffer will no longer try to free it
         aArgs.value.intoRustBuffer(),
         &result.mCallStatus
     );
    return result;
}

// Return the result of the scaffolding call back to JS
void ReturnResult(JSContext* aContext, const Result& aCallResult, RootedDictionary<UniFFIRustCallResult>& aReturnValue) {
    switch (aCallResult.mCallStatus.code) {
        case uniffi::CALL_SUCCESS: {
            // Successful call.  Populate data with the return value
            aReturnValue.mCode = uniffi::CALL_SUCCESS;
            // RustBuffer return, convert it to an ArrayBuffer
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mReturnValue).intoArrayBuffer(aContext));
            break;
        }

        case uniffi::CALL_ERROR:
            // Rust Err() value.  Populate data with the `RustBuffer` containing the error
            aReturnValue.mCode = uniffi::CALL_ERROR;
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mCallStatus.error_buf).intoArrayBuffer(aContext));
            break;

        default:
            // This indicates a RustError, which shouldn't happen in practice since FF sets panic=abort
            aReturnValue.mCode = uniffi::CALL_INTERNAL_ERROR;
            aReturnValue.mInternalErrorMessage.AssignLiteral(u"Unexpected Error");
            break;
    }
}
}
// For each Rust scaffolding function, define types and functions for calling it
namespace ffi_rondpoint_9336_stringifier_object_free {
using namespace mozilla::dom;
// Arguments to pass to the scaffolding function
struct Args {
    void * ptr;
};

// Return values from the scaffolding function
struct Result {
    RustCallStatus mCallStatus = {};
};

// Convert the arguments we get from JS to arguments to pass to Rust.
//
// On error, an error code will be stored in result.  Make sure to check this before
// passing the args to Invoke().
//
// For async calls this should be called in the main thread, since the GC can
// move the ArrayBuffer pointers while the background task is waiting.
Args PrepareArgs(const UniFFIPointer& ptr,
    mozilla::ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args
    Args uniFFIArgs;
    // We check if the pointer in the argument passed has the same type expected by this
    // function
    if (!ptr.isSamePtrType(&StringifierPointerType::getInstance())) {
        aUniFFIError.ThrowTypeError("pointer ptr is not of type Stringifier");
        return uniFFIArgs;
    }
    uniFFIArgs.ptr = ptr.getPtr();

    return uniFFIArgs;
}

// Call the scaffolding function
//
// For async calls this should be called in the worker thread
Result Invoke(Args& aArgs) {
    Result result = {};::ffi_rondpoint_9336_Stringifier_object_free(
         aArgs.ptr,
         &result.mCallStatus
     );
    return result;
}

// Return the result of the scaffolding call back to JS
void ReturnResult(JSContext* aContext, const Result& aCallResult, RootedDictionary<UniFFIRustCallResult>& aReturnValue) {
    switch (aCallResult.mCallStatus.code) {
        case uniffi::CALL_SUCCESS: {
            // Successful call.  Populate data with the return value
            aReturnValue.mCode = uniffi::CALL_SUCCESS;
            // Void return
            break;
        }

        case uniffi::CALL_ERROR:
            // Rust Err() value.  Populate data with the `RustBuffer` containing the error
            aReturnValue.mCode = uniffi::CALL_ERROR;
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mCallStatus.error_buf).intoArrayBuffer(aContext));
            break;

        default:
            // This indicates a RustError, which shouldn't happen in practice since FF sets panic=abort
            aReturnValue.mCode = uniffi::CALL_INTERNAL_ERROR;
            aReturnValue.mInternalErrorMessage.AssignLiteral(u"Unexpected Error");
            break;
    }
}
}
// For each Rust scaffolding function, define types and functions for calling it
namespace rondpoint_9336_stringifier_new {
using namespace mozilla::dom;
// Arguments to pass to the scaffolding function
struct Args {
};

// Return values from the scaffolding function
struct Result {
    void * mReturnValue;
    RustCallStatus mCallStatus = {};
};

// Convert the arguments we get from JS to arguments to pass to Rust.
//
// On error, an error code will be stored in result.  Make sure to check this before
// passing the args to Invoke().
//
// For async calls this should be called in the main thread, since the GC can
// move the ArrayBuffer pointers while the background task is waiting.
Args PrepareArgs(
    mozilla::ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args
    Args uniFFIArgs;

    return uniFFIArgs;
}

// Call the scaffolding function
//
// For async calls this should be called in the worker thread
Result Invoke(Args& aArgs) {
    Result result = {};result.mReturnValue =::rondpoint_9336_Stringifier_new(
         &result.mCallStatus
     );
    return result;
}

// Return the result of the scaffolding call back to JS
void ReturnResult(JSContext* aContext, const Result& aCallResult, RootedDictionary<UniFFIRustCallResult>& aReturnValue) {
    switch (aCallResult.mCallStatus.code) {
        case uniffi::CALL_SUCCESS: {
            // Successful call.  Populate data with the return value
            aReturnValue.mCode = uniffi::CALL_SUCCESS;
            RefPtr<UniFFIPointer> uniFFIPtr = UniFFIPointer::Create(aCallResult.mReturnValue, &StringifierPointerType::getInstance() );
            aReturnValue.mData.setObjectOrNull(uniFFIPtr->WrapObject(aContext, nullptr));
            break;
        }

        case uniffi::CALL_ERROR:
            // Rust Err() value.  Populate data with the `RustBuffer` containing the error
            aReturnValue.mCode = uniffi::CALL_ERROR;
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mCallStatus.error_buf).intoArrayBuffer(aContext));
            break;

        default:
            // This indicates a RustError, which shouldn't happen in practice since FF sets panic=abort
            aReturnValue.mCode = uniffi::CALL_INTERNAL_ERROR;
            aReturnValue.mInternalErrorMessage.AssignLiteral(u"Unexpected Error");
            break;
    }
}
}
// For each Rust scaffolding function, define types and functions for calling it
namespace rondpoint_9336_stringifier_well_known_string {
using namespace mozilla::dom;
// Arguments to pass to the scaffolding function
struct Args {
    void * ptr;
    // RustBuffer arguments are stored as OwnedRustBuffer instances.  That class takes care of
    // freeing the buffer if the arguments don't get passed to Rust (i.e. intoRustBuffer()
    // isn't called).  This can happen if some of the ArrayBuffer arguments are succuessfully
    // converted, but one fails to convert.
    mozilla::dom::OwnedRustBuffer value;
};

// Return values from the scaffolding function
struct Result {
    RustBuffer mReturnValue;
    RustCallStatus mCallStatus = {};
};

// Convert the arguments we get from JS to arguments to pass to Rust.
//
// On error, an error code will be stored in result.  Make sure to check this before
// passing the args to Invoke().
//
// For async calls this should be called in the main thread, since the GC can
// move the ArrayBuffer pointers while the background task is waiting.
Args PrepareArgs(const UniFFIPointer& ptr, const ArrayBuffer& value,
    mozilla::ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args
    Args uniFFIArgs;
    // We check if the pointer in the argument passed has the same type expected by this
    // function
    if (!ptr.isSamePtrType(&StringifierPointerType::getInstance())) {
        aUniFFIError.ThrowTypeError("pointer ptr is not of type Stringifier");
        return uniFFIArgs;
    }
    uniFFIArgs.ptr = ptr.getPtr();
    // Convert the ArrayBuffer we get from JS to an OwnedRustBuffer
    value.ComputeState();
    uniFFIArgs.value = OwnedRustBuffer(value, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return uniFFIArgs;
    }

    return uniFFIArgs;
}

// Call the scaffolding function
//
// For async calls this should be called in the worker thread
Result Invoke(Args& aArgs) {
    Result result = {};result.mReturnValue =::rondpoint_9336_Stringifier_well_known_string(
         aArgs.ptr,
         // Call intoRustBuffer() to get a `RustBuffer` from an OwnedRustBuffer.  This transfers ownership to Rust,
         // OwnedRustBuffer will no longer try to free it
         aArgs.value.intoRustBuffer(),
         &result.mCallStatus
     );
    return result;
}

// Return the result of the scaffolding call back to JS
void ReturnResult(JSContext* aContext, const Result& aCallResult, RootedDictionary<UniFFIRustCallResult>& aReturnValue) {
    switch (aCallResult.mCallStatus.code) {
        case uniffi::CALL_SUCCESS: {
            // Successful call.  Populate data with the return value
            aReturnValue.mCode = uniffi::CALL_SUCCESS;
            // RustBuffer return, convert it to an ArrayBuffer
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mReturnValue).intoArrayBuffer(aContext));
            break;
        }

        case uniffi::CALL_ERROR:
            // Rust Err() value.  Populate data with the `RustBuffer` containing the error
            aReturnValue.mCode = uniffi::CALL_ERROR;
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mCallStatus.error_buf).intoArrayBuffer(aContext));
            break;

        default:
            // This indicates a RustError, which shouldn't happen in practice since FF sets panic=abort
            aReturnValue.mCode = uniffi::CALL_INTERNAL_ERROR;
            aReturnValue.mInternalErrorMessage.AssignLiteral(u"Unexpected Error");
            break;
    }
}
}
// For each Rust scaffolding function, define types and functions for calling it
namespace rondpoint_9336_stringifier_to_string_i8 {
using namespace mozilla::dom;
// Arguments to pass to the scaffolding function
struct Args {
    void * ptr;
    int8_t value;
};

// Return values from the scaffolding function
struct Result {
    RustBuffer mReturnValue;
    RustCallStatus mCallStatus = {};
};

// Convert the arguments we get from JS to arguments to pass to Rust.
//
// On error, an error code will be stored in result.  Make sure to check this before
// passing the args to Invoke().
//
// For async calls this should be called in the main thread, since the GC can
// move the ArrayBuffer pointers while the background task is waiting.
Args PrepareArgs(const UniFFIPointer& ptr, const int8_t& value,
    mozilla::ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args
    Args uniFFIArgs;
    // We check if the pointer in the argument passed has the same type expected by this
    // function
    if (!ptr.isSamePtrType(&StringifierPointerType::getInstance())) {
        aUniFFIError.ThrowTypeError("pointer ptr is not of type Stringifier");
        return uniFFIArgs;
    }
    uniFFIArgs.ptr = ptr.getPtr();
    uniFFIArgs.value = value;

    return uniFFIArgs;
}

// Call the scaffolding function
//
// For async calls this should be called in the worker thread
Result Invoke(Args& aArgs) {
    Result result = {};result.mReturnValue =::rondpoint_9336_Stringifier_to_string_i8(
         aArgs.ptr,
         aArgs.value,
         &result.mCallStatus
     );
    return result;
}

// Return the result of the scaffolding call back to JS
void ReturnResult(JSContext* aContext, const Result& aCallResult, RootedDictionary<UniFFIRustCallResult>& aReturnValue) {
    switch (aCallResult.mCallStatus.code) {
        case uniffi::CALL_SUCCESS: {
            // Successful call.  Populate data with the return value
            aReturnValue.mCode = uniffi::CALL_SUCCESS;
            // RustBuffer return, convert it to an ArrayBuffer
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mReturnValue).intoArrayBuffer(aContext));
            break;
        }

        case uniffi::CALL_ERROR:
            // Rust Err() value.  Populate data with the `RustBuffer` containing the error
            aReturnValue.mCode = uniffi::CALL_ERROR;
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mCallStatus.error_buf).intoArrayBuffer(aContext));
            break;

        default:
            // This indicates a RustError, which shouldn't happen in practice since FF sets panic=abort
            aReturnValue.mCode = uniffi::CALL_INTERNAL_ERROR;
            aReturnValue.mInternalErrorMessage.AssignLiteral(u"Unexpected Error");
            break;
    }
}
}
// For each Rust scaffolding function, define types and functions for calling it
namespace rondpoint_9336_stringifier_to_string_u8 {
using namespace mozilla::dom;
// Arguments to pass to the scaffolding function
struct Args {
    void * ptr;
    uint8_t value;
};

// Return values from the scaffolding function
struct Result {
    RustBuffer mReturnValue;
    RustCallStatus mCallStatus = {};
};

// Convert the arguments we get from JS to arguments to pass to Rust.
//
// On error, an error code will be stored in result.  Make sure to check this before
// passing the args to Invoke().
//
// For async calls this should be called in the main thread, since the GC can
// move the ArrayBuffer pointers while the background task is waiting.
Args PrepareArgs(const UniFFIPointer& ptr, const uint8_t& value,
    mozilla::ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args
    Args uniFFIArgs;
    // We check if the pointer in the argument passed has the same type expected by this
    // function
    if (!ptr.isSamePtrType(&StringifierPointerType::getInstance())) {
        aUniFFIError.ThrowTypeError("pointer ptr is not of type Stringifier");
        return uniFFIArgs;
    }
    uniFFIArgs.ptr = ptr.getPtr();
    uniFFIArgs.value = value;

    return uniFFIArgs;
}

// Call the scaffolding function
//
// For async calls this should be called in the worker thread
Result Invoke(Args& aArgs) {
    Result result = {};result.mReturnValue =::rondpoint_9336_Stringifier_to_string_u8(
         aArgs.ptr,
         aArgs.value,
         &result.mCallStatus
     );
    return result;
}

// Return the result of the scaffolding call back to JS
void ReturnResult(JSContext* aContext, const Result& aCallResult, RootedDictionary<UniFFIRustCallResult>& aReturnValue) {
    switch (aCallResult.mCallStatus.code) {
        case uniffi::CALL_SUCCESS: {
            // Successful call.  Populate data with the return value
            aReturnValue.mCode = uniffi::CALL_SUCCESS;
            // RustBuffer return, convert it to an ArrayBuffer
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mReturnValue).intoArrayBuffer(aContext));
            break;
        }

        case uniffi::CALL_ERROR:
            // Rust Err() value.  Populate data with the `RustBuffer` containing the error
            aReturnValue.mCode = uniffi::CALL_ERROR;
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mCallStatus.error_buf).intoArrayBuffer(aContext));
            break;

        default:
            // This indicates a RustError, which shouldn't happen in practice since FF sets panic=abort
            aReturnValue.mCode = uniffi::CALL_INTERNAL_ERROR;
            aReturnValue.mInternalErrorMessage.AssignLiteral(u"Unexpected Error");
            break;
    }
}
}
// For each Rust scaffolding function, define types and functions for calling it
namespace rondpoint_9336_stringifier_to_string_i16 {
using namespace mozilla::dom;
// Arguments to pass to the scaffolding function
struct Args {
    void * ptr;
    int16_t value;
};

// Return values from the scaffolding function
struct Result {
    RustBuffer mReturnValue;
    RustCallStatus mCallStatus = {};
};

// Convert the arguments we get from JS to arguments to pass to Rust.
//
// On error, an error code will be stored in result.  Make sure to check this before
// passing the args to Invoke().
//
// For async calls this should be called in the main thread, since the GC can
// move the ArrayBuffer pointers while the background task is waiting.
Args PrepareArgs(const UniFFIPointer& ptr, const int16_t& value,
    mozilla::ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args
    Args uniFFIArgs;
    // We check if the pointer in the argument passed has the same type expected by this
    // function
    if (!ptr.isSamePtrType(&StringifierPointerType::getInstance())) {
        aUniFFIError.ThrowTypeError("pointer ptr is not of type Stringifier");
        return uniFFIArgs;
    }
    uniFFIArgs.ptr = ptr.getPtr();
    uniFFIArgs.value = value;

    return uniFFIArgs;
}

// Call the scaffolding function
//
// For async calls this should be called in the worker thread
Result Invoke(Args& aArgs) {
    Result result = {};result.mReturnValue =::rondpoint_9336_Stringifier_to_string_i16(
         aArgs.ptr,
         aArgs.value,
         &result.mCallStatus
     );
    return result;
}

// Return the result of the scaffolding call back to JS
void ReturnResult(JSContext* aContext, const Result& aCallResult, RootedDictionary<UniFFIRustCallResult>& aReturnValue) {
    switch (aCallResult.mCallStatus.code) {
        case uniffi::CALL_SUCCESS: {
            // Successful call.  Populate data with the return value
            aReturnValue.mCode = uniffi::CALL_SUCCESS;
            // RustBuffer return, convert it to an ArrayBuffer
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mReturnValue).intoArrayBuffer(aContext));
            break;
        }

        case uniffi::CALL_ERROR:
            // Rust Err() value.  Populate data with the `RustBuffer` containing the error
            aReturnValue.mCode = uniffi::CALL_ERROR;
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mCallStatus.error_buf).intoArrayBuffer(aContext));
            break;

        default:
            // This indicates a RustError, which shouldn't happen in practice since FF sets panic=abort
            aReturnValue.mCode = uniffi::CALL_INTERNAL_ERROR;
            aReturnValue.mInternalErrorMessage.AssignLiteral(u"Unexpected Error");
            break;
    }
}
}
// For each Rust scaffolding function, define types and functions for calling it
namespace rondpoint_9336_stringifier_to_string_u16 {
using namespace mozilla::dom;
// Arguments to pass to the scaffolding function
struct Args {
    void * ptr;
    uint16_t value;
};

// Return values from the scaffolding function
struct Result {
    RustBuffer mReturnValue;
    RustCallStatus mCallStatus = {};
};

// Convert the arguments we get from JS to arguments to pass to Rust.
//
// On error, an error code will be stored in result.  Make sure to check this before
// passing the args to Invoke().
//
// For async calls this should be called in the main thread, since the GC can
// move the ArrayBuffer pointers while the background task is waiting.
Args PrepareArgs(const UniFFIPointer& ptr, const uint16_t& value,
    mozilla::ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args
    Args uniFFIArgs;
    // We check if the pointer in the argument passed has the same type expected by this
    // function
    if (!ptr.isSamePtrType(&StringifierPointerType::getInstance())) {
        aUniFFIError.ThrowTypeError("pointer ptr is not of type Stringifier");
        return uniFFIArgs;
    }
    uniFFIArgs.ptr = ptr.getPtr();
    uniFFIArgs.value = value;

    return uniFFIArgs;
}

// Call the scaffolding function
//
// For async calls this should be called in the worker thread
Result Invoke(Args& aArgs) {
    Result result = {};result.mReturnValue =::rondpoint_9336_Stringifier_to_string_u16(
         aArgs.ptr,
         aArgs.value,
         &result.mCallStatus
     );
    return result;
}

// Return the result of the scaffolding call back to JS
void ReturnResult(JSContext* aContext, const Result& aCallResult, RootedDictionary<UniFFIRustCallResult>& aReturnValue) {
    switch (aCallResult.mCallStatus.code) {
        case uniffi::CALL_SUCCESS: {
            // Successful call.  Populate data with the return value
            aReturnValue.mCode = uniffi::CALL_SUCCESS;
            // RustBuffer return, convert it to an ArrayBuffer
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mReturnValue).intoArrayBuffer(aContext));
            break;
        }

        case uniffi::CALL_ERROR:
            // Rust Err() value.  Populate data with the `RustBuffer` containing the error
            aReturnValue.mCode = uniffi::CALL_ERROR;
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mCallStatus.error_buf).intoArrayBuffer(aContext));
            break;

        default:
            // This indicates a RustError, which shouldn't happen in practice since FF sets panic=abort
            aReturnValue.mCode = uniffi::CALL_INTERNAL_ERROR;
            aReturnValue.mInternalErrorMessage.AssignLiteral(u"Unexpected Error");
            break;
    }
}
}
// For each Rust scaffolding function, define types and functions for calling it
namespace rondpoint_9336_stringifier_to_string_i32 {
using namespace mozilla::dom;
// Arguments to pass to the scaffolding function
struct Args {
    void * ptr;
    int32_t value;
};

// Return values from the scaffolding function
struct Result {
    RustBuffer mReturnValue;
    RustCallStatus mCallStatus = {};
};

// Convert the arguments we get from JS to arguments to pass to Rust.
//
// On error, an error code will be stored in result.  Make sure to check this before
// passing the args to Invoke().
//
// For async calls this should be called in the main thread, since the GC can
// move the ArrayBuffer pointers while the background task is waiting.
Args PrepareArgs(const UniFFIPointer& ptr, const int32_t& value,
    mozilla::ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args
    Args uniFFIArgs;
    // We check if the pointer in the argument passed has the same type expected by this
    // function
    if (!ptr.isSamePtrType(&StringifierPointerType::getInstance())) {
        aUniFFIError.ThrowTypeError("pointer ptr is not of type Stringifier");
        return uniFFIArgs;
    }
    uniFFIArgs.ptr = ptr.getPtr();
    uniFFIArgs.value = value;

    return uniFFIArgs;
}

// Call the scaffolding function
//
// For async calls this should be called in the worker thread
Result Invoke(Args& aArgs) {
    Result result = {};result.mReturnValue =::rondpoint_9336_Stringifier_to_string_i32(
         aArgs.ptr,
         aArgs.value,
         &result.mCallStatus
     );
    return result;
}

// Return the result of the scaffolding call back to JS
void ReturnResult(JSContext* aContext, const Result& aCallResult, RootedDictionary<UniFFIRustCallResult>& aReturnValue) {
    switch (aCallResult.mCallStatus.code) {
        case uniffi::CALL_SUCCESS: {
            // Successful call.  Populate data with the return value
            aReturnValue.mCode = uniffi::CALL_SUCCESS;
            // RustBuffer return, convert it to an ArrayBuffer
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mReturnValue).intoArrayBuffer(aContext));
            break;
        }

        case uniffi::CALL_ERROR:
            // Rust Err() value.  Populate data with the `RustBuffer` containing the error
            aReturnValue.mCode = uniffi::CALL_ERROR;
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mCallStatus.error_buf).intoArrayBuffer(aContext));
            break;

        default:
            // This indicates a RustError, which shouldn't happen in practice since FF sets panic=abort
            aReturnValue.mCode = uniffi::CALL_INTERNAL_ERROR;
            aReturnValue.mInternalErrorMessage.AssignLiteral(u"Unexpected Error");
            break;
    }
}
}
// For each Rust scaffolding function, define types and functions for calling it
namespace rondpoint_9336_stringifier_to_string_u32 {
using namespace mozilla::dom;
// Arguments to pass to the scaffolding function
struct Args {
    void * ptr;
    uint32_t value;
};

// Return values from the scaffolding function
struct Result {
    RustBuffer mReturnValue;
    RustCallStatus mCallStatus = {};
};

// Convert the arguments we get from JS to arguments to pass to Rust.
//
// On error, an error code will be stored in result.  Make sure to check this before
// passing the args to Invoke().
//
// For async calls this should be called in the main thread, since the GC can
// move the ArrayBuffer pointers while the background task is waiting.
Args PrepareArgs(const UniFFIPointer& ptr, const uint32_t& value,
    mozilla::ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args
    Args uniFFIArgs;
    // We check if the pointer in the argument passed has the same type expected by this
    // function
    if (!ptr.isSamePtrType(&StringifierPointerType::getInstance())) {
        aUniFFIError.ThrowTypeError("pointer ptr is not of type Stringifier");
        return uniFFIArgs;
    }
    uniFFIArgs.ptr = ptr.getPtr();
    uniFFIArgs.value = value;

    return uniFFIArgs;
}

// Call the scaffolding function
//
// For async calls this should be called in the worker thread
Result Invoke(Args& aArgs) {
    Result result = {};result.mReturnValue =::rondpoint_9336_Stringifier_to_string_u32(
         aArgs.ptr,
         aArgs.value,
         &result.mCallStatus
     );
    return result;
}

// Return the result of the scaffolding call back to JS
void ReturnResult(JSContext* aContext, const Result& aCallResult, RootedDictionary<UniFFIRustCallResult>& aReturnValue) {
    switch (aCallResult.mCallStatus.code) {
        case uniffi::CALL_SUCCESS: {
            // Successful call.  Populate data with the return value
            aReturnValue.mCode = uniffi::CALL_SUCCESS;
            // RustBuffer return, convert it to an ArrayBuffer
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mReturnValue).intoArrayBuffer(aContext));
            break;
        }

        case uniffi::CALL_ERROR:
            // Rust Err() value.  Populate data with the `RustBuffer` containing the error
            aReturnValue.mCode = uniffi::CALL_ERROR;
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mCallStatus.error_buf).intoArrayBuffer(aContext));
            break;

        default:
            // This indicates a RustError, which shouldn't happen in practice since FF sets panic=abort
            aReturnValue.mCode = uniffi::CALL_INTERNAL_ERROR;
            aReturnValue.mInternalErrorMessage.AssignLiteral(u"Unexpected Error");
            break;
    }
}
}
// For each Rust scaffolding function, define types and functions for calling it
namespace rondpoint_9336_stringifier_to_string_i64 {
using namespace mozilla::dom;
// Arguments to pass to the scaffolding function
struct Args {
    void * ptr;
    int64_t value;
};

// Return values from the scaffolding function
struct Result {
    RustBuffer mReturnValue;
    RustCallStatus mCallStatus = {};
};

// Convert the arguments we get from JS to arguments to pass to Rust.
//
// On error, an error code will be stored in result.  Make sure to check this before
// passing the args to Invoke().
//
// For async calls this should be called in the main thread, since the GC can
// move the ArrayBuffer pointers while the background task is waiting.
Args PrepareArgs(const UniFFIPointer& ptr, const int64_t& value,
    mozilla::ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args
    Args uniFFIArgs;
    // We check if the pointer in the argument passed has the same type expected by this
    // function
    if (!ptr.isSamePtrType(&StringifierPointerType::getInstance())) {
        aUniFFIError.ThrowTypeError("pointer ptr is not of type Stringifier");
        return uniFFIArgs;
    }
    uniFFIArgs.ptr = ptr.getPtr();
    uniFFIArgs.value = value;

    return uniFFIArgs;
}

// Call the scaffolding function
//
// For async calls this should be called in the worker thread
Result Invoke(Args& aArgs) {
    Result result = {};result.mReturnValue =::rondpoint_9336_Stringifier_to_string_i64(
         aArgs.ptr,
         aArgs.value,
         &result.mCallStatus
     );
    return result;
}

// Return the result of the scaffolding call back to JS
void ReturnResult(JSContext* aContext, const Result& aCallResult, RootedDictionary<UniFFIRustCallResult>& aReturnValue) {
    switch (aCallResult.mCallStatus.code) {
        case uniffi::CALL_SUCCESS: {
            // Successful call.  Populate data with the return value
            aReturnValue.mCode = uniffi::CALL_SUCCESS;
            // RustBuffer return, convert it to an ArrayBuffer
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mReturnValue).intoArrayBuffer(aContext));
            break;
        }

        case uniffi::CALL_ERROR:
            // Rust Err() value.  Populate data with the `RustBuffer` containing the error
            aReturnValue.mCode = uniffi::CALL_ERROR;
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mCallStatus.error_buf).intoArrayBuffer(aContext));
            break;

        default:
            // This indicates a RustError, which shouldn't happen in practice since FF sets panic=abort
            aReturnValue.mCode = uniffi::CALL_INTERNAL_ERROR;
            aReturnValue.mInternalErrorMessage.AssignLiteral(u"Unexpected Error");
            break;
    }
}
}
// For each Rust scaffolding function, define types and functions for calling it
namespace rondpoint_9336_stringifier_to_string_u64 {
using namespace mozilla::dom;
// Arguments to pass to the scaffolding function
struct Args {
    void * ptr;
    uint64_t value;
};

// Return values from the scaffolding function
struct Result {
    RustBuffer mReturnValue;
    RustCallStatus mCallStatus = {};
};

// Convert the arguments we get from JS to arguments to pass to Rust.
//
// On error, an error code will be stored in result.  Make sure to check this before
// passing the args to Invoke().
//
// For async calls this should be called in the main thread, since the GC can
// move the ArrayBuffer pointers while the background task is waiting.
Args PrepareArgs(const UniFFIPointer& ptr, const uint64_t& value,
    mozilla::ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args
    Args uniFFIArgs;
    // We check if the pointer in the argument passed has the same type expected by this
    // function
    if (!ptr.isSamePtrType(&StringifierPointerType::getInstance())) {
        aUniFFIError.ThrowTypeError("pointer ptr is not of type Stringifier");
        return uniFFIArgs;
    }
    uniFFIArgs.ptr = ptr.getPtr();
    uniFFIArgs.value = value;

    return uniFFIArgs;
}

// Call the scaffolding function
//
// For async calls this should be called in the worker thread
Result Invoke(Args& aArgs) {
    Result result = {};result.mReturnValue =::rondpoint_9336_Stringifier_to_string_u64(
         aArgs.ptr,
         aArgs.value,
         &result.mCallStatus
     );
    return result;
}

// Return the result of the scaffolding call back to JS
void ReturnResult(JSContext* aContext, const Result& aCallResult, RootedDictionary<UniFFIRustCallResult>& aReturnValue) {
    switch (aCallResult.mCallStatus.code) {
        case uniffi::CALL_SUCCESS: {
            // Successful call.  Populate data with the return value
            aReturnValue.mCode = uniffi::CALL_SUCCESS;
            // RustBuffer return, convert it to an ArrayBuffer
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mReturnValue).intoArrayBuffer(aContext));
            break;
        }

        case uniffi::CALL_ERROR:
            // Rust Err() value.  Populate data with the `RustBuffer` containing the error
            aReturnValue.mCode = uniffi::CALL_ERROR;
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mCallStatus.error_buf).intoArrayBuffer(aContext));
            break;

        default:
            // This indicates a RustError, which shouldn't happen in practice since FF sets panic=abort
            aReturnValue.mCode = uniffi::CALL_INTERNAL_ERROR;
            aReturnValue.mInternalErrorMessage.AssignLiteral(u"Unexpected Error");
            break;
    }
}
}
// For each Rust scaffolding function, define types and functions for calling it
namespace rondpoint_9336_stringifier_to_string_float {
using namespace mozilla::dom;
// Arguments to pass to the scaffolding function
struct Args {
    void * ptr;
    float value;
};

// Return values from the scaffolding function
struct Result {
    RustBuffer mReturnValue;
    RustCallStatus mCallStatus = {};
};

// Convert the arguments we get from JS to arguments to pass to Rust.
//
// On error, an error code will be stored in result.  Make sure to check this before
// passing the args to Invoke().
//
// For async calls this should be called in the main thread, since the GC can
// move the ArrayBuffer pointers while the background task is waiting.
Args PrepareArgs(const UniFFIPointer& ptr, const float& value,
    mozilla::ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args
    Args uniFFIArgs;
    // We check if the pointer in the argument passed has the same type expected by this
    // function
    if (!ptr.isSamePtrType(&StringifierPointerType::getInstance())) {
        aUniFFIError.ThrowTypeError("pointer ptr is not of type Stringifier");
        return uniFFIArgs;
    }
    uniFFIArgs.ptr = ptr.getPtr();
    uniFFIArgs.value = value;

    return uniFFIArgs;
}

// Call the scaffolding function
//
// For async calls this should be called in the worker thread
Result Invoke(Args& aArgs) {
    Result result = {};result.mReturnValue =::rondpoint_9336_Stringifier_to_string_float(
         aArgs.ptr,
         aArgs.value,
         &result.mCallStatus
     );
    return result;
}

// Return the result of the scaffolding call back to JS
void ReturnResult(JSContext* aContext, const Result& aCallResult, RootedDictionary<UniFFIRustCallResult>& aReturnValue) {
    switch (aCallResult.mCallStatus.code) {
        case uniffi::CALL_SUCCESS: {
            // Successful call.  Populate data with the return value
            aReturnValue.mCode = uniffi::CALL_SUCCESS;
            // RustBuffer return, convert it to an ArrayBuffer
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mReturnValue).intoArrayBuffer(aContext));
            break;
        }

        case uniffi::CALL_ERROR:
            // Rust Err() value.  Populate data with the `RustBuffer` containing the error
            aReturnValue.mCode = uniffi::CALL_ERROR;
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mCallStatus.error_buf).intoArrayBuffer(aContext));
            break;

        default:
            // This indicates a RustError, which shouldn't happen in practice since FF sets panic=abort
            aReturnValue.mCode = uniffi::CALL_INTERNAL_ERROR;
            aReturnValue.mInternalErrorMessage.AssignLiteral(u"Unexpected Error");
            break;
    }
}
}
// For each Rust scaffolding function, define types and functions for calling it
namespace rondpoint_9336_stringifier_to_string_double {
using namespace mozilla::dom;
// Arguments to pass to the scaffolding function
struct Args {
    void * ptr;
    double value;
};

// Return values from the scaffolding function
struct Result {
    RustBuffer mReturnValue;
    RustCallStatus mCallStatus = {};
};

// Convert the arguments we get from JS to arguments to pass to Rust.
//
// On error, an error code will be stored in result.  Make sure to check this before
// passing the args to Invoke().
//
// For async calls this should be called in the main thread, since the GC can
// move the ArrayBuffer pointers while the background task is waiting.
Args PrepareArgs(const UniFFIPointer& ptr, const double& value,
    mozilla::ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args
    Args uniFFIArgs;
    // We check if the pointer in the argument passed has the same type expected by this
    // function
    if (!ptr.isSamePtrType(&StringifierPointerType::getInstance())) {
        aUniFFIError.ThrowTypeError("pointer ptr is not of type Stringifier");
        return uniFFIArgs;
    }
    uniFFIArgs.ptr = ptr.getPtr();
    uniFFIArgs.value = value;

    return uniFFIArgs;
}

// Call the scaffolding function
//
// For async calls this should be called in the worker thread
Result Invoke(Args& aArgs) {
    Result result = {};result.mReturnValue =::rondpoint_9336_Stringifier_to_string_double(
         aArgs.ptr,
         aArgs.value,
         &result.mCallStatus
     );
    return result;
}

// Return the result of the scaffolding call back to JS
void ReturnResult(JSContext* aContext, const Result& aCallResult, RootedDictionary<UniFFIRustCallResult>& aReturnValue) {
    switch (aCallResult.mCallStatus.code) {
        case uniffi::CALL_SUCCESS: {
            // Successful call.  Populate data with the return value
            aReturnValue.mCode = uniffi::CALL_SUCCESS;
            // RustBuffer return, convert it to an ArrayBuffer
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mReturnValue).intoArrayBuffer(aContext));
            break;
        }

        case uniffi::CALL_ERROR:
            // Rust Err() value.  Populate data with the `RustBuffer` containing the error
            aReturnValue.mCode = uniffi::CALL_ERROR;
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mCallStatus.error_buf).intoArrayBuffer(aContext));
            break;

        default:
            // This indicates a RustError, which shouldn't happen in practice since FF sets panic=abort
            aReturnValue.mCode = uniffi::CALL_INTERNAL_ERROR;
            aReturnValue.mInternalErrorMessage.AssignLiteral(u"Unexpected Error");
            break;
    }
}
}
// For each Rust scaffolding function, define types and functions for calling it
namespace rondpoint_9336_stringifier_to_string_boolean {
using namespace mozilla::dom;
// Arguments to pass to the scaffolding function
struct Args {
    void * ptr;
    int8_t value;
};

// Return values from the scaffolding function
struct Result {
    RustBuffer mReturnValue;
    RustCallStatus mCallStatus = {};
};

// Convert the arguments we get from JS to arguments to pass to Rust.
//
// On error, an error code will be stored in result.  Make sure to check this before
// passing the args to Invoke().
//
// For async calls this should be called in the main thread, since the GC can
// move the ArrayBuffer pointers while the background task is waiting.
Args PrepareArgs(const UniFFIPointer& ptr, const int8_t& value,
    mozilla::ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args
    Args uniFFIArgs;
    // We check if the pointer in the argument passed has the same type expected by this
    // function
    if (!ptr.isSamePtrType(&StringifierPointerType::getInstance())) {
        aUniFFIError.ThrowTypeError("pointer ptr is not of type Stringifier");
        return uniFFIArgs;
    }
    uniFFIArgs.ptr = ptr.getPtr();
    uniFFIArgs.value = value;

    return uniFFIArgs;
}

// Call the scaffolding function
//
// For async calls this should be called in the worker thread
Result Invoke(Args& aArgs) {
    Result result = {};result.mReturnValue =::rondpoint_9336_Stringifier_to_string_boolean(
         aArgs.ptr,
         aArgs.value,
         &result.mCallStatus
     );
    return result;
}

// Return the result of the scaffolding call back to JS
void ReturnResult(JSContext* aContext, const Result& aCallResult, RootedDictionary<UniFFIRustCallResult>& aReturnValue) {
    switch (aCallResult.mCallStatus.code) {
        case uniffi::CALL_SUCCESS: {
            // Successful call.  Populate data with the return value
            aReturnValue.mCode = uniffi::CALL_SUCCESS;
            // RustBuffer return, convert it to an ArrayBuffer
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mReturnValue).intoArrayBuffer(aContext));
            break;
        }

        case uniffi::CALL_ERROR:
            // Rust Err() value.  Populate data with the `RustBuffer` containing the error
            aReturnValue.mCode = uniffi::CALL_ERROR;
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mCallStatus.error_buf).intoArrayBuffer(aContext));
            break;

        default:
            // This indicates a RustError, which shouldn't happen in practice since FF sets panic=abort
            aReturnValue.mCode = uniffi::CALL_INTERNAL_ERROR;
            aReturnValue.mInternalErrorMessage.AssignLiteral(u"Unexpected Error");
            break;
    }
}
}
// For each Rust scaffolding function, define types and functions for calling it
namespace ffi_rondpoint_9336_optionneur_object_free {
using namespace mozilla::dom;
// Arguments to pass to the scaffolding function
struct Args {
    void * ptr;
};

// Return values from the scaffolding function
struct Result {
    RustCallStatus mCallStatus = {};
};

// Convert the arguments we get from JS to arguments to pass to Rust.
//
// On error, an error code will be stored in result.  Make sure to check this before
// passing the args to Invoke().
//
// For async calls this should be called in the main thread, since the GC can
// move the ArrayBuffer pointers while the background task is waiting.
Args PrepareArgs(const UniFFIPointer& ptr,
    mozilla::ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args
    Args uniFFIArgs;
    // We check if the pointer in the argument passed has the same type expected by this
    // function
    if (!ptr.isSamePtrType(&OptionneurPointerType::getInstance())) {
        aUniFFIError.ThrowTypeError("pointer ptr is not of type Optionneur");
        return uniFFIArgs;
    }
    uniFFIArgs.ptr = ptr.getPtr();

    return uniFFIArgs;
}

// Call the scaffolding function
//
// For async calls this should be called in the worker thread
Result Invoke(Args& aArgs) {
    Result result = {};::ffi_rondpoint_9336_Optionneur_object_free(
         aArgs.ptr,
         &result.mCallStatus
     );
    return result;
}

// Return the result of the scaffolding call back to JS
void ReturnResult(JSContext* aContext, const Result& aCallResult, RootedDictionary<UniFFIRustCallResult>& aReturnValue) {
    switch (aCallResult.mCallStatus.code) {
        case uniffi::CALL_SUCCESS: {
            // Successful call.  Populate data with the return value
            aReturnValue.mCode = uniffi::CALL_SUCCESS;
            // Void return
            break;
        }

        case uniffi::CALL_ERROR:
            // Rust Err() value.  Populate data with the `RustBuffer` containing the error
            aReturnValue.mCode = uniffi::CALL_ERROR;
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mCallStatus.error_buf).intoArrayBuffer(aContext));
            break;

        default:
            // This indicates a RustError, which shouldn't happen in practice since FF sets panic=abort
            aReturnValue.mCode = uniffi::CALL_INTERNAL_ERROR;
            aReturnValue.mInternalErrorMessage.AssignLiteral(u"Unexpected Error");
            break;
    }
}
}
// For each Rust scaffolding function, define types and functions for calling it
namespace rondpoint_9336_optionneur_new {
using namespace mozilla::dom;
// Arguments to pass to the scaffolding function
struct Args {
};

// Return values from the scaffolding function
struct Result {
    void * mReturnValue;
    RustCallStatus mCallStatus = {};
};

// Convert the arguments we get from JS to arguments to pass to Rust.
//
// On error, an error code will be stored in result.  Make sure to check this before
// passing the args to Invoke().
//
// For async calls this should be called in the main thread, since the GC can
// move the ArrayBuffer pointers while the background task is waiting.
Args PrepareArgs(
    mozilla::ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args
    Args uniFFIArgs;

    return uniFFIArgs;
}

// Call the scaffolding function
//
// For async calls this should be called in the worker thread
Result Invoke(Args& aArgs) {
    Result result = {};result.mReturnValue =::rondpoint_9336_Optionneur_new(
         &result.mCallStatus
     );
    return result;
}

// Return the result of the scaffolding call back to JS
void ReturnResult(JSContext* aContext, const Result& aCallResult, RootedDictionary<UniFFIRustCallResult>& aReturnValue) {
    switch (aCallResult.mCallStatus.code) {
        case uniffi::CALL_SUCCESS: {
            // Successful call.  Populate data with the return value
            aReturnValue.mCode = uniffi::CALL_SUCCESS;
            RefPtr<UniFFIPointer> uniFFIPtr = UniFFIPointer::Create(aCallResult.mReturnValue, &OptionneurPointerType::getInstance() );
            aReturnValue.mData.setObjectOrNull(uniFFIPtr->WrapObject(aContext, nullptr));
            break;
        }

        case uniffi::CALL_ERROR:
            // Rust Err() value.  Populate data with the `RustBuffer` containing the error
            aReturnValue.mCode = uniffi::CALL_ERROR;
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mCallStatus.error_buf).intoArrayBuffer(aContext));
            break;

        default:
            // This indicates a RustError, which shouldn't happen in practice since FF sets panic=abort
            aReturnValue.mCode = uniffi::CALL_INTERNAL_ERROR;
            aReturnValue.mInternalErrorMessage.AssignLiteral(u"Unexpected Error");
            break;
    }
}
}
// For each Rust scaffolding function, define types and functions for calling it
namespace rondpoint_9336_optionneur_sinon_boolean {
using namespace mozilla::dom;
// Arguments to pass to the scaffolding function
struct Args {
    void * ptr;
    int8_t value;
};

// Return values from the scaffolding function
struct Result {
    int8_t mReturnValue;
    RustCallStatus mCallStatus = {};
};

// Convert the arguments we get from JS to arguments to pass to Rust.
//
// On error, an error code will be stored in result.  Make sure to check this before
// passing the args to Invoke().
//
// For async calls this should be called in the main thread, since the GC can
// move the ArrayBuffer pointers while the background task is waiting.
Args PrepareArgs(const UniFFIPointer& ptr, const int8_t& value,
    mozilla::ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args
    Args uniFFIArgs;
    // We check if the pointer in the argument passed has the same type expected by this
    // function
    if (!ptr.isSamePtrType(&OptionneurPointerType::getInstance())) {
        aUniFFIError.ThrowTypeError("pointer ptr is not of type Optionneur");
        return uniFFIArgs;
    }
    uniFFIArgs.ptr = ptr.getPtr();
    uniFFIArgs.value = value;

    return uniFFIArgs;
}

// Call the scaffolding function
//
// For async calls this should be called in the worker thread
Result Invoke(Args& aArgs) {
    Result result = {};result.mReturnValue =::rondpoint_9336_Optionneur_sinon_boolean(
         aArgs.ptr,
         aArgs.value,
         &result.mCallStatus
     );
    return result;
}

// Return the result of the scaffolding call back to JS
void ReturnResult(JSContext* aContext, const Result& aCallResult, RootedDictionary<UniFFIRustCallResult>& aReturnValue) {
    switch (aCallResult.mCallStatus.code) {
        case uniffi::CALL_SUCCESS: {
            // Successful call.  Populate data with the return value
            aReturnValue.mCode = uniffi::CALL_SUCCESS;
            // Numeric Return
            aReturnValue.mData.setNumber(aCallResult.mReturnValue);
            break;
        }

        case uniffi::CALL_ERROR:
            // Rust Err() value.  Populate data with the `RustBuffer` containing the error
            aReturnValue.mCode = uniffi::CALL_ERROR;
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mCallStatus.error_buf).intoArrayBuffer(aContext));
            break;

        default:
            // This indicates a RustError, which shouldn't happen in practice since FF sets panic=abort
            aReturnValue.mCode = uniffi::CALL_INTERNAL_ERROR;
            aReturnValue.mInternalErrorMessage.AssignLiteral(u"Unexpected Error");
            break;
    }
}
}
// For each Rust scaffolding function, define types and functions for calling it
namespace rondpoint_9336_optionneur_sinon_string {
using namespace mozilla::dom;
// Arguments to pass to the scaffolding function
struct Args {
    void * ptr;
    // RustBuffer arguments are stored as OwnedRustBuffer instances.  That class takes care of
    // freeing the buffer if the arguments don't get passed to Rust (i.e. intoRustBuffer()
    // isn't called).  This can happen if some of the ArrayBuffer arguments are succuessfully
    // converted, but one fails to convert.
    mozilla::dom::OwnedRustBuffer value;
};

// Return values from the scaffolding function
struct Result {
    RustBuffer mReturnValue;
    RustCallStatus mCallStatus = {};
};

// Convert the arguments we get from JS to arguments to pass to Rust.
//
// On error, an error code will be stored in result.  Make sure to check this before
// passing the args to Invoke().
//
// For async calls this should be called in the main thread, since the GC can
// move the ArrayBuffer pointers while the background task is waiting.
Args PrepareArgs(const UniFFIPointer& ptr, const ArrayBuffer& value,
    mozilla::ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args
    Args uniFFIArgs;
    // We check if the pointer in the argument passed has the same type expected by this
    // function
    if (!ptr.isSamePtrType(&OptionneurPointerType::getInstance())) {
        aUniFFIError.ThrowTypeError("pointer ptr is not of type Optionneur");
        return uniFFIArgs;
    }
    uniFFIArgs.ptr = ptr.getPtr();
    // Convert the ArrayBuffer we get from JS to an OwnedRustBuffer
    value.ComputeState();
    uniFFIArgs.value = OwnedRustBuffer(value, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return uniFFIArgs;
    }

    return uniFFIArgs;
}

// Call the scaffolding function
//
// For async calls this should be called in the worker thread
Result Invoke(Args& aArgs) {
    Result result = {};result.mReturnValue =::rondpoint_9336_Optionneur_sinon_string(
         aArgs.ptr,
         // Call intoRustBuffer() to get a `RustBuffer` from an OwnedRustBuffer.  This transfers ownership to Rust,
         // OwnedRustBuffer will no longer try to free it
         aArgs.value.intoRustBuffer(),
         &result.mCallStatus
     );
    return result;
}

// Return the result of the scaffolding call back to JS
void ReturnResult(JSContext* aContext, const Result& aCallResult, RootedDictionary<UniFFIRustCallResult>& aReturnValue) {
    switch (aCallResult.mCallStatus.code) {
        case uniffi::CALL_SUCCESS: {
            // Successful call.  Populate data with the return value
            aReturnValue.mCode = uniffi::CALL_SUCCESS;
            // RustBuffer return, convert it to an ArrayBuffer
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mReturnValue).intoArrayBuffer(aContext));
            break;
        }

        case uniffi::CALL_ERROR:
            // Rust Err() value.  Populate data with the `RustBuffer` containing the error
            aReturnValue.mCode = uniffi::CALL_ERROR;
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mCallStatus.error_buf).intoArrayBuffer(aContext));
            break;

        default:
            // This indicates a RustError, which shouldn't happen in practice since FF sets panic=abort
            aReturnValue.mCode = uniffi::CALL_INTERNAL_ERROR;
            aReturnValue.mInternalErrorMessage.AssignLiteral(u"Unexpected Error");
            break;
    }
}
}
// For each Rust scaffolding function, define types and functions for calling it
namespace rondpoint_9336_optionneur_sinon_sequence {
using namespace mozilla::dom;
// Arguments to pass to the scaffolding function
struct Args {
    void * ptr;
    // RustBuffer arguments are stored as OwnedRustBuffer instances.  That class takes care of
    // freeing the buffer if the arguments don't get passed to Rust (i.e. intoRustBuffer()
    // isn't called).  This can happen if some of the ArrayBuffer arguments are succuessfully
    // converted, but one fails to convert.
    mozilla::dom::OwnedRustBuffer value;
};

// Return values from the scaffolding function
struct Result {
    RustBuffer mReturnValue;
    RustCallStatus mCallStatus = {};
};

// Convert the arguments we get from JS to arguments to pass to Rust.
//
// On error, an error code will be stored in result.  Make sure to check this before
// passing the args to Invoke().
//
// For async calls this should be called in the main thread, since the GC can
// move the ArrayBuffer pointers while the background task is waiting.
Args PrepareArgs(const UniFFIPointer& ptr, const ArrayBuffer& value,
    mozilla::ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args
    Args uniFFIArgs;
    // We check if the pointer in the argument passed has the same type expected by this
    // function
    if (!ptr.isSamePtrType(&OptionneurPointerType::getInstance())) {
        aUniFFIError.ThrowTypeError("pointer ptr is not of type Optionneur");
        return uniFFIArgs;
    }
    uniFFIArgs.ptr = ptr.getPtr();
    // Convert the ArrayBuffer we get from JS to an OwnedRustBuffer
    value.ComputeState();
    uniFFIArgs.value = OwnedRustBuffer(value, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return uniFFIArgs;
    }

    return uniFFIArgs;
}

// Call the scaffolding function
//
// For async calls this should be called in the worker thread
Result Invoke(Args& aArgs) {
    Result result = {};result.mReturnValue =::rondpoint_9336_Optionneur_sinon_sequence(
         aArgs.ptr,
         // Call intoRustBuffer() to get a `RustBuffer` from an OwnedRustBuffer.  This transfers ownership to Rust,
         // OwnedRustBuffer will no longer try to free it
         aArgs.value.intoRustBuffer(),
         &result.mCallStatus
     );
    return result;
}

// Return the result of the scaffolding call back to JS
void ReturnResult(JSContext* aContext, const Result& aCallResult, RootedDictionary<UniFFIRustCallResult>& aReturnValue) {
    switch (aCallResult.mCallStatus.code) {
        case uniffi::CALL_SUCCESS: {
            // Successful call.  Populate data with the return value
            aReturnValue.mCode = uniffi::CALL_SUCCESS;
            // RustBuffer return, convert it to an ArrayBuffer
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mReturnValue).intoArrayBuffer(aContext));
            break;
        }

        case uniffi::CALL_ERROR:
            // Rust Err() value.  Populate data with the `RustBuffer` containing the error
            aReturnValue.mCode = uniffi::CALL_ERROR;
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mCallStatus.error_buf).intoArrayBuffer(aContext));
            break;

        default:
            // This indicates a RustError, which shouldn't happen in practice since FF sets panic=abort
            aReturnValue.mCode = uniffi::CALL_INTERNAL_ERROR;
            aReturnValue.mInternalErrorMessage.AssignLiteral(u"Unexpected Error");
            break;
    }
}
}
// For each Rust scaffolding function, define types and functions for calling it
namespace rondpoint_9336_optionneur_sinon_null {
using namespace mozilla::dom;
// Arguments to pass to the scaffolding function
struct Args {
    void * ptr;
    // RustBuffer arguments are stored as OwnedRustBuffer instances.  That class takes care of
    // freeing the buffer if the arguments don't get passed to Rust (i.e. intoRustBuffer()
    // isn't called).  This can happen if some of the ArrayBuffer arguments are succuessfully
    // converted, but one fails to convert.
    mozilla::dom::OwnedRustBuffer value;
};

// Return values from the scaffolding function
struct Result {
    RustBuffer mReturnValue;
    RustCallStatus mCallStatus = {};
};

// Convert the arguments we get from JS to arguments to pass to Rust.
//
// On error, an error code will be stored in result.  Make sure to check this before
// passing the args to Invoke().
//
// For async calls this should be called in the main thread, since the GC can
// move the ArrayBuffer pointers while the background task is waiting.
Args PrepareArgs(const UniFFIPointer& ptr, const ArrayBuffer& value,
    mozilla::ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args
    Args uniFFIArgs;
    // We check if the pointer in the argument passed has the same type expected by this
    // function
    if (!ptr.isSamePtrType(&OptionneurPointerType::getInstance())) {
        aUniFFIError.ThrowTypeError("pointer ptr is not of type Optionneur");
        return uniFFIArgs;
    }
    uniFFIArgs.ptr = ptr.getPtr();
    // Convert the ArrayBuffer we get from JS to an OwnedRustBuffer
    value.ComputeState();
    uniFFIArgs.value = OwnedRustBuffer(value, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return uniFFIArgs;
    }

    return uniFFIArgs;
}

// Call the scaffolding function
//
// For async calls this should be called in the worker thread
Result Invoke(Args& aArgs) {
    Result result = {};result.mReturnValue =::rondpoint_9336_Optionneur_sinon_null(
         aArgs.ptr,
         // Call intoRustBuffer() to get a `RustBuffer` from an OwnedRustBuffer.  This transfers ownership to Rust,
         // OwnedRustBuffer will no longer try to free it
         aArgs.value.intoRustBuffer(),
         &result.mCallStatus
     );
    return result;
}

// Return the result of the scaffolding call back to JS
void ReturnResult(JSContext* aContext, const Result& aCallResult, RootedDictionary<UniFFIRustCallResult>& aReturnValue) {
    switch (aCallResult.mCallStatus.code) {
        case uniffi::CALL_SUCCESS: {
            // Successful call.  Populate data with the return value
            aReturnValue.mCode = uniffi::CALL_SUCCESS;
            // RustBuffer return, convert it to an ArrayBuffer
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mReturnValue).intoArrayBuffer(aContext));
            break;
        }

        case uniffi::CALL_ERROR:
            // Rust Err() value.  Populate data with the `RustBuffer` containing the error
            aReturnValue.mCode = uniffi::CALL_ERROR;
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mCallStatus.error_buf).intoArrayBuffer(aContext));
            break;

        default:
            // This indicates a RustError, which shouldn't happen in practice since FF sets panic=abort
            aReturnValue.mCode = uniffi::CALL_INTERNAL_ERROR;
            aReturnValue.mInternalErrorMessage.AssignLiteral(u"Unexpected Error");
            break;
    }
}
}
// For each Rust scaffolding function, define types and functions for calling it
namespace rondpoint_9336_optionneur_sinon_zero {
using namespace mozilla::dom;
// Arguments to pass to the scaffolding function
struct Args {
    void * ptr;
    // RustBuffer arguments are stored as OwnedRustBuffer instances.  That class takes care of
    // freeing the buffer if the arguments don't get passed to Rust (i.e. intoRustBuffer()
    // isn't called).  This can happen if some of the ArrayBuffer arguments are succuessfully
    // converted, but one fails to convert.
    mozilla::dom::OwnedRustBuffer value;
};

// Return values from the scaffolding function
struct Result {
    RustBuffer mReturnValue;
    RustCallStatus mCallStatus = {};
};

// Convert the arguments we get from JS to arguments to pass to Rust.
//
// On error, an error code will be stored in result.  Make sure to check this before
// passing the args to Invoke().
//
// For async calls this should be called in the main thread, since the GC can
// move the ArrayBuffer pointers while the background task is waiting.
Args PrepareArgs(const UniFFIPointer& ptr, const ArrayBuffer& value,
    mozilla::ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args
    Args uniFFIArgs;
    // We check if the pointer in the argument passed has the same type expected by this
    // function
    if (!ptr.isSamePtrType(&OptionneurPointerType::getInstance())) {
        aUniFFIError.ThrowTypeError("pointer ptr is not of type Optionneur");
        return uniFFIArgs;
    }
    uniFFIArgs.ptr = ptr.getPtr();
    // Convert the ArrayBuffer we get from JS to an OwnedRustBuffer
    value.ComputeState();
    uniFFIArgs.value = OwnedRustBuffer(value, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return uniFFIArgs;
    }

    return uniFFIArgs;
}

// Call the scaffolding function
//
// For async calls this should be called in the worker thread
Result Invoke(Args& aArgs) {
    Result result = {};result.mReturnValue =::rondpoint_9336_Optionneur_sinon_zero(
         aArgs.ptr,
         // Call intoRustBuffer() to get a `RustBuffer` from an OwnedRustBuffer.  This transfers ownership to Rust,
         // OwnedRustBuffer will no longer try to free it
         aArgs.value.intoRustBuffer(),
         &result.mCallStatus
     );
    return result;
}

// Return the result of the scaffolding call back to JS
void ReturnResult(JSContext* aContext, const Result& aCallResult, RootedDictionary<UniFFIRustCallResult>& aReturnValue) {
    switch (aCallResult.mCallStatus.code) {
        case uniffi::CALL_SUCCESS: {
            // Successful call.  Populate data with the return value
            aReturnValue.mCode = uniffi::CALL_SUCCESS;
            // RustBuffer return, convert it to an ArrayBuffer
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mReturnValue).intoArrayBuffer(aContext));
            break;
        }

        case uniffi::CALL_ERROR:
            // Rust Err() value.  Populate data with the `RustBuffer` containing the error
            aReturnValue.mCode = uniffi::CALL_ERROR;
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mCallStatus.error_buf).intoArrayBuffer(aContext));
            break;

        default:
            // This indicates a RustError, which shouldn't happen in practice since FF sets panic=abort
            aReturnValue.mCode = uniffi::CALL_INTERNAL_ERROR;
            aReturnValue.mInternalErrorMessage.AssignLiteral(u"Unexpected Error");
            break;
    }
}
}
// For each Rust scaffolding function, define types and functions for calling it
namespace rondpoint_9336_optionneur_sinon_u8_dec {
using namespace mozilla::dom;
// Arguments to pass to the scaffolding function
struct Args {
    void * ptr;
    uint8_t value;
};

// Return values from the scaffolding function
struct Result {
    uint8_t mReturnValue;
    RustCallStatus mCallStatus = {};
};

// Convert the arguments we get from JS to arguments to pass to Rust.
//
// On error, an error code will be stored in result.  Make sure to check this before
// passing the args to Invoke().
//
// For async calls this should be called in the main thread, since the GC can
// move the ArrayBuffer pointers while the background task is waiting.
Args PrepareArgs(const UniFFIPointer& ptr, const uint8_t& value,
    mozilla::ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args
    Args uniFFIArgs;
    // We check if the pointer in the argument passed has the same type expected by this
    // function
    if (!ptr.isSamePtrType(&OptionneurPointerType::getInstance())) {
        aUniFFIError.ThrowTypeError("pointer ptr is not of type Optionneur");
        return uniFFIArgs;
    }
    uniFFIArgs.ptr = ptr.getPtr();
    uniFFIArgs.value = value;

    return uniFFIArgs;
}

// Call the scaffolding function
//
// For async calls this should be called in the worker thread
Result Invoke(Args& aArgs) {
    Result result = {};result.mReturnValue =::rondpoint_9336_Optionneur_sinon_u8_dec(
         aArgs.ptr,
         aArgs.value,
         &result.mCallStatus
     );
    return result;
}

// Return the result of the scaffolding call back to JS
void ReturnResult(JSContext* aContext, const Result& aCallResult, RootedDictionary<UniFFIRustCallResult>& aReturnValue) {
    switch (aCallResult.mCallStatus.code) {
        case uniffi::CALL_SUCCESS: {
            // Successful call.  Populate data with the return value
            aReturnValue.mCode = uniffi::CALL_SUCCESS;
            // Numeric Return
            aReturnValue.mData.setNumber(aCallResult.mReturnValue);
            break;
        }

        case uniffi::CALL_ERROR:
            // Rust Err() value.  Populate data with the `RustBuffer` containing the error
            aReturnValue.mCode = uniffi::CALL_ERROR;
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mCallStatus.error_buf).intoArrayBuffer(aContext));
            break;

        default:
            // This indicates a RustError, which shouldn't happen in practice since FF sets panic=abort
            aReturnValue.mCode = uniffi::CALL_INTERNAL_ERROR;
            aReturnValue.mInternalErrorMessage.AssignLiteral(u"Unexpected Error");
            break;
    }
}
}
// For each Rust scaffolding function, define types and functions for calling it
namespace rondpoint_9336_optionneur_sinon_i8_dec {
using namespace mozilla::dom;
// Arguments to pass to the scaffolding function
struct Args {
    void * ptr;
    int8_t value;
};

// Return values from the scaffolding function
struct Result {
    int8_t mReturnValue;
    RustCallStatus mCallStatus = {};
};

// Convert the arguments we get from JS to arguments to pass to Rust.
//
// On error, an error code will be stored in result.  Make sure to check this before
// passing the args to Invoke().
//
// For async calls this should be called in the main thread, since the GC can
// move the ArrayBuffer pointers while the background task is waiting.
Args PrepareArgs(const UniFFIPointer& ptr, const int8_t& value,
    mozilla::ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args
    Args uniFFIArgs;
    // We check if the pointer in the argument passed has the same type expected by this
    // function
    if (!ptr.isSamePtrType(&OptionneurPointerType::getInstance())) {
        aUniFFIError.ThrowTypeError("pointer ptr is not of type Optionneur");
        return uniFFIArgs;
    }
    uniFFIArgs.ptr = ptr.getPtr();
    uniFFIArgs.value = value;

    return uniFFIArgs;
}

// Call the scaffolding function
//
// For async calls this should be called in the worker thread
Result Invoke(Args& aArgs) {
    Result result = {};result.mReturnValue =::rondpoint_9336_Optionneur_sinon_i8_dec(
         aArgs.ptr,
         aArgs.value,
         &result.mCallStatus
     );
    return result;
}

// Return the result of the scaffolding call back to JS
void ReturnResult(JSContext* aContext, const Result& aCallResult, RootedDictionary<UniFFIRustCallResult>& aReturnValue) {
    switch (aCallResult.mCallStatus.code) {
        case uniffi::CALL_SUCCESS: {
            // Successful call.  Populate data with the return value
            aReturnValue.mCode = uniffi::CALL_SUCCESS;
            // Numeric Return
            aReturnValue.mData.setNumber(aCallResult.mReturnValue);
            break;
        }

        case uniffi::CALL_ERROR:
            // Rust Err() value.  Populate data with the `RustBuffer` containing the error
            aReturnValue.mCode = uniffi::CALL_ERROR;
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mCallStatus.error_buf).intoArrayBuffer(aContext));
            break;

        default:
            // This indicates a RustError, which shouldn't happen in practice since FF sets panic=abort
            aReturnValue.mCode = uniffi::CALL_INTERNAL_ERROR;
            aReturnValue.mInternalErrorMessage.AssignLiteral(u"Unexpected Error");
            break;
    }
}
}
// For each Rust scaffolding function, define types and functions for calling it
namespace rondpoint_9336_optionneur_sinon_u16_dec {
using namespace mozilla::dom;
// Arguments to pass to the scaffolding function
struct Args {
    void * ptr;
    uint16_t value;
};

// Return values from the scaffolding function
struct Result {
    uint16_t mReturnValue;
    RustCallStatus mCallStatus = {};
};

// Convert the arguments we get from JS to arguments to pass to Rust.
//
// On error, an error code will be stored in result.  Make sure to check this before
// passing the args to Invoke().
//
// For async calls this should be called in the main thread, since the GC can
// move the ArrayBuffer pointers while the background task is waiting.
Args PrepareArgs(const UniFFIPointer& ptr, const uint16_t& value,
    mozilla::ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args
    Args uniFFIArgs;
    // We check if the pointer in the argument passed has the same type expected by this
    // function
    if (!ptr.isSamePtrType(&OptionneurPointerType::getInstance())) {
        aUniFFIError.ThrowTypeError("pointer ptr is not of type Optionneur");
        return uniFFIArgs;
    }
    uniFFIArgs.ptr = ptr.getPtr();
    uniFFIArgs.value = value;

    return uniFFIArgs;
}

// Call the scaffolding function
//
// For async calls this should be called in the worker thread
Result Invoke(Args& aArgs) {
    Result result = {};result.mReturnValue =::rondpoint_9336_Optionneur_sinon_u16_dec(
         aArgs.ptr,
         aArgs.value,
         &result.mCallStatus
     );
    return result;
}

// Return the result of the scaffolding call back to JS
void ReturnResult(JSContext* aContext, const Result& aCallResult, RootedDictionary<UniFFIRustCallResult>& aReturnValue) {
    switch (aCallResult.mCallStatus.code) {
        case uniffi::CALL_SUCCESS: {
            // Successful call.  Populate data with the return value
            aReturnValue.mCode = uniffi::CALL_SUCCESS;
            // Numeric Return
            aReturnValue.mData.setNumber(aCallResult.mReturnValue);
            break;
        }

        case uniffi::CALL_ERROR:
            // Rust Err() value.  Populate data with the `RustBuffer` containing the error
            aReturnValue.mCode = uniffi::CALL_ERROR;
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mCallStatus.error_buf).intoArrayBuffer(aContext));
            break;

        default:
            // This indicates a RustError, which shouldn't happen in practice since FF sets panic=abort
            aReturnValue.mCode = uniffi::CALL_INTERNAL_ERROR;
            aReturnValue.mInternalErrorMessage.AssignLiteral(u"Unexpected Error");
            break;
    }
}
}
// For each Rust scaffolding function, define types and functions for calling it
namespace rondpoint_9336_optionneur_sinon_i16_dec {
using namespace mozilla::dom;
// Arguments to pass to the scaffolding function
struct Args {
    void * ptr;
    int16_t value;
};

// Return values from the scaffolding function
struct Result {
    int16_t mReturnValue;
    RustCallStatus mCallStatus = {};
};

// Convert the arguments we get from JS to arguments to pass to Rust.
//
// On error, an error code will be stored in result.  Make sure to check this before
// passing the args to Invoke().
//
// For async calls this should be called in the main thread, since the GC can
// move the ArrayBuffer pointers while the background task is waiting.
Args PrepareArgs(const UniFFIPointer& ptr, const int16_t& value,
    mozilla::ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args
    Args uniFFIArgs;
    // We check if the pointer in the argument passed has the same type expected by this
    // function
    if (!ptr.isSamePtrType(&OptionneurPointerType::getInstance())) {
        aUniFFIError.ThrowTypeError("pointer ptr is not of type Optionneur");
        return uniFFIArgs;
    }
    uniFFIArgs.ptr = ptr.getPtr();
    uniFFIArgs.value = value;

    return uniFFIArgs;
}

// Call the scaffolding function
//
// For async calls this should be called in the worker thread
Result Invoke(Args& aArgs) {
    Result result = {};result.mReturnValue =::rondpoint_9336_Optionneur_sinon_i16_dec(
         aArgs.ptr,
         aArgs.value,
         &result.mCallStatus
     );
    return result;
}

// Return the result of the scaffolding call back to JS
void ReturnResult(JSContext* aContext, const Result& aCallResult, RootedDictionary<UniFFIRustCallResult>& aReturnValue) {
    switch (aCallResult.mCallStatus.code) {
        case uniffi::CALL_SUCCESS: {
            // Successful call.  Populate data with the return value
            aReturnValue.mCode = uniffi::CALL_SUCCESS;
            // Numeric Return
            aReturnValue.mData.setNumber(aCallResult.mReturnValue);
            break;
        }

        case uniffi::CALL_ERROR:
            // Rust Err() value.  Populate data with the `RustBuffer` containing the error
            aReturnValue.mCode = uniffi::CALL_ERROR;
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mCallStatus.error_buf).intoArrayBuffer(aContext));
            break;

        default:
            // This indicates a RustError, which shouldn't happen in practice since FF sets panic=abort
            aReturnValue.mCode = uniffi::CALL_INTERNAL_ERROR;
            aReturnValue.mInternalErrorMessage.AssignLiteral(u"Unexpected Error");
            break;
    }
}
}
// For each Rust scaffolding function, define types and functions for calling it
namespace rondpoint_9336_optionneur_sinon_u32_dec {
using namespace mozilla::dom;
// Arguments to pass to the scaffolding function
struct Args {
    void * ptr;
    uint32_t value;
};

// Return values from the scaffolding function
struct Result {
    uint32_t mReturnValue;
    RustCallStatus mCallStatus = {};
};

// Convert the arguments we get from JS to arguments to pass to Rust.
//
// On error, an error code will be stored in result.  Make sure to check this before
// passing the args to Invoke().
//
// For async calls this should be called in the main thread, since the GC can
// move the ArrayBuffer pointers while the background task is waiting.
Args PrepareArgs(const UniFFIPointer& ptr, const uint32_t& value,
    mozilla::ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args
    Args uniFFIArgs;
    // We check if the pointer in the argument passed has the same type expected by this
    // function
    if (!ptr.isSamePtrType(&OptionneurPointerType::getInstance())) {
        aUniFFIError.ThrowTypeError("pointer ptr is not of type Optionneur");
        return uniFFIArgs;
    }
    uniFFIArgs.ptr = ptr.getPtr();
    uniFFIArgs.value = value;

    return uniFFIArgs;
}

// Call the scaffolding function
//
// For async calls this should be called in the worker thread
Result Invoke(Args& aArgs) {
    Result result = {};result.mReturnValue =::rondpoint_9336_Optionneur_sinon_u32_dec(
         aArgs.ptr,
         aArgs.value,
         &result.mCallStatus
     );
    return result;
}

// Return the result of the scaffolding call back to JS
void ReturnResult(JSContext* aContext, const Result& aCallResult, RootedDictionary<UniFFIRustCallResult>& aReturnValue) {
    switch (aCallResult.mCallStatus.code) {
        case uniffi::CALL_SUCCESS: {
            // Successful call.  Populate data with the return value
            aReturnValue.mCode = uniffi::CALL_SUCCESS;
            // Numeric Return
            aReturnValue.mData.setNumber(aCallResult.mReturnValue);
            break;
        }

        case uniffi::CALL_ERROR:
            // Rust Err() value.  Populate data with the `RustBuffer` containing the error
            aReturnValue.mCode = uniffi::CALL_ERROR;
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mCallStatus.error_buf).intoArrayBuffer(aContext));
            break;

        default:
            // This indicates a RustError, which shouldn't happen in practice since FF sets panic=abort
            aReturnValue.mCode = uniffi::CALL_INTERNAL_ERROR;
            aReturnValue.mInternalErrorMessage.AssignLiteral(u"Unexpected Error");
            break;
    }
}
}
// For each Rust scaffolding function, define types and functions for calling it
namespace rondpoint_9336_optionneur_sinon_i32_dec {
using namespace mozilla::dom;
// Arguments to pass to the scaffolding function
struct Args {
    void * ptr;
    int32_t value;
};

// Return values from the scaffolding function
struct Result {
    int32_t mReturnValue;
    RustCallStatus mCallStatus = {};
};

// Convert the arguments we get from JS to arguments to pass to Rust.
//
// On error, an error code will be stored in result.  Make sure to check this before
// passing the args to Invoke().
//
// For async calls this should be called in the main thread, since the GC can
// move the ArrayBuffer pointers while the background task is waiting.
Args PrepareArgs(const UniFFIPointer& ptr, const int32_t& value,
    mozilla::ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args
    Args uniFFIArgs;
    // We check if the pointer in the argument passed has the same type expected by this
    // function
    if (!ptr.isSamePtrType(&OptionneurPointerType::getInstance())) {
        aUniFFIError.ThrowTypeError("pointer ptr is not of type Optionneur");
        return uniFFIArgs;
    }
    uniFFIArgs.ptr = ptr.getPtr();
    uniFFIArgs.value = value;

    return uniFFIArgs;
}

// Call the scaffolding function
//
// For async calls this should be called in the worker thread
Result Invoke(Args& aArgs) {
    Result result = {};result.mReturnValue =::rondpoint_9336_Optionneur_sinon_i32_dec(
         aArgs.ptr,
         aArgs.value,
         &result.mCallStatus
     );
    return result;
}

// Return the result of the scaffolding call back to JS
void ReturnResult(JSContext* aContext, const Result& aCallResult, RootedDictionary<UniFFIRustCallResult>& aReturnValue) {
    switch (aCallResult.mCallStatus.code) {
        case uniffi::CALL_SUCCESS: {
            // Successful call.  Populate data with the return value
            aReturnValue.mCode = uniffi::CALL_SUCCESS;
            // Numeric Return
            aReturnValue.mData.setNumber(aCallResult.mReturnValue);
            break;
        }

        case uniffi::CALL_ERROR:
            // Rust Err() value.  Populate data with the `RustBuffer` containing the error
            aReturnValue.mCode = uniffi::CALL_ERROR;
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mCallStatus.error_buf).intoArrayBuffer(aContext));
            break;

        default:
            // This indicates a RustError, which shouldn't happen in practice since FF sets panic=abort
            aReturnValue.mCode = uniffi::CALL_INTERNAL_ERROR;
            aReturnValue.mInternalErrorMessage.AssignLiteral(u"Unexpected Error");
            break;
    }
}
}
// For each Rust scaffolding function, define types and functions for calling it
namespace rondpoint_9336_optionneur_sinon_u64_dec {
using namespace mozilla::dom;
// Arguments to pass to the scaffolding function
struct Args {
    void * ptr;
    uint64_t value;
};

// Return values from the scaffolding function
struct Result {
    uint64_t mReturnValue;
    RustCallStatus mCallStatus = {};
};

// Convert the arguments we get from JS to arguments to pass to Rust.
//
// On error, an error code will be stored in result.  Make sure to check this before
// passing the args to Invoke().
//
// For async calls this should be called in the main thread, since the GC can
// move the ArrayBuffer pointers while the background task is waiting.
Args PrepareArgs(const UniFFIPointer& ptr, const uint64_t& value,
    mozilla::ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args
    Args uniFFIArgs;
    // We check if the pointer in the argument passed has the same type expected by this
    // function
    if (!ptr.isSamePtrType(&OptionneurPointerType::getInstance())) {
        aUniFFIError.ThrowTypeError("pointer ptr is not of type Optionneur");
        return uniFFIArgs;
    }
    uniFFIArgs.ptr = ptr.getPtr();
    uniFFIArgs.value = value;

    return uniFFIArgs;
}

// Call the scaffolding function
//
// For async calls this should be called in the worker thread
Result Invoke(Args& aArgs) {
    Result result = {};result.mReturnValue =::rondpoint_9336_Optionneur_sinon_u64_dec(
         aArgs.ptr,
         aArgs.value,
         &result.mCallStatus
     );
    return result;
}

// Return the result of the scaffolding call back to JS
void ReturnResult(JSContext* aContext, const Result& aCallResult, RootedDictionary<UniFFIRustCallResult>& aReturnValue) {
    switch (aCallResult.mCallStatus.code) {
        case uniffi::CALL_SUCCESS: {
            // Successful call.  Populate data with the return value
            aReturnValue.mCode = uniffi::CALL_SUCCESS;
            // Numeric Return
            aReturnValue.mData.setNumber(aCallResult.mReturnValue);
            break;
        }

        case uniffi::CALL_ERROR:
            // Rust Err() value.  Populate data with the `RustBuffer` containing the error
            aReturnValue.mCode = uniffi::CALL_ERROR;
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mCallStatus.error_buf).intoArrayBuffer(aContext));
            break;

        default:
            // This indicates a RustError, which shouldn't happen in practice since FF sets panic=abort
            aReturnValue.mCode = uniffi::CALL_INTERNAL_ERROR;
            aReturnValue.mInternalErrorMessage.AssignLiteral(u"Unexpected Error");
            break;
    }
}
}
// For each Rust scaffolding function, define types and functions for calling it
namespace rondpoint_9336_optionneur_sinon_i64_dec {
using namespace mozilla::dom;
// Arguments to pass to the scaffolding function
struct Args {
    void * ptr;
    int64_t value;
};

// Return values from the scaffolding function
struct Result {
    int64_t mReturnValue;
    RustCallStatus mCallStatus = {};
};

// Convert the arguments we get from JS to arguments to pass to Rust.
//
// On error, an error code will be stored in result.  Make sure to check this before
// passing the args to Invoke().
//
// For async calls this should be called in the main thread, since the GC can
// move the ArrayBuffer pointers while the background task is waiting.
Args PrepareArgs(const UniFFIPointer& ptr, const int64_t& value,
    mozilla::ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args
    Args uniFFIArgs;
    // We check if the pointer in the argument passed has the same type expected by this
    // function
    if (!ptr.isSamePtrType(&OptionneurPointerType::getInstance())) {
        aUniFFIError.ThrowTypeError("pointer ptr is not of type Optionneur");
        return uniFFIArgs;
    }
    uniFFIArgs.ptr = ptr.getPtr();
    uniFFIArgs.value = value;

    return uniFFIArgs;
}

// Call the scaffolding function
//
// For async calls this should be called in the worker thread
Result Invoke(Args& aArgs) {
    Result result = {};result.mReturnValue =::rondpoint_9336_Optionneur_sinon_i64_dec(
         aArgs.ptr,
         aArgs.value,
         &result.mCallStatus
     );
    return result;
}

// Return the result of the scaffolding call back to JS
void ReturnResult(JSContext* aContext, const Result& aCallResult, RootedDictionary<UniFFIRustCallResult>& aReturnValue) {
    switch (aCallResult.mCallStatus.code) {
        case uniffi::CALL_SUCCESS: {
            // Successful call.  Populate data with the return value
            aReturnValue.mCode = uniffi::CALL_SUCCESS;
            // Numeric Return
            aReturnValue.mData.setNumber(aCallResult.mReturnValue);
            break;
        }

        case uniffi::CALL_ERROR:
            // Rust Err() value.  Populate data with the `RustBuffer` containing the error
            aReturnValue.mCode = uniffi::CALL_ERROR;
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mCallStatus.error_buf).intoArrayBuffer(aContext));
            break;

        default:
            // This indicates a RustError, which shouldn't happen in practice since FF sets panic=abort
            aReturnValue.mCode = uniffi::CALL_INTERNAL_ERROR;
            aReturnValue.mInternalErrorMessage.AssignLiteral(u"Unexpected Error");
            break;
    }
}
}
// For each Rust scaffolding function, define types and functions for calling it
namespace rondpoint_9336_optionneur_sinon_u8_hex {
using namespace mozilla::dom;
// Arguments to pass to the scaffolding function
struct Args {
    void * ptr;
    uint8_t value;
};

// Return values from the scaffolding function
struct Result {
    uint8_t mReturnValue;
    RustCallStatus mCallStatus = {};
};

// Convert the arguments we get from JS to arguments to pass to Rust.
//
// On error, an error code will be stored in result.  Make sure to check this before
// passing the args to Invoke().
//
// For async calls this should be called in the main thread, since the GC can
// move the ArrayBuffer pointers while the background task is waiting.
Args PrepareArgs(const UniFFIPointer& ptr, const uint8_t& value,
    mozilla::ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args
    Args uniFFIArgs;
    // We check if the pointer in the argument passed has the same type expected by this
    // function
    if (!ptr.isSamePtrType(&OptionneurPointerType::getInstance())) {
        aUniFFIError.ThrowTypeError("pointer ptr is not of type Optionneur");
        return uniFFIArgs;
    }
    uniFFIArgs.ptr = ptr.getPtr();
    uniFFIArgs.value = value;

    return uniFFIArgs;
}

// Call the scaffolding function
//
// For async calls this should be called in the worker thread
Result Invoke(Args& aArgs) {
    Result result = {};result.mReturnValue =::rondpoint_9336_Optionneur_sinon_u8_hex(
         aArgs.ptr,
         aArgs.value,
         &result.mCallStatus
     );
    return result;
}

// Return the result of the scaffolding call back to JS
void ReturnResult(JSContext* aContext, const Result& aCallResult, RootedDictionary<UniFFIRustCallResult>& aReturnValue) {
    switch (aCallResult.mCallStatus.code) {
        case uniffi::CALL_SUCCESS: {
            // Successful call.  Populate data with the return value
            aReturnValue.mCode = uniffi::CALL_SUCCESS;
            // Numeric Return
            aReturnValue.mData.setNumber(aCallResult.mReturnValue);
            break;
        }

        case uniffi::CALL_ERROR:
            // Rust Err() value.  Populate data with the `RustBuffer` containing the error
            aReturnValue.mCode = uniffi::CALL_ERROR;
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mCallStatus.error_buf).intoArrayBuffer(aContext));
            break;

        default:
            // This indicates a RustError, which shouldn't happen in practice since FF sets panic=abort
            aReturnValue.mCode = uniffi::CALL_INTERNAL_ERROR;
            aReturnValue.mInternalErrorMessage.AssignLiteral(u"Unexpected Error");
            break;
    }
}
}
// For each Rust scaffolding function, define types and functions for calling it
namespace rondpoint_9336_optionneur_sinon_i8_hex {
using namespace mozilla::dom;
// Arguments to pass to the scaffolding function
struct Args {
    void * ptr;
    int8_t value;
};

// Return values from the scaffolding function
struct Result {
    int8_t mReturnValue;
    RustCallStatus mCallStatus = {};
};

// Convert the arguments we get from JS to arguments to pass to Rust.
//
// On error, an error code will be stored in result.  Make sure to check this before
// passing the args to Invoke().
//
// For async calls this should be called in the main thread, since the GC can
// move the ArrayBuffer pointers while the background task is waiting.
Args PrepareArgs(const UniFFIPointer& ptr, const int8_t& value,
    mozilla::ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args
    Args uniFFIArgs;
    // We check if the pointer in the argument passed has the same type expected by this
    // function
    if (!ptr.isSamePtrType(&OptionneurPointerType::getInstance())) {
        aUniFFIError.ThrowTypeError("pointer ptr is not of type Optionneur");
        return uniFFIArgs;
    }
    uniFFIArgs.ptr = ptr.getPtr();
    uniFFIArgs.value = value;

    return uniFFIArgs;
}

// Call the scaffolding function
//
// For async calls this should be called in the worker thread
Result Invoke(Args& aArgs) {
    Result result = {};result.mReturnValue =::rondpoint_9336_Optionneur_sinon_i8_hex(
         aArgs.ptr,
         aArgs.value,
         &result.mCallStatus
     );
    return result;
}

// Return the result of the scaffolding call back to JS
void ReturnResult(JSContext* aContext, const Result& aCallResult, RootedDictionary<UniFFIRustCallResult>& aReturnValue) {
    switch (aCallResult.mCallStatus.code) {
        case uniffi::CALL_SUCCESS: {
            // Successful call.  Populate data with the return value
            aReturnValue.mCode = uniffi::CALL_SUCCESS;
            // Numeric Return
            aReturnValue.mData.setNumber(aCallResult.mReturnValue);
            break;
        }

        case uniffi::CALL_ERROR:
            // Rust Err() value.  Populate data with the `RustBuffer` containing the error
            aReturnValue.mCode = uniffi::CALL_ERROR;
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mCallStatus.error_buf).intoArrayBuffer(aContext));
            break;

        default:
            // This indicates a RustError, which shouldn't happen in practice since FF sets panic=abort
            aReturnValue.mCode = uniffi::CALL_INTERNAL_ERROR;
            aReturnValue.mInternalErrorMessage.AssignLiteral(u"Unexpected Error");
            break;
    }
}
}
// For each Rust scaffolding function, define types and functions for calling it
namespace rondpoint_9336_optionneur_sinon_u16_hex {
using namespace mozilla::dom;
// Arguments to pass to the scaffolding function
struct Args {
    void * ptr;
    uint16_t value;
};

// Return values from the scaffolding function
struct Result {
    uint16_t mReturnValue;
    RustCallStatus mCallStatus = {};
};

// Convert the arguments we get from JS to arguments to pass to Rust.
//
// On error, an error code will be stored in result.  Make sure to check this before
// passing the args to Invoke().
//
// For async calls this should be called in the main thread, since the GC can
// move the ArrayBuffer pointers while the background task is waiting.
Args PrepareArgs(const UniFFIPointer& ptr, const uint16_t& value,
    mozilla::ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args
    Args uniFFIArgs;
    // We check if the pointer in the argument passed has the same type expected by this
    // function
    if (!ptr.isSamePtrType(&OptionneurPointerType::getInstance())) {
        aUniFFIError.ThrowTypeError("pointer ptr is not of type Optionneur");
        return uniFFIArgs;
    }
    uniFFIArgs.ptr = ptr.getPtr();
    uniFFIArgs.value = value;

    return uniFFIArgs;
}

// Call the scaffolding function
//
// For async calls this should be called in the worker thread
Result Invoke(Args& aArgs) {
    Result result = {};result.mReturnValue =::rondpoint_9336_Optionneur_sinon_u16_hex(
         aArgs.ptr,
         aArgs.value,
         &result.mCallStatus
     );
    return result;
}

// Return the result of the scaffolding call back to JS
void ReturnResult(JSContext* aContext, const Result& aCallResult, RootedDictionary<UniFFIRustCallResult>& aReturnValue) {
    switch (aCallResult.mCallStatus.code) {
        case uniffi::CALL_SUCCESS: {
            // Successful call.  Populate data with the return value
            aReturnValue.mCode = uniffi::CALL_SUCCESS;
            // Numeric Return
            aReturnValue.mData.setNumber(aCallResult.mReturnValue);
            break;
        }

        case uniffi::CALL_ERROR:
            // Rust Err() value.  Populate data with the `RustBuffer` containing the error
            aReturnValue.mCode = uniffi::CALL_ERROR;
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mCallStatus.error_buf).intoArrayBuffer(aContext));
            break;

        default:
            // This indicates a RustError, which shouldn't happen in practice since FF sets panic=abort
            aReturnValue.mCode = uniffi::CALL_INTERNAL_ERROR;
            aReturnValue.mInternalErrorMessage.AssignLiteral(u"Unexpected Error");
            break;
    }
}
}
// For each Rust scaffolding function, define types and functions for calling it
namespace rondpoint_9336_optionneur_sinon_i16_hex {
using namespace mozilla::dom;
// Arguments to pass to the scaffolding function
struct Args {
    void * ptr;
    int16_t value;
};

// Return values from the scaffolding function
struct Result {
    int16_t mReturnValue;
    RustCallStatus mCallStatus = {};
};

// Convert the arguments we get from JS to arguments to pass to Rust.
//
// On error, an error code will be stored in result.  Make sure to check this before
// passing the args to Invoke().
//
// For async calls this should be called in the main thread, since the GC can
// move the ArrayBuffer pointers while the background task is waiting.
Args PrepareArgs(const UniFFIPointer& ptr, const int16_t& value,
    mozilla::ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args
    Args uniFFIArgs;
    // We check if the pointer in the argument passed has the same type expected by this
    // function
    if (!ptr.isSamePtrType(&OptionneurPointerType::getInstance())) {
        aUniFFIError.ThrowTypeError("pointer ptr is not of type Optionneur");
        return uniFFIArgs;
    }
    uniFFIArgs.ptr = ptr.getPtr();
    uniFFIArgs.value = value;

    return uniFFIArgs;
}

// Call the scaffolding function
//
// For async calls this should be called in the worker thread
Result Invoke(Args& aArgs) {
    Result result = {};result.mReturnValue =::rondpoint_9336_Optionneur_sinon_i16_hex(
         aArgs.ptr,
         aArgs.value,
         &result.mCallStatus
     );
    return result;
}

// Return the result of the scaffolding call back to JS
void ReturnResult(JSContext* aContext, const Result& aCallResult, RootedDictionary<UniFFIRustCallResult>& aReturnValue) {
    switch (aCallResult.mCallStatus.code) {
        case uniffi::CALL_SUCCESS: {
            // Successful call.  Populate data with the return value
            aReturnValue.mCode = uniffi::CALL_SUCCESS;
            // Numeric Return
            aReturnValue.mData.setNumber(aCallResult.mReturnValue);
            break;
        }

        case uniffi::CALL_ERROR:
            // Rust Err() value.  Populate data with the `RustBuffer` containing the error
            aReturnValue.mCode = uniffi::CALL_ERROR;
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mCallStatus.error_buf).intoArrayBuffer(aContext));
            break;

        default:
            // This indicates a RustError, which shouldn't happen in practice since FF sets panic=abort
            aReturnValue.mCode = uniffi::CALL_INTERNAL_ERROR;
            aReturnValue.mInternalErrorMessage.AssignLiteral(u"Unexpected Error");
            break;
    }
}
}
// For each Rust scaffolding function, define types and functions for calling it
namespace rondpoint_9336_optionneur_sinon_u32_hex {
using namespace mozilla::dom;
// Arguments to pass to the scaffolding function
struct Args {
    void * ptr;
    uint32_t value;
};

// Return values from the scaffolding function
struct Result {
    uint32_t mReturnValue;
    RustCallStatus mCallStatus = {};
};

// Convert the arguments we get from JS to arguments to pass to Rust.
//
// On error, an error code will be stored in result.  Make sure to check this before
// passing the args to Invoke().
//
// For async calls this should be called in the main thread, since the GC can
// move the ArrayBuffer pointers while the background task is waiting.
Args PrepareArgs(const UniFFIPointer& ptr, const uint32_t& value,
    mozilla::ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args
    Args uniFFIArgs;
    // We check if the pointer in the argument passed has the same type expected by this
    // function
    if (!ptr.isSamePtrType(&OptionneurPointerType::getInstance())) {
        aUniFFIError.ThrowTypeError("pointer ptr is not of type Optionneur");
        return uniFFIArgs;
    }
    uniFFIArgs.ptr = ptr.getPtr();
    uniFFIArgs.value = value;

    return uniFFIArgs;
}

// Call the scaffolding function
//
// For async calls this should be called in the worker thread
Result Invoke(Args& aArgs) {
    Result result = {};result.mReturnValue =::rondpoint_9336_Optionneur_sinon_u32_hex(
         aArgs.ptr,
         aArgs.value,
         &result.mCallStatus
     );
    return result;
}

// Return the result of the scaffolding call back to JS
void ReturnResult(JSContext* aContext, const Result& aCallResult, RootedDictionary<UniFFIRustCallResult>& aReturnValue) {
    switch (aCallResult.mCallStatus.code) {
        case uniffi::CALL_SUCCESS: {
            // Successful call.  Populate data with the return value
            aReturnValue.mCode = uniffi::CALL_SUCCESS;
            // Numeric Return
            aReturnValue.mData.setNumber(aCallResult.mReturnValue);
            break;
        }

        case uniffi::CALL_ERROR:
            // Rust Err() value.  Populate data with the `RustBuffer` containing the error
            aReturnValue.mCode = uniffi::CALL_ERROR;
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mCallStatus.error_buf).intoArrayBuffer(aContext));
            break;

        default:
            // This indicates a RustError, which shouldn't happen in practice since FF sets panic=abort
            aReturnValue.mCode = uniffi::CALL_INTERNAL_ERROR;
            aReturnValue.mInternalErrorMessage.AssignLiteral(u"Unexpected Error");
            break;
    }
}
}
// For each Rust scaffolding function, define types and functions for calling it
namespace rondpoint_9336_optionneur_sinon_i32_hex {
using namespace mozilla::dom;
// Arguments to pass to the scaffolding function
struct Args {
    void * ptr;
    int32_t value;
};

// Return values from the scaffolding function
struct Result {
    int32_t mReturnValue;
    RustCallStatus mCallStatus = {};
};

// Convert the arguments we get from JS to arguments to pass to Rust.
//
// On error, an error code will be stored in result.  Make sure to check this before
// passing the args to Invoke().
//
// For async calls this should be called in the main thread, since the GC can
// move the ArrayBuffer pointers while the background task is waiting.
Args PrepareArgs(const UniFFIPointer& ptr, const int32_t& value,
    mozilla::ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args
    Args uniFFIArgs;
    // We check if the pointer in the argument passed has the same type expected by this
    // function
    if (!ptr.isSamePtrType(&OptionneurPointerType::getInstance())) {
        aUniFFIError.ThrowTypeError("pointer ptr is not of type Optionneur");
        return uniFFIArgs;
    }
    uniFFIArgs.ptr = ptr.getPtr();
    uniFFIArgs.value = value;

    return uniFFIArgs;
}

// Call the scaffolding function
//
// For async calls this should be called in the worker thread
Result Invoke(Args& aArgs) {
    Result result = {};result.mReturnValue =::rondpoint_9336_Optionneur_sinon_i32_hex(
         aArgs.ptr,
         aArgs.value,
         &result.mCallStatus
     );
    return result;
}

// Return the result of the scaffolding call back to JS
void ReturnResult(JSContext* aContext, const Result& aCallResult, RootedDictionary<UniFFIRustCallResult>& aReturnValue) {
    switch (aCallResult.mCallStatus.code) {
        case uniffi::CALL_SUCCESS: {
            // Successful call.  Populate data with the return value
            aReturnValue.mCode = uniffi::CALL_SUCCESS;
            // Numeric Return
            aReturnValue.mData.setNumber(aCallResult.mReturnValue);
            break;
        }

        case uniffi::CALL_ERROR:
            // Rust Err() value.  Populate data with the `RustBuffer` containing the error
            aReturnValue.mCode = uniffi::CALL_ERROR;
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mCallStatus.error_buf).intoArrayBuffer(aContext));
            break;

        default:
            // This indicates a RustError, which shouldn't happen in practice since FF sets panic=abort
            aReturnValue.mCode = uniffi::CALL_INTERNAL_ERROR;
            aReturnValue.mInternalErrorMessage.AssignLiteral(u"Unexpected Error");
            break;
    }
}
}
// For each Rust scaffolding function, define types and functions for calling it
namespace rondpoint_9336_optionneur_sinon_u64_hex {
using namespace mozilla::dom;
// Arguments to pass to the scaffolding function
struct Args {
    void * ptr;
    uint64_t value;
};

// Return values from the scaffolding function
struct Result {
    uint64_t mReturnValue;
    RustCallStatus mCallStatus = {};
};

// Convert the arguments we get from JS to arguments to pass to Rust.
//
// On error, an error code will be stored in result.  Make sure to check this before
// passing the args to Invoke().
//
// For async calls this should be called in the main thread, since the GC can
// move the ArrayBuffer pointers while the background task is waiting.
Args PrepareArgs(const UniFFIPointer& ptr, const uint64_t& value,
    mozilla::ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args
    Args uniFFIArgs;
    // We check if the pointer in the argument passed has the same type expected by this
    // function
    if (!ptr.isSamePtrType(&OptionneurPointerType::getInstance())) {
        aUniFFIError.ThrowTypeError("pointer ptr is not of type Optionneur");
        return uniFFIArgs;
    }
    uniFFIArgs.ptr = ptr.getPtr();
    uniFFIArgs.value = value;

    return uniFFIArgs;
}

// Call the scaffolding function
//
// For async calls this should be called in the worker thread
Result Invoke(Args& aArgs) {
    Result result = {};result.mReturnValue =::rondpoint_9336_Optionneur_sinon_u64_hex(
         aArgs.ptr,
         aArgs.value,
         &result.mCallStatus
     );
    return result;
}

// Return the result of the scaffolding call back to JS
void ReturnResult(JSContext* aContext, const Result& aCallResult, RootedDictionary<UniFFIRustCallResult>& aReturnValue) {
    switch (aCallResult.mCallStatus.code) {
        case uniffi::CALL_SUCCESS: {
            // Successful call.  Populate data with the return value
            aReturnValue.mCode = uniffi::CALL_SUCCESS;
            // Numeric Return
            aReturnValue.mData.setNumber(aCallResult.mReturnValue);
            break;
        }

        case uniffi::CALL_ERROR:
            // Rust Err() value.  Populate data with the `RustBuffer` containing the error
            aReturnValue.mCode = uniffi::CALL_ERROR;
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mCallStatus.error_buf).intoArrayBuffer(aContext));
            break;

        default:
            // This indicates a RustError, which shouldn't happen in practice since FF sets panic=abort
            aReturnValue.mCode = uniffi::CALL_INTERNAL_ERROR;
            aReturnValue.mInternalErrorMessage.AssignLiteral(u"Unexpected Error");
            break;
    }
}
}
// For each Rust scaffolding function, define types and functions for calling it
namespace rondpoint_9336_optionneur_sinon_i64_hex {
using namespace mozilla::dom;
// Arguments to pass to the scaffolding function
struct Args {
    void * ptr;
    int64_t value;
};

// Return values from the scaffolding function
struct Result {
    int64_t mReturnValue;
    RustCallStatus mCallStatus = {};
};

// Convert the arguments we get from JS to arguments to pass to Rust.
//
// On error, an error code will be stored in result.  Make sure to check this before
// passing the args to Invoke().
//
// For async calls this should be called in the main thread, since the GC can
// move the ArrayBuffer pointers while the background task is waiting.
Args PrepareArgs(const UniFFIPointer& ptr, const int64_t& value,
    mozilla::ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args
    Args uniFFIArgs;
    // We check if the pointer in the argument passed has the same type expected by this
    // function
    if (!ptr.isSamePtrType(&OptionneurPointerType::getInstance())) {
        aUniFFIError.ThrowTypeError("pointer ptr is not of type Optionneur");
        return uniFFIArgs;
    }
    uniFFIArgs.ptr = ptr.getPtr();
    uniFFIArgs.value = value;

    return uniFFIArgs;
}

// Call the scaffolding function
//
// For async calls this should be called in the worker thread
Result Invoke(Args& aArgs) {
    Result result = {};result.mReturnValue =::rondpoint_9336_Optionneur_sinon_i64_hex(
         aArgs.ptr,
         aArgs.value,
         &result.mCallStatus
     );
    return result;
}

// Return the result of the scaffolding call back to JS
void ReturnResult(JSContext* aContext, const Result& aCallResult, RootedDictionary<UniFFIRustCallResult>& aReturnValue) {
    switch (aCallResult.mCallStatus.code) {
        case uniffi::CALL_SUCCESS: {
            // Successful call.  Populate data with the return value
            aReturnValue.mCode = uniffi::CALL_SUCCESS;
            // Numeric Return
            aReturnValue.mData.setNumber(aCallResult.mReturnValue);
            break;
        }

        case uniffi::CALL_ERROR:
            // Rust Err() value.  Populate data with the `RustBuffer` containing the error
            aReturnValue.mCode = uniffi::CALL_ERROR;
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mCallStatus.error_buf).intoArrayBuffer(aContext));
            break;

        default:
            // This indicates a RustError, which shouldn't happen in practice since FF sets panic=abort
            aReturnValue.mCode = uniffi::CALL_INTERNAL_ERROR;
            aReturnValue.mInternalErrorMessage.AssignLiteral(u"Unexpected Error");
            break;
    }
}
}
// For each Rust scaffolding function, define types and functions for calling it
namespace rondpoint_9336_optionneur_sinon_u32_oct {
using namespace mozilla::dom;
// Arguments to pass to the scaffolding function
struct Args {
    void * ptr;
    uint32_t value;
};

// Return values from the scaffolding function
struct Result {
    uint32_t mReturnValue;
    RustCallStatus mCallStatus = {};
};

// Convert the arguments we get from JS to arguments to pass to Rust.
//
// On error, an error code will be stored in result.  Make sure to check this before
// passing the args to Invoke().
//
// For async calls this should be called in the main thread, since the GC can
// move the ArrayBuffer pointers while the background task is waiting.
Args PrepareArgs(const UniFFIPointer& ptr, const uint32_t& value,
    mozilla::ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args
    Args uniFFIArgs;
    // We check if the pointer in the argument passed has the same type expected by this
    // function
    if (!ptr.isSamePtrType(&OptionneurPointerType::getInstance())) {
        aUniFFIError.ThrowTypeError("pointer ptr is not of type Optionneur");
        return uniFFIArgs;
    }
    uniFFIArgs.ptr = ptr.getPtr();
    uniFFIArgs.value = value;

    return uniFFIArgs;
}

// Call the scaffolding function
//
// For async calls this should be called in the worker thread
Result Invoke(Args& aArgs) {
    Result result = {};result.mReturnValue =::rondpoint_9336_Optionneur_sinon_u32_oct(
         aArgs.ptr,
         aArgs.value,
         &result.mCallStatus
     );
    return result;
}

// Return the result of the scaffolding call back to JS
void ReturnResult(JSContext* aContext, const Result& aCallResult, RootedDictionary<UniFFIRustCallResult>& aReturnValue) {
    switch (aCallResult.mCallStatus.code) {
        case uniffi::CALL_SUCCESS: {
            // Successful call.  Populate data with the return value
            aReturnValue.mCode = uniffi::CALL_SUCCESS;
            // Numeric Return
            aReturnValue.mData.setNumber(aCallResult.mReturnValue);
            break;
        }

        case uniffi::CALL_ERROR:
            // Rust Err() value.  Populate data with the `RustBuffer` containing the error
            aReturnValue.mCode = uniffi::CALL_ERROR;
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mCallStatus.error_buf).intoArrayBuffer(aContext));
            break;

        default:
            // This indicates a RustError, which shouldn't happen in practice since FF sets panic=abort
            aReturnValue.mCode = uniffi::CALL_INTERNAL_ERROR;
            aReturnValue.mInternalErrorMessage.AssignLiteral(u"Unexpected Error");
            break;
    }
}
}
// For each Rust scaffolding function, define types and functions for calling it
namespace rondpoint_9336_optionneur_sinon_f32 {
using namespace mozilla::dom;
// Arguments to pass to the scaffolding function
struct Args {
    void * ptr;
    float value;
};

// Return values from the scaffolding function
struct Result {
    float mReturnValue;
    RustCallStatus mCallStatus = {};
};

// Convert the arguments we get from JS to arguments to pass to Rust.
//
// On error, an error code will be stored in result.  Make sure to check this before
// passing the args to Invoke().
//
// For async calls this should be called in the main thread, since the GC can
// move the ArrayBuffer pointers while the background task is waiting.
Args PrepareArgs(const UniFFIPointer& ptr, const float& value,
    mozilla::ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args
    Args uniFFIArgs;
    // We check if the pointer in the argument passed has the same type expected by this
    // function
    if (!ptr.isSamePtrType(&OptionneurPointerType::getInstance())) {
        aUniFFIError.ThrowTypeError("pointer ptr is not of type Optionneur");
        return uniFFIArgs;
    }
    uniFFIArgs.ptr = ptr.getPtr();
    uniFFIArgs.value = value;

    return uniFFIArgs;
}

// Call the scaffolding function
//
// For async calls this should be called in the worker thread
Result Invoke(Args& aArgs) {
    Result result = {};result.mReturnValue =::rondpoint_9336_Optionneur_sinon_f32(
         aArgs.ptr,
         aArgs.value,
         &result.mCallStatus
     );
    return result;
}

// Return the result of the scaffolding call back to JS
void ReturnResult(JSContext* aContext, const Result& aCallResult, RootedDictionary<UniFFIRustCallResult>& aReturnValue) {
    switch (aCallResult.mCallStatus.code) {
        case uniffi::CALL_SUCCESS: {
            // Successful call.  Populate data with the return value
            aReturnValue.mCode = uniffi::CALL_SUCCESS;
            // Numeric Return
            aReturnValue.mData.setNumber(aCallResult.mReturnValue);
            break;
        }

        case uniffi::CALL_ERROR:
            // Rust Err() value.  Populate data with the `RustBuffer` containing the error
            aReturnValue.mCode = uniffi::CALL_ERROR;
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mCallStatus.error_buf).intoArrayBuffer(aContext));
            break;

        default:
            // This indicates a RustError, which shouldn't happen in practice since FF sets panic=abort
            aReturnValue.mCode = uniffi::CALL_INTERNAL_ERROR;
            aReturnValue.mInternalErrorMessage.AssignLiteral(u"Unexpected Error");
            break;
    }
}
}
// For each Rust scaffolding function, define types and functions for calling it
namespace rondpoint_9336_optionneur_sinon_f64 {
using namespace mozilla::dom;
// Arguments to pass to the scaffolding function
struct Args {
    void * ptr;
    double value;
};

// Return values from the scaffolding function
struct Result {
    double mReturnValue;
    RustCallStatus mCallStatus = {};
};

// Convert the arguments we get from JS to arguments to pass to Rust.
//
// On error, an error code will be stored in result.  Make sure to check this before
// passing the args to Invoke().
//
// For async calls this should be called in the main thread, since the GC can
// move the ArrayBuffer pointers while the background task is waiting.
Args PrepareArgs(const UniFFIPointer& ptr, const double& value,
    mozilla::ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args
    Args uniFFIArgs;
    // We check if the pointer in the argument passed has the same type expected by this
    // function
    if (!ptr.isSamePtrType(&OptionneurPointerType::getInstance())) {
        aUniFFIError.ThrowTypeError("pointer ptr is not of type Optionneur");
        return uniFFIArgs;
    }
    uniFFIArgs.ptr = ptr.getPtr();
    uniFFIArgs.value = value;

    return uniFFIArgs;
}

// Call the scaffolding function
//
// For async calls this should be called in the worker thread
Result Invoke(Args& aArgs) {
    Result result = {};result.mReturnValue =::rondpoint_9336_Optionneur_sinon_f64(
         aArgs.ptr,
         aArgs.value,
         &result.mCallStatus
     );
    return result;
}

// Return the result of the scaffolding call back to JS
void ReturnResult(JSContext* aContext, const Result& aCallResult, RootedDictionary<UniFFIRustCallResult>& aReturnValue) {
    switch (aCallResult.mCallStatus.code) {
        case uniffi::CALL_SUCCESS: {
            // Successful call.  Populate data with the return value
            aReturnValue.mCode = uniffi::CALL_SUCCESS;
            // Numeric Return
            aReturnValue.mData.setNumber(aCallResult.mReturnValue);
            break;
        }

        case uniffi::CALL_ERROR:
            // Rust Err() value.  Populate data with the `RustBuffer` containing the error
            aReturnValue.mCode = uniffi::CALL_ERROR;
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mCallStatus.error_buf).intoArrayBuffer(aContext));
            break;

        default:
            // This indicates a RustError, which shouldn't happen in practice since FF sets panic=abort
            aReturnValue.mCode = uniffi::CALL_INTERNAL_ERROR;
            aReturnValue.mInternalErrorMessage.AssignLiteral(u"Unexpected Error");
            break;
    }
}
}
// For each Rust scaffolding function, define types and functions for calling it
namespace rondpoint_9336_optionneur_sinon_enum {
using namespace mozilla::dom;
// Arguments to pass to the scaffolding function
struct Args {
    void * ptr;
    // RustBuffer arguments are stored as OwnedRustBuffer instances.  That class takes care of
    // freeing the buffer if the arguments don't get passed to Rust (i.e. intoRustBuffer()
    // isn't called).  This can happen if some of the ArrayBuffer arguments are succuessfully
    // converted, but one fails to convert.
    mozilla::dom::OwnedRustBuffer value;
};

// Return values from the scaffolding function
struct Result {
    RustBuffer mReturnValue;
    RustCallStatus mCallStatus = {};
};

// Convert the arguments we get from JS to arguments to pass to Rust.
//
// On error, an error code will be stored in result.  Make sure to check this before
// passing the args to Invoke().
//
// For async calls this should be called in the main thread, since the GC can
// move the ArrayBuffer pointers while the background task is waiting.
Args PrepareArgs(const UniFFIPointer& ptr, const ArrayBuffer& value,
    mozilla::ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args
    Args uniFFIArgs;
    // We check if the pointer in the argument passed has the same type expected by this
    // function
    if (!ptr.isSamePtrType(&OptionneurPointerType::getInstance())) {
        aUniFFIError.ThrowTypeError("pointer ptr is not of type Optionneur");
        return uniFFIArgs;
    }
    uniFFIArgs.ptr = ptr.getPtr();
    // Convert the ArrayBuffer we get from JS to an OwnedRustBuffer
    value.ComputeState();
    uniFFIArgs.value = OwnedRustBuffer(value, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return uniFFIArgs;
    }

    return uniFFIArgs;
}

// Call the scaffolding function
//
// For async calls this should be called in the worker thread
Result Invoke(Args& aArgs) {
    Result result = {};result.mReturnValue =::rondpoint_9336_Optionneur_sinon_enum(
         aArgs.ptr,
         // Call intoRustBuffer() to get a `RustBuffer` from an OwnedRustBuffer.  This transfers ownership to Rust,
         // OwnedRustBuffer will no longer try to free it
         aArgs.value.intoRustBuffer(),
         &result.mCallStatus
     );
    return result;
}

// Return the result of the scaffolding call back to JS
void ReturnResult(JSContext* aContext, const Result& aCallResult, RootedDictionary<UniFFIRustCallResult>& aReturnValue) {
    switch (aCallResult.mCallStatus.code) {
        case uniffi::CALL_SUCCESS: {
            // Successful call.  Populate data with the return value
            aReturnValue.mCode = uniffi::CALL_SUCCESS;
            // RustBuffer return, convert it to an ArrayBuffer
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mReturnValue).intoArrayBuffer(aContext));
            break;
        }

        case uniffi::CALL_ERROR:
            // Rust Err() value.  Populate data with the `RustBuffer` containing the error
            aReturnValue.mCode = uniffi::CALL_ERROR;
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mCallStatus.error_buf).intoArrayBuffer(aContext));
            break;

        default:
            // This indicates a RustError, which shouldn't happen in practice since FF sets panic=abort
            aReturnValue.mCode = uniffi::CALL_INTERNAL_ERROR;
            aReturnValue.mInternalErrorMessage.AssignLiteral(u"Unexpected Error");
            break;
    }
}
}
// For each Rust scaffolding function, define types and functions for calling it
namespace rondpoint_9336_copie_dictionnaire {
using namespace mozilla::dom;
// Arguments to pass to the scaffolding function
struct Args {
    // RustBuffer arguments are stored as OwnedRustBuffer instances.  That class takes care of
    // freeing the buffer if the arguments don't get passed to Rust (i.e. intoRustBuffer()
    // isn't called).  This can happen if some of the ArrayBuffer arguments are succuessfully
    // converted, but one fails to convert.
    mozilla::dom::OwnedRustBuffer d;
};

// Return values from the scaffolding function
struct Result {
    RustBuffer mReturnValue;
    RustCallStatus mCallStatus = {};
};

// Convert the arguments we get from JS to arguments to pass to Rust.
//
// On error, an error code will be stored in result.  Make sure to check this before
// passing the args to Invoke().
//
// For async calls this should be called in the main thread, since the GC can
// move the ArrayBuffer pointers while the background task is waiting.
Args PrepareArgs(const ArrayBuffer& d,
    mozilla::ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args
    Args uniFFIArgs;
    // Convert the ArrayBuffer we get from JS to an OwnedRustBuffer
    d.ComputeState();
    uniFFIArgs.d = OwnedRustBuffer(d, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return uniFFIArgs;
    }

    return uniFFIArgs;
}

// Call the scaffolding function
//
// For async calls this should be called in the worker thread
Result Invoke(Args& aArgs) {
    Result result = {};result.mReturnValue =::rondpoint_9336_copie_dictionnaire(
         // Call intoRustBuffer() to get a `RustBuffer` from an OwnedRustBuffer.  This transfers ownership to Rust,
         // OwnedRustBuffer will no longer try to free it
         aArgs.d.intoRustBuffer(),
         &result.mCallStatus
     );
    return result;
}

// Return the result of the scaffolding call back to JS
void ReturnResult(JSContext* aContext, const Result& aCallResult, RootedDictionary<UniFFIRustCallResult>& aReturnValue) {
    switch (aCallResult.mCallStatus.code) {
        case uniffi::CALL_SUCCESS: {
            // Successful call.  Populate data with the return value
            aReturnValue.mCode = uniffi::CALL_SUCCESS;
            // RustBuffer return, convert it to an ArrayBuffer
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mReturnValue).intoArrayBuffer(aContext));
            break;
        }

        case uniffi::CALL_ERROR:
            // Rust Err() value.  Populate data with the `RustBuffer` containing the error
            aReturnValue.mCode = uniffi::CALL_ERROR;
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mCallStatus.error_buf).intoArrayBuffer(aContext));
            break;

        default:
            // This indicates a RustError, which shouldn't happen in practice since FF sets panic=abort
            aReturnValue.mCode = uniffi::CALL_INTERNAL_ERROR;
            aReturnValue.mInternalErrorMessage.AssignLiteral(u"Unexpected Error");
            break;
    }
}
}
// For each Rust scaffolding function, define types and functions for calling it
namespace rondpoint_9336_copie_enumeration {
using namespace mozilla::dom;
// Arguments to pass to the scaffolding function
struct Args {
    // RustBuffer arguments are stored as OwnedRustBuffer instances.  That class takes care of
    // freeing the buffer if the arguments don't get passed to Rust (i.e. intoRustBuffer()
    // isn't called).  This can happen if some of the ArrayBuffer arguments are succuessfully
    // converted, but one fails to convert.
    mozilla::dom::OwnedRustBuffer e;
};

// Return values from the scaffolding function
struct Result {
    RustBuffer mReturnValue;
    RustCallStatus mCallStatus = {};
};

// Convert the arguments we get from JS to arguments to pass to Rust.
//
// On error, an error code will be stored in result.  Make sure to check this before
// passing the args to Invoke().
//
// For async calls this should be called in the main thread, since the GC can
// move the ArrayBuffer pointers while the background task is waiting.
Args PrepareArgs(const ArrayBuffer& e,
    mozilla::ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args
    Args uniFFIArgs;
    // Convert the ArrayBuffer we get from JS to an OwnedRustBuffer
    e.ComputeState();
    uniFFIArgs.e = OwnedRustBuffer(e, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return uniFFIArgs;
    }

    return uniFFIArgs;
}

// Call the scaffolding function
//
// For async calls this should be called in the worker thread
Result Invoke(Args& aArgs) {
    Result result = {};result.mReturnValue =::rondpoint_9336_copie_enumeration(
         // Call intoRustBuffer() to get a `RustBuffer` from an OwnedRustBuffer.  This transfers ownership to Rust,
         // OwnedRustBuffer will no longer try to free it
         aArgs.e.intoRustBuffer(),
         &result.mCallStatus
     );
    return result;
}

// Return the result of the scaffolding call back to JS
void ReturnResult(JSContext* aContext, const Result& aCallResult, RootedDictionary<UniFFIRustCallResult>& aReturnValue) {
    switch (aCallResult.mCallStatus.code) {
        case uniffi::CALL_SUCCESS: {
            // Successful call.  Populate data with the return value
            aReturnValue.mCode = uniffi::CALL_SUCCESS;
            // RustBuffer return, convert it to an ArrayBuffer
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mReturnValue).intoArrayBuffer(aContext));
            break;
        }

        case uniffi::CALL_ERROR:
            // Rust Err() value.  Populate data with the `RustBuffer` containing the error
            aReturnValue.mCode = uniffi::CALL_ERROR;
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mCallStatus.error_buf).intoArrayBuffer(aContext));
            break;

        default:
            // This indicates a RustError, which shouldn't happen in practice since FF sets panic=abort
            aReturnValue.mCode = uniffi::CALL_INTERNAL_ERROR;
            aReturnValue.mInternalErrorMessage.AssignLiteral(u"Unexpected Error");
            break;
    }
}
}
// For each Rust scaffolding function, define types and functions for calling it
namespace rondpoint_9336_copie_enumerations {
using namespace mozilla::dom;
// Arguments to pass to the scaffolding function
struct Args {
    // RustBuffer arguments are stored as OwnedRustBuffer instances.  That class takes care of
    // freeing the buffer if the arguments don't get passed to Rust (i.e. intoRustBuffer()
    // isn't called).  This can happen if some of the ArrayBuffer arguments are succuessfully
    // converted, but one fails to convert.
    mozilla::dom::OwnedRustBuffer e;
};

// Return values from the scaffolding function
struct Result {
    RustBuffer mReturnValue;
    RustCallStatus mCallStatus = {};
};

// Convert the arguments we get from JS to arguments to pass to Rust.
//
// On error, an error code will be stored in result.  Make sure to check this before
// passing the args to Invoke().
//
// For async calls this should be called in the main thread, since the GC can
// move the ArrayBuffer pointers while the background task is waiting.
Args PrepareArgs(const ArrayBuffer& e,
    mozilla::ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args
    Args uniFFIArgs;
    // Convert the ArrayBuffer we get from JS to an OwnedRustBuffer
    e.ComputeState();
    uniFFIArgs.e = OwnedRustBuffer(e, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return uniFFIArgs;
    }

    return uniFFIArgs;
}

// Call the scaffolding function
//
// For async calls this should be called in the worker thread
Result Invoke(Args& aArgs) {
    Result result = {};result.mReturnValue =::rondpoint_9336_copie_enumerations(
         // Call intoRustBuffer() to get a `RustBuffer` from an OwnedRustBuffer.  This transfers ownership to Rust,
         // OwnedRustBuffer will no longer try to free it
         aArgs.e.intoRustBuffer(),
         &result.mCallStatus
     );
    return result;
}

// Return the result of the scaffolding call back to JS
void ReturnResult(JSContext* aContext, const Result& aCallResult, RootedDictionary<UniFFIRustCallResult>& aReturnValue) {
    switch (aCallResult.mCallStatus.code) {
        case uniffi::CALL_SUCCESS: {
            // Successful call.  Populate data with the return value
            aReturnValue.mCode = uniffi::CALL_SUCCESS;
            // RustBuffer return, convert it to an ArrayBuffer
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mReturnValue).intoArrayBuffer(aContext));
            break;
        }

        case uniffi::CALL_ERROR:
            // Rust Err() value.  Populate data with the `RustBuffer` containing the error
            aReturnValue.mCode = uniffi::CALL_ERROR;
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mCallStatus.error_buf).intoArrayBuffer(aContext));
            break;

        default:
            // This indicates a RustError, which shouldn't happen in practice since FF sets panic=abort
            aReturnValue.mCode = uniffi::CALL_INTERNAL_ERROR;
            aReturnValue.mInternalErrorMessage.AssignLiteral(u"Unexpected Error");
            break;
    }
}
}
// For each Rust scaffolding function, define types and functions for calling it
namespace rondpoint_9336_copie_carte {
using namespace mozilla::dom;
// Arguments to pass to the scaffolding function
struct Args {
    // RustBuffer arguments are stored as OwnedRustBuffer instances.  That class takes care of
    // freeing the buffer if the arguments don't get passed to Rust (i.e. intoRustBuffer()
    // isn't called).  This can happen if some of the ArrayBuffer arguments are succuessfully
    // converted, but one fails to convert.
    mozilla::dom::OwnedRustBuffer c;
};

// Return values from the scaffolding function
struct Result {
    RustBuffer mReturnValue;
    RustCallStatus mCallStatus = {};
};

// Convert the arguments we get from JS to arguments to pass to Rust.
//
// On error, an error code will be stored in result.  Make sure to check this before
// passing the args to Invoke().
//
// For async calls this should be called in the main thread, since the GC can
// move the ArrayBuffer pointers while the background task is waiting.
Args PrepareArgs(const ArrayBuffer& c,
    mozilla::ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args
    Args uniFFIArgs;
    // Convert the ArrayBuffer we get from JS to an OwnedRustBuffer
    c.ComputeState();
    uniFFIArgs.c = OwnedRustBuffer(c, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return uniFFIArgs;
    }

    return uniFFIArgs;
}

// Call the scaffolding function
//
// For async calls this should be called in the worker thread
Result Invoke(Args& aArgs) {
    Result result = {};result.mReturnValue =::rondpoint_9336_copie_carte(
         // Call intoRustBuffer() to get a `RustBuffer` from an OwnedRustBuffer.  This transfers ownership to Rust,
         // OwnedRustBuffer will no longer try to free it
         aArgs.c.intoRustBuffer(),
         &result.mCallStatus
     );
    return result;
}

// Return the result of the scaffolding call back to JS
void ReturnResult(JSContext* aContext, const Result& aCallResult, RootedDictionary<UniFFIRustCallResult>& aReturnValue) {
    switch (aCallResult.mCallStatus.code) {
        case uniffi::CALL_SUCCESS: {
            // Successful call.  Populate data with the return value
            aReturnValue.mCode = uniffi::CALL_SUCCESS;
            // RustBuffer return, convert it to an ArrayBuffer
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mReturnValue).intoArrayBuffer(aContext));
            break;
        }

        case uniffi::CALL_ERROR:
            // Rust Err() value.  Populate data with the `RustBuffer` containing the error
            aReturnValue.mCode = uniffi::CALL_ERROR;
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mCallStatus.error_buf).intoArrayBuffer(aContext));
            break;

        default:
            // This indicates a RustError, which shouldn't happen in practice since FF sets panic=abort
            aReturnValue.mCode = uniffi::CALL_INTERNAL_ERROR;
            aReturnValue.mInternalErrorMessage.AssignLiteral(u"Unexpected Error");
            break;
    }
}
}
// For each Rust scaffolding function, define types and functions for calling it
namespace rondpoint_9336_switcheroo {
using namespace mozilla::dom;
// Arguments to pass to the scaffolding function
struct Args {
    int8_t b;
};

// Return values from the scaffolding function
struct Result {
    int8_t mReturnValue;
    RustCallStatus mCallStatus = {};
};

// Convert the arguments we get from JS to arguments to pass to Rust.
//
// On error, an error code will be stored in result.  Make sure to check this before
// passing the args to Invoke().
//
// For async calls this should be called in the main thread, since the GC can
// move the ArrayBuffer pointers while the background task is waiting.
Args PrepareArgs(const int8_t& b,
    mozilla::ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args
    Args uniFFIArgs;
    uniFFIArgs.b = b;

    return uniFFIArgs;
}

// Call the scaffolding function
//
// For async calls this should be called in the worker thread
Result Invoke(Args& aArgs) {
    Result result = {};result.mReturnValue =::rondpoint_9336_switcheroo(
         aArgs.b,
         &result.mCallStatus
     );
    return result;
}

// Return the result of the scaffolding call back to JS
void ReturnResult(JSContext* aContext, const Result& aCallResult, RootedDictionary<UniFFIRustCallResult>& aReturnValue) {
    switch (aCallResult.mCallStatus.code) {
        case uniffi::CALL_SUCCESS: {
            // Successful call.  Populate data with the return value
            aReturnValue.mCode = uniffi::CALL_SUCCESS;
            // Numeric Return
            aReturnValue.mData.setNumber(aCallResult.mReturnValue);
            break;
        }

        case uniffi::CALL_ERROR:
            // Rust Err() value.  Populate data with the `RustBuffer` containing the error
            aReturnValue.mCode = uniffi::CALL_ERROR;
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mCallStatus.error_buf).intoArrayBuffer(aContext));
            break;

        default:
            // This indicates a RustError, which shouldn't happen in practice since FF sets panic=abort
            aReturnValue.mCode = uniffi::CALL_INTERNAL_ERROR;
            aReturnValue.mInternalErrorMessage.AssignLiteral(u"Unexpected Error");
            break;
    }
}
}
}

namespace mozilla::dom {
using namespace uniffi::rondpoint;
already_AddRefed<Promise> RondpointScaffolding::FfiRondpoint9336RetourneurObjectFree(const GlobalObject& aUniFFIGlobal,const UniFFIPointer& ptr,
 ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args

    // Create the promise that we return to JS
    nsCOMPtr<nsIGlobalObject> uniFFIXPCOMGlobal = do_QueryInterface(aUniFFIGlobal.GetAsSupports());
    RefPtr<Promise> uniFFIReturnPromise = Promise::Create(uniFFIXPCOMGlobal, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Prepare arguments to pass to Rust
    auto uniFFIArgs = ffi_rondpoint_9336_retourneur_object_free::PrepareArgs(ptr, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Create a second promise that gets resolved by a background task that calls the scaffolding function
    using UniFFITaskPromise = MozPromise<ffi_rondpoint_9336_retourneur_object_free::Result, nsresult, true>;
    RefPtr uniFFITaskPromise = new UniFFITaskPromise::Private(__func__);
    nsresult uniFFIDispatchResult = NS_DispatchBackgroundTask(
            NS_NewRunnableFunction(
                "RondpointScaffolding::FfiRondpoint9336RetourneurObjectFree",
                [args = std::move(uniFFIArgs), uniFFITaskPromise]() mutable {
                auto result = ffi_rondpoint_9336_retourneur_object_free::Invoke(args);
                uniFFITaskPromise->Resolve(std::move(result), __func__);
            }),
            NS_DISPATCH_EVENT_MAY_BLOCK);
    if (NS_FAILED(uniFFIDispatchResult)) {
        uniFFITaskPromise->Reject(uniFFIDispatchResult, __func__);
    }

    // When the background task promise completes, resolve the JS promise
    uniFFITaskPromise->Then(GetCurrentSerialEventTarget(), __func__,
            [uniFFIXPCOMGlobal, uniFFIReturnPromise](UniFFITaskPromise::ResolveOrRejectValue&& aResult) {
            if (!aResult.IsResolve()) {
                uniFFIReturnPromise->MaybeRejectWithUnknownError("RondpointScaffolding::FfiRondpoint9336RetourneurObjectFree task dispatch failed");
                return;
            }

            AutoEntryScript aes(uniFFIXPCOMGlobal, "RondpointScaffolding::FfiRondpoint9336RetourneurObjectFree call resolve");
            RootedDictionary<UniFFIRustCallResult> returnValue(aes.cx());

            ffi_rondpoint_9336_retourneur_object_free::ReturnResult(aes.cx(), aResult.ResolveValue(), returnValue);
            uniFFIReturnPromise->MaybeResolve(returnValue);
            }
    );

    // Return the JS promise, using forget() to convert it to already_AddRefed
    return uniFFIReturnPromise.forget();
}
using namespace uniffi::rondpoint;
already_AddRefed<Promise> RondpointScaffolding::Rondpoint9336RetourneurNew(const GlobalObject& aUniFFIGlobal,
 ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args

    // Create the promise that we return to JS
    nsCOMPtr<nsIGlobalObject> uniFFIXPCOMGlobal = do_QueryInterface(aUniFFIGlobal.GetAsSupports());
    RefPtr<Promise> uniFFIReturnPromise = Promise::Create(uniFFIXPCOMGlobal, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Prepare arguments to pass to Rust
    auto uniFFIArgs = rondpoint_9336_retourneur_new::PrepareArgs(aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Create a second promise that gets resolved by a background task that calls the scaffolding function
    using UniFFITaskPromise = MozPromise<rondpoint_9336_retourneur_new::Result, nsresult, true>;
    RefPtr uniFFITaskPromise = new UniFFITaskPromise::Private(__func__);
    nsresult uniFFIDispatchResult = NS_DispatchBackgroundTask(
            NS_NewRunnableFunction(
                "RondpointScaffolding::Rondpoint9336RetourneurNew",
                [args = std::move(uniFFIArgs), uniFFITaskPromise]() mutable {
                auto result = rondpoint_9336_retourneur_new::Invoke(args);
                uniFFITaskPromise->Resolve(std::move(result), __func__);
            }),
            NS_DISPATCH_EVENT_MAY_BLOCK);
    if (NS_FAILED(uniFFIDispatchResult)) {
        uniFFITaskPromise->Reject(uniFFIDispatchResult, __func__);
    }

    // When the background task promise completes, resolve the JS promise
    uniFFITaskPromise->Then(GetCurrentSerialEventTarget(), __func__,
            [uniFFIXPCOMGlobal, uniFFIReturnPromise](UniFFITaskPromise::ResolveOrRejectValue&& aResult) {
            if (!aResult.IsResolve()) {
                uniFFIReturnPromise->MaybeRejectWithUnknownError("RondpointScaffolding::Rondpoint9336RetourneurNew task dispatch failed");
                return;
            }

            AutoEntryScript aes(uniFFIXPCOMGlobal, "RondpointScaffolding::Rondpoint9336RetourneurNew call resolve");
            RootedDictionary<UniFFIRustCallResult> returnValue(aes.cx());

            rondpoint_9336_retourneur_new::ReturnResult(aes.cx(), aResult.ResolveValue(), returnValue);
            uniFFIReturnPromise->MaybeResolve(returnValue);
            }
    );

    // Return the JS promise, using forget() to convert it to already_AddRefed
    return uniFFIReturnPromise.forget();
}
using namespace uniffi::rondpoint;
already_AddRefed<Promise> RondpointScaffolding::Rondpoint9336RetourneurIdentiqueI8(const GlobalObject& aUniFFIGlobal,const UniFFIPointer& ptr, const int8_t& value,
 ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args

    // Create the promise that we return to JS
    nsCOMPtr<nsIGlobalObject> uniFFIXPCOMGlobal = do_QueryInterface(aUniFFIGlobal.GetAsSupports());
    RefPtr<Promise> uniFFIReturnPromise = Promise::Create(uniFFIXPCOMGlobal, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Prepare arguments to pass to Rust
    auto uniFFIArgs = rondpoint_9336_retourneur_identique_i8::PrepareArgs(ptr, value, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Create a second promise that gets resolved by a background task that calls the scaffolding function
    using UniFFITaskPromise = MozPromise<rondpoint_9336_retourneur_identique_i8::Result, nsresult, true>;
    RefPtr uniFFITaskPromise = new UniFFITaskPromise::Private(__func__);
    nsresult uniFFIDispatchResult = NS_DispatchBackgroundTask(
            NS_NewRunnableFunction(
                "RondpointScaffolding::Rondpoint9336RetourneurIdentiqueI8",
                [args = std::move(uniFFIArgs), uniFFITaskPromise]() mutable {
                auto result = rondpoint_9336_retourneur_identique_i8::Invoke(args);
                uniFFITaskPromise->Resolve(std::move(result), __func__);
            }),
            NS_DISPATCH_EVENT_MAY_BLOCK);
    if (NS_FAILED(uniFFIDispatchResult)) {
        uniFFITaskPromise->Reject(uniFFIDispatchResult, __func__);
    }

    // When the background task promise completes, resolve the JS promise
    uniFFITaskPromise->Then(GetCurrentSerialEventTarget(), __func__,
            [uniFFIXPCOMGlobal, uniFFIReturnPromise](UniFFITaskPromise::ResolveOrRejectValue&& aResult) {
            if (!aResult.IsResolve()) {
                uniFFIReturnPromise->MaybeRejectWithUnknownError("RondpointScaffolding::Rondpoint9336RetourneurIdentiqueI8 task dispatch failed");
                return;
            }

            AutoEntryScript aes(uniFFIXPCOMGlobal, "RondpointScaffolding::Rondpoint9336RetourneurIdentiqueI8 call resolve");
            RootedDictionary<UniFFIRustCallResult> returnValue(aes.cx());

            rondpoint_9336_retourneur_identique_i8::ReturnResult(aes.cx(), aResult.ResolveValue(), returnValue);
            uniFFIReturnPromise->MaybeResolve(returnValue);
            }
    );

    // Return the JS promise, using forget() to convert it to already_AddRefed
    return uniFFIReturnPromise.forget();
}
using namespace uniffi::rondpoint;
already_AddRefed<Promise> RondpointScaffolding::Rondpoint9336RetourneurIdentiqueU8(const GlobalObject& aUniFFIGlobal,const UniFFIPointer& ptr, const uint8_t& value,
 ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args

    // Create the promise that we return to JS
    nsCOMPtr<nsIGlobalObject> uniFFIXPCOMGlobal = do_QueryInterface(aUniFFIGlobal.GetAsSupports());
    RefPtr<Promise> uniFFIReturnPromise = Promise::Create(uniFFIXPCOMGlobal, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Prepare arguments to pass to Rust
    auto uniFFIArgs = rondpoint_9336_retourneur_identique_u8::PrepareArgs(ptr, value, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Create a second promise that gets resolved by a background task that calls the scaffolding function
    using UniFFITaskPromise = MozPromise<rondpoint_9336_retourneur_identique_u8::Result, nsresult, true>;
    RefPtr uniFFITaskPromise = new UniFFITaskPromise::Private(__func__);
    nsresult uniFFIDispatchResult = NS_DispatchBackgroundTask(
            NS_NewRunnableFunction(
                "RondpointScaffolding::Rondpoint9336RetourneurIdentiqueU8",
                [args = std::move(uniFFIArgs), uniFFITaskPromise]() mutable {
                auto result = rondpoint_9336_retourneur_identique_u8::Invoke(args);
                uniFFITaskPromise->Resolve(std::move(result), __func__);
            }),
            NS_DISPATCH_EVENT_MAY_BLOCK);
    if (NS_FAILED(uniFFIDispatchResult)) {
        uniFFITaskPromise->Reject(uniFFIDispatchResult, __func__);
    }

    // When the background task promise completes, resolve the JS promise
    uniFFITaskPromise->Then(GetCurrentSerialEventTarget(), __func__,
            [uniFFIXPCOMGlobal, uniFFIReturnPromise](UniFFITaskPromise::ResolveOrRejectValue&& aResult) {
            if (!aResult.IsResolve()) {
                uniFFIReturnPromise->MaybeRejectWithUnknownError("RondpointScaffolding::Rondpoint9336RetourneurIdentiqueU8 task dispatch failed");
                return;
            }

            AutoEntryScript aes(uniFFIXPCOMGlobal, "RondpointScaffolding::Rondpoint9336RetourneurIdentiqueU8 call resolve");
            RootedDictionary<UniFFIRustCallResult> returnValue(aes.cx());

            rondpoint_9336_retourneur_identique_u8::ReturnResult(aes.cx(), aResult.ResolveValue(), returnValue);
            uniFFIReturnPromise->MaybeResolve(returnValue);
            }
    );

    // Return the JS promise, using forget() to convert it to already_AddRefed
    return uniFFIReturnPromise.forget();
}
using namespace uniffi::rondpoint;
already_AddRefed<Promise> RondpointScaffolding::Rondpoint9336RetourneurIdentiqueI16(const GlobalObject& aUniFFIGlobal,const UniFFIPointer& ptr, const int16_t& value,
 ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args

    // Create the promise that we return to JS
    nsCOMPtr<nsIGlobalObject> uniFFIXPCOMGlobal = do_QueryInterface(aUniFFIGlobal.GetAsSupports());
    RefPtr<Promise> uniFFIReturnPromise = Promise::Create(uniFFIXPCOMGlobal, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Prepare arguments to pass to Rust
    auto uniFFIArgs = rondpoint_9336_retourneur_identique_i16::PrepareArgs(ptr, value, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Create a second promise that gets resolved by a background task that calls the scaffolding function
    using UniFFITaskPromise = MozPromise<rondpoint_9336_retourneur_identique_i16::Result, nsresult, true>;
    RefPtr uniFFITaskPromise = new UniFFITaskPromise::Private(__func__);
    nsresult uniFFIDispatchResult = NS_DispatchBackgroundTask(
            NS_NewRunnableFunction(
                "RondpointScaffolding::Rondpoint9336RetourneurIdentiqueI16",
                [args = std::move(uniFFIArgs), uniFFITaskPromise]() mutable {
                auto result = rondpoint_9336_retourneur_identique_i16::Invoke(args);
                uniFFITaskPromise->Resolve(std::move(result), __func__);
            }),
            NS_DISPATCH_EVENT_MAY_BLOCK);
    if (NS_FAILED(uniFFIDispatchResult)) {
        uniFFITaskPromise->Reject(uniFFIDispatchResult, __func__);
    }

    // When the background task promise completes, resolve the JS promise
    uniFFITaskPromise->Then(GetCurrentSerialEventTarget(), __func__,
            [uniFFIXPCOMGlobal, uniFFIReturnPromise](UniFFITaskPromise::ResolveOrRejectValue&& aResult) {
            if (!aResult.IsResolve()) {
                uniFFIReturnPromise->MaybeRejectWithUnknownError("RondpointScaffolding::Rondpoint9336RetourneurIdentiqueI16 task dispatch failed");
                return;
            }

            AutoEntryScript aes(uniFFIXPCOMGlobal, "RondpointScaffolding::Rondpoint9336RetourneurIdentiqueI16 call resolve");
            RootedDictionary<UniFFIRustCallResult> returnValue(aes.cx());

            rondpoint_9336_retourneur_identique_i16::ReturnResult(aes.cx(), aResult.ResolveValue(), returnValue);
            uniFFIReturnPromise->MaybeResolve(returnValue);
            }
    );

    // Return the JS promise, using forget() to convert it to already_AddRefed
    return uniFFIReturnPromise.forget();
}
using namespace uniffi::rondpoint;
already_AddRefed<Promise> RondpointScaffolding::Rondpoint9336RetourneurIdentiqueU16(const GlobalObject& aUniFFIGlobal,const UniFFIPointer& ptr, const uint16_t& value,
 ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args

    // Create the promise that we return to JS
    nsCOMPtr<nsIGlobalObject> uniFFIXPCOMGlobal = do_QueryInterface(aUniFFIGlobal.GetAsSupports());
    RefPtr<Promise> uniFFIReturnPromise = Promise::Create(uniFFIXPCOMGlobal, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Prepare arguments to pass to Rust
    auto uniFFIArgs = rondpoint_9336_retourneur_identique_u16::PrepareArgs(ptr, value, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Create a second promise that gets resolved by a background task that calls the scaffolding function
    using UniFFITaskPromise = MozPromise<rondpoint_9336_retourneur_identique_u16::Result, nsresult, true>;
    RefPtr uniFFITaskPromise = new UniFFITaskPromise::Private(__func__);
    nsresult uniFFIDispatchResult = NS_DispatchBackgroundTask(
            NS_NewRunnableFunction(
                "RondpointScaffolding::Rondpoint9336RetourneurIdentiqueU16",
                [args = std::move(uniFFIArgs), uniFFITaskPromise]() mutable {
                auto result = rondpoint_9336_retourneur_identique_u16::Invoke(args);
                uniFFITaskPromise->Resolve(std::move(result), __func__);
            }),
            NS_DISPATCH_EVENT_MAY_BLOCK);
    if (NS_FAILED(uniFFIDispatchResult)) {
        uniFFITaskPromise->Reject(uniFFIDispatchResult, __func__);
    }

    // When the background task promise completes, resolve the JS promise
    uniFFITaskPromise->Then(GetCurrentSerialEventTarget(), __func__,
            [uniFFIXPCOMGlobal, uniFFIReturnPromise](UniFFITaskPromise::ResolveOrRejectValue&& aResult) {
            if (!aResult.IsResolve()) {
                uniFFIReturnPromise->MaybeRejectWithUnknownError("RondpointScaffolding::Rondpoint9336RetourneurIdentiqueU16 task dispatch failed");
                return;
            }

            AutoEntryScript aes(uniFFIXPCOMGlobal, "RondpointScaffolding::Rondpoint9336RetourneurIdentiqueU16 call resolve");
            RootedDictionary<UniFFIRustCallResult> returnValue(aes.cx());

            rondpoint_9336_retourneur_identique_u16::ReturnResult(aes.cx(), aResult.ResolveValue(), returnValue);
            uniFFIReturnPromise->MaybeResolve(returnValue);
            }
    );

    // Return the JS promise, using forget() to convert it to already_AddRefed
    return uniFFIReturnPromise.forget();
}
using namespace uniffi::rondpoint;
already_AddRefed<Promise> RondpointScaffolding::Rondpoint9336RetourneurIdentiqueI32(const GlobalObject& aUniFFIGlobal,const UniFFIPointer& ptr, const int32_t& value,
 ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args

    // Create the promise that we return to JS
    nsCOMPtr<nsIGlobalObject> uniFFIXPCOMGlobal = do_QueryInterface(aUniFFIGlobal.GetAsSupports());
    RefPtr<Promise> uniFFIReturnPromise = Promise::Create(uniFFIXPCOMGlobal, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Prepare arguments to pass to Rust
    auto uniFFIArgs = rondpoint_9336_retourneur_identique_i32::PrepareArgs(ptr, value, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Create a second promise that gets resolved by a background task that calls the scaffolding function
    using UniFFITaskPromise = MozPromise<rondpoint_9336_retourneur_identique_i32::Result, nsresult, true>;
    RefPtr uniFFITaskPromise = new UniFFITaskPromise::Private(__func__);
    nsresult uniFFIDispatchResult = NS_DispatchBackgroundTask(
            NS_NewRunnableFunction(
                "RondpointScaffolding::Rondpoint9336RetourneurIdentiqueI32",
                [args = std::move(uniFFIArgs), uniFFITaskPromise]() mutable {
                auto result = rondpoint_9336_retourneur_identique_i32::Invoke(args);
                uniFFITaskPromise->Resolve(std::move(result), __func__);
            }),
            NS_DISPATCH_EVENT_MAY_BLOCK);
    if (NS_FAILED(uniFFIDispatchResult)) {
        uniFFITaskPromise->Reject(uniFFIDispatchResult, __func__);
    }

    // When the background task promise completes, resolve the JS promise
    uniFFITaskPromise->Then(GetCurrentSerialEventTarget(), __func__,
            [uniFFIXPCOMGlobal, uniFFIReturnPromise](UniFFITaskPromise::ResolveOrRejectValue&& aResult) {
            if (!aResult.IsResolve()) {
                uniFFIReturnPromise->MaybeRejectWithUnknownError("RondpointScaffolding::Rondpoint9336RetourneurIdentiqueI32 task dispatch failed");
                return;
            }

            AutoEntryScript aes(uniFFIXPCOMGlobal, "RondpointScaffolding::Rondpoint9336RetourneurIdentiqueI32 call resolve");
            RootedDictionary<UniFFIRustCallResult> returnValue(aes.cx());

            rondpoint_9336_retourneur_identique_i32::ReturnResult(aes.cx(), aResult.ResolveValue(), returnValue);
            uniFFIReturnPromise->MaybeResolve(returnValue);
            }
    );

    // Return the JS promise, using forget() to convert it to already_AddRefed
    return uniFFIReturnPromise.forget();
}
using namespace uniffi::rondpoint;
already_AddRefed<Promise> RondpointScaffolding::Rondpoint9336RetourneurIdentiqueU32(const GlobalObject& aUniFFIGlobal,const UniFFIPointer& ptr, const uint32_t& value,
 ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args

    // Create the promise that we return to JS
    nsCOMPtr<nsIGlobalObject> uniFFIXPCOMGlobal = do_QueryInterface(aUniFFIGlobal.GetAsSupports());
    RefPtr<Promise> uniFFIReturnPromise = Promise::Create(uniFFIXPCOMGlobal, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Prepare arguments to pass to Rust
    auto uniFFIArgs = rondpoint_9336_retourneur_identique_u32::PrepareArgs(ptr, value, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Create a second promise that gets resolved by a background task that calls the scaffolding function
    using UniFFITaskPromise = MozPromise<rondpoint_9336_retourneur_identique_u32::Result, nsresult, true>;
    RefPtr uniFFITaskPromise = new UniFFITaskPromise::Private(__func__);
    nsresult uniFFIDispatchResult = NS_DispatchBackgroundTask(
            NS_NewRunnableFunction(
                "RondpointScaffolding::Rondpoint9336RetourneurIdentiqueU32",
                [args = std::move(uniFFIArgs), uniFFITaskPromise]() mutable {
                auto result = rondpoint_9336_retourneur_identique_u32::Invoke(args);
                uniFFITaskPromise->Resolve(std::move(result), __func__);
            }),
            NS_DISPATCH_EVENT_MAY_BLOCK);
    if (NS_FAILED(uniFFIDispatchResult)) {
        uniFFITaskPromise->Reject(uniFFIDispatchResult, __func__);
    }

    // When the background task promise completes, resolve the JS promise
    uniFFITaskPromise->Then(GetCurrentSerialEventTarget(), __func__,
            [uniFFIXPCOMGlobal, uniFFIReturnPromise](UniFFITaskPromise::ResolveOrRejectValue&& aResult) {
            if (!aResult.IsResolve()) {
                uniFFIReturnPromise->MaybeRejectWithUnknownError("RondpointScaffolding::Rondpoint9336RetourneurIdentiqueU32 task dispatch failed");
                return;
            }

            AutoEntryScript aes(uniFFIXPCOMGlobal, "RondpointScaffolding::Rondpoint9336RetourneurIdentiqueU32 call resolve");
            RootedDictionary<UniFFIRustCallResult> returnValue(aes.cx());

            rondpoint_9336_retourneur_identique_u32::ReturnResult(aes.cx(), aResult.ResolveValue(), returnValue);
            uniFFIReturnPromise->MaybeResolve(returnValue);
            }
    );

    // Return the JS promise, using forget() to convert it to already_AddRefed
    return uniFFIReturnPromise.forget();
}
using namespace uniffi::rondpoint;
already_AddRefed<Promise> RondpointScaffolding::Rondpoint9336RetourneurIdentiqueI64(const GlobalObject& aUniFFIGlobal,const UniFFIPointer& ptr, const int64_t& value,
 ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args

    // Create the promise that we return to JS
    nsCOMPtr<nsIGlobalObject> uniFFIXPCOMGlobal = do_QueryInterface(aUniFFIGlobal.GetAsSupports());
    RefPtr<Promise> uniFFIReturnPromise = Promise::Create(uniFFIXPCOMGlobal, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Prepare arguments to pass to Rust
    auto uniFFIArgs = rondpoint_9336_retourneur_identique_i64::PrepareArgs(ptr, value, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Create a second promise that gets resolved by a background task that calls the scaffolding function
    using UniFFITaskPromise = MozPromise<rondpoint_9336_retourneur_identique_i64::Result, nsresult, true>;
    RefPtr uniFFITaskPromise = new UniFFITaskPromise::Private(__func__);
    nsresult uniFFIDispatchResult = NS_DispatchBackgroundTask(
            NS_NewRunnableFunction(
                "RondpointScaffolding::Rondpoint9336RetourneurIdentiqueI64",
                [args = std::move(uniFFIArgs), uniFFITaskPromise]() mutable {
                auto result = rondpoint_9336_retourneur_identique_i64::Invoke(args);
                uniFFITaskPromise->Resolve(std::move(result), __func__);
            }),
            NS_DISPATCH_EVENT_MAY_BLOCK);
    if (NS_FAILED(uniFFIDispatchResult)) {
        uniFFITaskPromise->Reject(uniFFIDispatchResult, __func__);
    }

    // When the background task promise completes, resolve the JS promise
    uniFFITaskPromise->Then(GetCurrentSerialEventTarget(), __func__,
            [uniFFIXPCOMGlobal, uniFFIReturnPromise](UniFFITaskPromise::ResolveOrRejectValue&& aResult) {
            if (!aResult.IsResolve()) {
                uniFFIReturnPromise->MaybeRejectWithUnknownError("RondpointScaffolding::Rondpoint9336RetourneurIdentiqueI64 task dispatch failed");
                return;
            }

            AutoEntryScript aes(uniFFIXPCOMGlobal, "RondpointScaffolding::Rondpoint9336RetourneurIdentiqueI64 call resolve");
            RootedDictionary<UniFFIRustCallResult> returnValue(aes.cx());

            rondpoint_9336_retourneur_identique_i64::ReturnResult(aes.cx(), aResult.ResolveValue(), returnValue);
            uniFFIReturnPromise->MaybeResolve(returnValue);
            }
    );

    // Return the JS promise, using forget() to convert it to already_AddRefed
    return uniFFIReturnPromise.forget();
}
using namespace uniffi::rondpoint;
already_AddRefed<Promise> RondpointScaffolding::Rondpoint9336RetourneurIdentiqueU64(const GlobalObject& aUniFFIGlobal,const UniFFIPointer& ptr, const uint64_t& value,
 ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args

    // Create the promise that we return to JS
    nsCOMPtr<nsIGlobalObject> uniFFIXPCOMGlobal = do_QueryInterface(aUniFFIGlobal.GetAsSupports());
    RefPtr<Promise> uniFFIReturnPromise = Promise::Create(uniFFIXPCOMGlobal, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Prepare arguments to pass to Rust
    auto uniFFIArgs = rondpoint_9336_retourneur_identique_u64::PrepareArgs(ptr, value, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Create a second promise that gets resolved by a background task that calls the scaffolding function
    using UniFFITaskPromise = MozPromise<rondpoint_9336_retourneur_identique_u64::Result, nsresult, true>;
    RefPtr uniFFITaskPromise = new UniFFITaskPromise::Private(__func__);
    nsresult uniFFIDispatchResult = NS_DispatchBackgroundTask(
            NS_NewRunnableFunction(
                "RondpointScaffolding::Rondpoint9336RetourneurIdentiqueU64",
                [args = std::move(uniFFIArgs), uniFFITaskPromise]() mutable {
                auto result = rondpoint_9336_retourneur_identique_u64::Invoke(args);
                uniFFITaskPromise->Resolve(std::move(result), __func__);
            }),
            NS_DISPATCH_EVENT_MAY_BLOCK);
    if (NS_FAILED(uniFFIDispatchResult)) {
        uniFFITaskPromise->Reject(uniFFIDispatchResult, __func__);
    }

    // When the background task promise completes, resolve the JS promise
    uniFFITaskPromise->Then(GetCurrentSerialEventTarget(), __func__,
            [uniFFIXPCOMGlobal, uniFFIReturnPromise](UniFFITaskPromise::ResolveOrRejectValue&& aResult) {
            if (!aResult.IsResolve()) {
                uniFFIReturnPromise->MaybeRejectWithUnknownError("RondpointScaffolding::Rondpoint9336RetourneurIdentiqueU64 task dispatch failed");
                return;
            }

            AutoEntryScript aes(uniFFIXPCOMGlobal, "RondpointScaffolding::Rondpoint9336RetourneurIdentiqueU64 call resolve");
            RootedDictionary<UniFFIRustCallResult> returnValue(aes.cx());

            rondpoint_9336_retourneur_identique_u64::ReturnResult(aes.cx(), aResult.ResolveValue(), returnValue);
            uniFFIReturnPromise->MaybeResolve(returnValue);
            }
    );

    // Return the JS promise, using forget() to convert it to already_AddRefed
    return uniFFIReturnPromise.forget();
}
using namespace uniffi::rondpoint;
already_AddRefed<Promise> RondpointScaffolding::Rondpoint9336RetourneurIdentiqueFloat(const GlobalObject& aUniFFIGlobal,const UniFFIPointer& ptr, const float& value,
 ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args

    // Create the promise that we return to JS
    nsCOMPtr<nsIGlobalObject> uniFFIXPCOMGlobal = do_QueryInterface(aUniFFIGlobal.GetAsSupports());
    RefPtr<Promise> uniFFIReturnPromise = Promise::Create(uniFFIXPCOMGlobal, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Prepare arguments to pass to Rust
    auto uniFFIArgs = rondpoint_9336_retourneur_identique_float::PrepareArgs(ptr, value, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Create a second promise that gets resolved by a background task that calls the scaffolding function
    using UniFFITaskPromise = MozPromise<rondpoint_9336_retourneur_identique_float::Result, nsresult, true>;
    RefPtr uniFFITaskPromise = new UniFFITaskPromise::Private(__func__);
    nsresult uniFFIDispatchResult = NS_DispatchBackgroundTask(
            NS_NewRunnableFunction(
                "RondpointScaffolding::Rondpoint9336RetourneurIdentiqueFloat",
                [args = std::move(uniFFIArgs), uniFFITaskPromise]() mutable {
                auto result = rondpoint_9336_retourneur_identique_float::Invoke(args);
                uniFFITaskPromise->Resolve(std::move(result), __func__);
            }),
            NS_DISPATCH_EVENT_MAY_BLOCK);
    if (NS_FAILED(uniFFIDispatchResult)) {
        uniFFITaskPromise->Reject(uniFFIDispatchResult, __func__);
    }

    // When the background task promise completes, resolve the JS promise
    uniFFITaskPromise->Then(GetCurrentSerialEventTarget(), __func__,
            [uniFFIXPCOMGlobal, uniFFIReturnPromise](UniFFITaskPromise::ResolveOrRejectValue&& aResult) {
            if (!aResult.IsResolve()) {
                uniFFIReturnPromise->MaybeRejectWithUnknownError("RondpointScaffolding::Rondpoint9336RetourneurIdentiqueFloat task dispatch failed");
                return;
            }

            AutoEntryScript aes(uniFFIXPCOMGlobal, "RondpointScaffolding::Rondpoint9336RetourneurIdentiqueFloat call resolve");
            RootedDictionary<UniFFIRustCallResult> returnValue(aes.cx());

            rondpoint_9336_retourneur_identique_float::ReturnResult(aes.cx(), aResult.ResolveValue(), returnValue);
            uniFFIReturnPromise->MaybeResolve(returnValue);
            }
    );

    // Return the JS promise, using forget() to convert it to already_AddRefed
    return uniFFIReturnPromise.forget();
}
using namespace uniffi::rondpoint;
already_AddRefed<Promise> RondpointScaffolding::Rondpoint9336RetourneurIdentiqueDouble(const GlobalObject& aUniFFIGlobal,const UniFFIPointer& ptr, const double& value,
 ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args

    // Create the promise that we return to JS
    nsCOMPtr<nsIGlobalObject> uniFFIXPCOMGlobal = do_QueryInterface(aUniFFIGlobal.GetAsSupports());
    RefPtr<Promise> uniFFIReturnPromise = Promise::Create(uniFFIXPCOMGlobal, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Prepare arguments to pass to Rust
    auto uniFFIArgs = rondpoint_9336_retourneur_identique_double::PrepareArgs(ptr, value, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Create a second promise that gets resolved by a background task that calls the scaffolding function
    using UniFFITaskPromise = MozPromise<rondpoint_9336_retourneur_identique_double::Result, nsresult, true>;
    RefPtr uniFFITaskPromise = new UniFFITaskPromise::Private(__func__);
    nsresult uniFFIDispatchResult = NS_DispatchBackgroundTask(
            NS_NewRunnableFunction(
                "RondpointScaffolding::Rondpoint9336RetourneurIdentiqueDouble",
                [args = std::move(uniFFIArgs), uniFFITaskPromise]() mutable {
                auto result = rondpoint_9336_retourneur_identique_double::Invoke(args);
                uniFFITaskPromise->Resolve(std::move(result), __func__);
            }),
            NS_DISPATCH_EVENT_MAY_BLOCK);
    if (NS_FAILED(uniFFIDispatchResult)) {
        uniFFITaskPromise->Reject(uniFFIDispatchResult, __func__);
    }

    // When the background task promise completes, resolve the JS promise
    uniFFITaskPromise->Then(GetCurrentSerialEventTarget(), __func__,
            [uniFFIXPCOMGlobal, uniFFIReturnPromise](UniFFITaskPromise::ResolveOrRejectValue&& aResult) {
            if (!aResult.IsResolve()) {
                uniFFIReturnPromise->MaybeRejectWithUnknownError("RondpointScaffolding::Rondpoint9336RetourneurIdentiqueDouble task dispatch failed");
                return;
            }

            AutoEntryScript aes(uniFFIXPCOMGlobal, "RondpointScaffolding::Rondpoint9336RetourneurIdentiqueDouble call resolve");
            RootedDictionary<UniFFIRustCallResult> returnValue(aes.cx());

            rondpoint_9336_retourneur_identique_double::ReturnResult(aes.cx(), aResult.ResolveValue(), returnValue);
            uniFFIReturnPromise->MaybeResolve(returnValue);
            }
    );

    // Return the JS promise, using forget() to convert it to already_AddRefed
    return uniFFIReturnPromise.forget();
}
using namespace uniffi::rondpoint;
already_AddRefed<Promise> RondpointScaffolding::Rondpoint9336RetourneurIdentiqueBoolean(const GlobalObject& aUniFFIGlobal,const UniFFIPointer& ptr, const int8_t& value,
 ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args

    // Create the promise that we return to JS
    nsCOMPtr<nsIGlobalObject> uniFFIXPCOMGlobal = do_QueryInterface(aUniFFIGlobal.GetAsSupports());
    RefPtr<Promise> uniFFIReturnPromise = Promise::Create(uniFFIXPCOMGlobal, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Prepare arguments to pass to Rust
    auto uniFFIArgs = rondpoint_9336_retourneur_identique_boolean::PrepareArgs(ptr, value, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Create a second promise that gets resolved by a background task that calls the scaffolding function
    using UniFFITaskPromise = MozPromise<rondpoint_9336_retourneur_identique_boolean::Result, nsresult, true>;
    RefPtr uniFFITaskPromise = new UniFFITaskPromise::Private(__func__);
    nsresult uniFFIDispatchResult = NS_DispatchBackgroundTask(
            NS_NewRunnableFunction(
                "RondpointScaffolding::Rondpoint9336RetourneurIdentiqueBoolean",
                [args = std::move(uniFFIArgs), uniFFITaskPromise]() mutable {
                auto result = rondpoint_9336_retourneur_identique_boolean::Invoke(args);
                uniFFITaskPromise->Resolve(std::move(result), __func__);
            }),
            NS_DISPATCH_EVENT_MAY_BLOCK);
    if (NS_FAILED(uniFFIDispatchResult)) {
        uniFFITaskPromise->Reject(uniFFIDispatchResult, __func__);
    }

    // When the background task promise completes, resolve the JS promise
    uniFFITaskPromise->Then(GetCurrentSerialEventTarget(), __func__,
            [uniFFIXPCOMGlobal, uniFFIReturnPromise](UniFFITaskPromise::ResolveOrRejectValue&& aResult) {
            if (!aResult.IsResolve()) {
                uniFFIReturnPromise->MaybeRejectWithUnknownError("RondpointScaffolding::Rondpoint9336RetourneurIdentiqueBoolean task dispatch failed");
                return;
            }

            AutoEntryScript aes(uniFFIXPCOMGlobal, "RondpointScaffolding::Rondpoint9336RetourneurIdentiqueBoolean call resolve");
            RootedDictionary<UniFFIRustCallResult> returnValue(aes.cx());

            rondpoint_9336_retourneur_identique_boolean::ReturnResult(aes.cx(), aResult.ResolveValue(), returnValue);
            uniFFIReturnPromise->MaybeResolve(returnValue);
            }
    );

    // Return the JS promise, using forget() to convert it to already_AddRefed
    return uniFFIReturnPromise.forget();
}
using namespace uniffi::rondpoint;
already_AddRefed<Promise> RondpointScaffolding::Rondpoint9336RetourneurIdentiqueString(const GlobalObject& aUniFFIGlobal,const UniFFIPointer& ptr, const ArrayBuffer& value,
 ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args

    // Create the promise that we return to JS
    nsCOMPtr<nsIGlobalObject> uniFFIXPCOMGlobal = do_QueryInterface(aUniFFIGlobal.GetAsSupports());
    RefPtr<Promise> uniFFIReturnPromise = Promise::Create(uniFFIXPCOMGlobal, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Prepare arguments to pass to Rust
    auto uniFFIArgs = rondpoint_9336_retourneur_identique_string::PrepareArgs(ptr, value, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Create a second promise that gets resolved by a background task that calls the scaffolding function
    using UniFFITaskPromise = MozPromise<rondpoint_9336_retourneur_identique_string::Result, nsresult, true>;
    RefPtr uniFFITaskPromise = new UniFFITaskPromise::Private(__func__);
    nsresult uniFFIDispatchResult = NS_DispatchBackgroundTask(
            NS_NewRunnableFunction(
                "RondpointScaffolding::Rondpoint9336RetourneurIdentiqueString",
                [args = std::move(uniFFIArgs), uniFFITaskPromise]() mutable {
                auto result = rondpoint_9336_retourneur_identique_string::Invoke(args);
                uniFFITaskPromise->Resolve(std::move(result), __func__);
            }),
            NS_DISPATCH_EVENT_MAY_BLOCK);
    if (NS_FAILED(uniFFIDispatchResult)) {
        uniFFITaskPromise->Reject(uniFFIDispatchResult, __func__);
    }

    // When the background task promise completes, resolve the JS promise
    uniFFITaskPromise->Then(GetCurrentSerialEventTarget(), __func__,
            [uniFFIXPCOMGlobal, uniFFIReturnPromise](UniFFITaskPromise::ResolveOrRejectValue&& aResult) {
            if (!aResult.IsResolve()) {
                uniFFIReturnPromise->MaybeRejectWithUnknownError("RondpointScaffolding::Rondpoint9336RetourneurIdentiqueString task dispatch failed");
                return;
            }

            AutoEntryScript aes(uniFFIXPCOMGlobal, "RondpointScaffolding::Rondpoint9336RetourneurIdentiqueString call resolve");
            RootedDictionary<UniFFIRustCallResult> returnValue(aes.cx());

            rondpoint_9336_retourneur_identique_string::ReturnResult(aes.cx(), aResult.ResolveValue(), returnValue);
            uniFFIReturnPromise->MaybeResolve(returnValue);
            }
    );

    // Return the JS promise, using forget() to convert it to already_AddRefed
    return uniFFIReturnPromise.forget();
}
using namespace uniffi::rondpoint;
already_AddRefed<Promise> RondpointScaffolding::Rondpoint9336RetourneurIdentiqueNombresSignes(const GlobalObject& aUniFFIGlobal,const UniFFIPointer& ptr, const ArrayBuffer& value,
 ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args

    // Create the promise that we return to JS
    nsCOMPtr<nsIGlobalObject> uniFFIXPCOMGlobal = do_QueryInterface(aUniFFIGlobal.GetAsSupports());
    RefPtr<Promise> uniFFIReturnPromise = Promise::Create(uniFFIXPCOMGlobal, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Prepare arguments to pass to Rust
    auto uniFFIArgs = rondpoint_9336_retourneur_identique_nombres_signes::PrepareArgs(ptr, value, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Create a second promise that gets resolved by a background task that calls the scaffolding function
    using UniFFITaskPromise = MozPromise<rondpoint_9336_retourneur_identique_nombres_signes::Result, nsresult, true>;
    RefPtr uniFFITaskPromise = new UniFFITaskPromise::Private(__func__);
    nsresult uniFFIDispatchResult = NS_DispatchBackgroundTask(
            NS_NewRunnableFunction(
                "RondpointScaffolding::Rondpoint9336RetourneurIdentiqueNombresSignes",
                [args = std::move(uniFFIArgs), uniFFITaskPromise]() mutable {
                auto result = rondpoint_9336_retourneur_identique_nombres_signes::Invoke(args);
                uniFFITaskPromise->Resolve(std::move(result), __func__);
            }),
            NS_DISPATCH_EVENT_MAY_BLOCK);
    if (NS_FAILED(uniFFIDispatchResult)) {
        uniFFITaskPromise->Reject(uniFFIDispatchResult, __func__);
    }

    // When the background task promise completes, resolve the JS promise
    uniFFITaskPromise->Then(GetCurrentSerialEventTarget(), __func__,
            [uniFFIXPCOMGlobal, uniFFIReturnPromise](UniFFITaskPromise::ResolveOrRejectValue&& aResult) {
            if (!aResult.IsResolve()) {
                uniFFIReturnPromise->MaybeRejectWithUnknownError("RondpointScaffolding::Rondpoint9336RetourneurIdentiqueNombresSignes task dispatch failed");
                return;
            }

            AutoEntryScript aes(uniFFIXPCOMGlobal, "RondpointScaffolding::Rondpoint9336RetourneurIdentiqueNombresSignes call resolve");
            RootedDictionary<UniFFIRustCallResult> returnValue(aes.cx());

            rondpoint_9336_retourneur_identique_nombres_signes::ReturnResult(aes.cx(), aResult.ResolveValue(), returnValue);
            uniFFIReturnPromise->MaybeResolve(returnValue);
            }
    );

    // Return the JS promise, using forget() to convert it to already_AddRefed
    return uniFFIReturnPromise.forget();
}
using namespace uniffi::rondpoint;
already_AddRefed<Promise> RondpointScaffolding::Rondpoint9336RetourneurIdentiqueNombres(const GlobalObject& aUniFFIGlobal,const UniFFIPointer& ptr, const ArrayBuffer& value,
 ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args

    // Create the promise that we return to JS
    nsCOMPtr<nsIGlobalObject> uniFFIXPCOMGlobal = do_QueryInterface(aUniFFIGlobal.GetAsSupports());
    RefPtr<Promise> uniFFIReturnPromise = Promise::Create(uniFFIXPCOMGlobal, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Prepare arguments to pass to Rust
    auto uniFFIArgs = rondpoint_9336_retourneur_identique_nombres::PrepareArgs(ptr, value, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Create a second promise that gets resolved by a background task that calls the scaffolding function
    using UniFFITaskPromise = MozPromise<rondpoint_9336_retourneur_identique_nombres::Result, nsresult, true>;
    RefPtr uniFFITaskPromise = new UniFFITaskPromise::Private(__func__);
    nsresult uniFFIDispatchResult = NS_DispatchBackgroundTask(
            NS_NewRunnableFunction(
                "RondpointScaffolding::Rondpoint9336RetourneurIdentiqueNombres",
                [args = std::move(uniFFIArgs), uniFFITaskPromise]() mutable {
                auto result = rondpoint_9336_retourneur_identique_nombres::Invoke(args);
                uniFFITaskPromise->Resolve(std::move(result), __func__);
            }),
            NS_DISPATCH_EVENT_MAY_BLOCK);
    if (NS_FAILED(uniFFIDispatchResult)) {
        uniFFITaskPromise->Reject(uniFFIDispatchResult, __func__);
    }

    // When the background task promise completes, resolve the JS promise
    uniFFITaskPromise->Then(GetCurrentSerialEventTarget(), __func__,
            [uniFFIXPCOMGlobal, uniFFIReturnPromise](UniFFITaskPromise::ResolveOrRejectValue&& aResult) {
            if (!aResult.IsResolve()) {
                uniFFIReturnPromise->MaybeRejectWithUnknownError("RondpointScaffolding::Rondpoint9336RetourneurIdentiqueNombres task dispatch failed");
                return;
            }

            AutoEntryScript aes(uniFFIXPCOMGlobal, "RondpointScaffolding::Rondpoint9336RetourneurIdentiqueNombres call resolve");
            RootedDictionary<UniFFIRustCallResult> returnValue(aes.cx());

            rondpoint_9336_retourneur_identique_nombres::ReturnResult(aes.cx(), aResult.ResolveValue(), returnValue);
            uniFFIReturnPromise->MaybeResolve(returnValue);
            }
    );

    // Return the JS promise, using forget() to convert it to already_AddRefed
    return uniFFIReturnPromise.forget();
}
using namespace uniffi::rondpoint;
already_AddRefed<Promise> RondpointScaffolding::Rondpoint9336RetourneurIdentiqueOptionneurDictionnaire(const GlobalObject& aUniFFIGlobal,const UniFFIPointer& ptr, const ArrayBuffer& value,
 ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args

    // Create the promise that we return to JS
    nsCOMPtr<nsIGlobalObject> uniFFIXPCOMGlobal = do_QueryInterface(aUniFFIGlobal.GetAsSupports());
    RefPtr<Promise> uniFFIReturnPromise = Promise::Create(uniFFIXPCOMGlobal, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Prepare arguments to pass to Rust
    auto uniFFIArgs = rondpoint_9336_retourneur_identique_optionneur_dictionnaire::PrepareArgs(ptr, value, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Create a second promise that gets resolved by a background task that calls the scaffolding function
    using UniFFITaskPromise = MozPromise<rondpoint_9336_retourneur_identique_optionneur_dictionnaire::Result, nsresult, true>;
    RefPtr uniFFITaskPromise = new UniFFITaskPromise::Private(__func__);
    nsresult uniFFIDispatchResult = NS_DispatchBackgroundTask(
            NS_NewRunnableFunction(
                "RondpointScaffolding::Rondpoint9336RetourneurIdentiqueOptionneurDictionnaire",
                [args = std::move(uniFFIArgs), uniFFITaskPromise]() mutable {
                auto result = rondpoint_9336_retourneur_identique_optionneur_dictionnaire::Invoke(args);
                uniFFITaskPromise->Resolve(std::move(result), __func__);
            }),
            NS_DISPATCH_EVENT_MAY_BLOCK);
    if (NS_FAILED(uniFFIDispatchResult)) {
        uniFFITaskPromise->Reject(uniFFIDispatchResult, __func__);
    }

    // When the background task promise completes, resolve the JS promise
    uniFFITaskPromise->Then(GetCurrentSerialEventTarget(), __func__,
            [uniFFIXPCOMGlobal, uniFFIReturnPromise](UniFFITaskPromise::ResolveOrRejectValue&& aResult) {
            if (!aResult.IsResolve()) {
                uniFFIReturnPromise->MaybeRejectWithUnknownError("RondpointScaffolding::Rondpoint9336RetourneurIdentiqueOptionneurDictionnaire task dispatch failed");
                return;
            }

            AutoEntryScript aes(uniFFIXPCOMGlobal, "RondpointScaffolding::Rondpoint9336RetourneurIdentiqueOptionneurDictionnaire call resolve");
            RootedDictionary<UniFFIRustCallResult> returnValue(aes.cx());

            rondpoint_9336_retourneur_identique_optionneur_dictionnaire::ReturnResult(aes.cx(), aResult.ResolveValue(), returnValue);
            uniFFIReturnPromise->MaybeResolve(returnValue);
            }
    );

    // Return the JS promise, using forget() to convert it to already_AddRefed
    return uniFFIReturnPromise.forget();
}
using namespace uniffi::rondpoint;
already_AddRefed<Promise> RondpointScaffolding::FfiRondpoint9336StringifierObjectFree(const GlobalObject& aUniFFIGlobal,const UniFFIPointer& ptr,
 ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args

    // Create the promise that we return to JS
    nsCOMPtr<nsIGlobalObject> uniFFIXPCOMGlobal = do_QueryInterface(aUniFFIGlobal.GetAsSupports());
    RefPtr<Promise> uniFFIReturnPromise = Promise::Create(uniFFIXPCOMGlobal, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Prepare arguments to pass to Rust
    auto uniFFIArgs = ffi_rondpoint_9336_stringifier_object_free::PrepareArgs(ptr, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Create a second promise that gets resolved by a background task that calls the scaffolding function
    using UniFFITaskPromise = MozPromise<ffi_rondpoint_9336_stringifier_object_free::Result, nsresult, true>;
    RefPtr uniFFITaskPromise = new UniFFITaskPromise::Private(__func__);
    nsresult uniFFIDispatchResult = NS_DispatchBackgroundTask(
            NS_NewRunnableFunction(
                "RondpointScaffolding::FfiRondpoint9336StringifierObjectFree",
                [args = std::move(uniFFIArgs), uniFFITaskPromise]() mutable {
                auto result = ffi_rondpoint_9336_stringifier_object_free::Invoke(args);
                uniFFITaskPromise->Resolve(std::move(result), __func__);
            }),
            NS_DISPATCH_EVENT_MAY_BLOCK);
    if (NS_FAILED(uniFFIDispatchResult)) {
        uniFFITaskPromise->Reject(uniFFIDispatchResult, __func__);
    }

    // When the background task promise completes, resolve the JS promise
    uniFFITaskPromise->Then(GetCurrentSerialEventTarget(), __func__,
            [uniFFIXPCOMGlobal, uniFFIReturnPromise](UniFFITaskPromise::ResolveOrRejectValue&& aResult) {
            if (!aResult.IsResolve()) {
                uniFFIReturnPromise->MaybeRejectWithUnknownError("RondpointScaffolding::FfiRondpoint9336StringifierObjectFree task dispatch failed");
                return;
            }

            AutoEntryScript aes(uniFFIXPCOMGlobal, "RondpointScaffolding::FfiRondpoint9336StringifierObjectFree call resolve");
            RootedDictionary<UniFFIRustCallResult> returnValue(aes.cx());

            ffi_rondpoint_9336_stringifier_object_free::ReturnResult(aes.cx(), aResult.ResolveValue(), returnValue);
            uniFFIReturnPromise->MaybeResolve(returnValue);
            }
    );

    // Return the JS promise, using forget() to convert it to already_AddRefed
    return uniFFIReturnPromise.forget();
}
using namespace uniffi::rondpoint;
already_AddRefed<Promise> RondpointScaffolding::Rondpoint9336StringifierNew(const GlobalObject& aUniFFIGlobal,
 ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args

    // Create the promise that we return to JS
    nsCOMPtr<nsIGlobalObject> uniFFIXPCOMGlobal = do_QueryInterface(aUniFFIGlobal.GetAsSupports());
    RefPtr<Promise> uniFFIReturnPromise = Promise::Create(uniFFIXPCOMGlobal, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Prepare arguments to pass to Rust
    auto uniFFIArgs = rondpoint_9336_stringifier_new::PrepareArgs(aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Create a second promise that gets resolved by a background task that calls the scaffolding function
    using UniFFITaskPromise = MozPromise<rondpoint_9336_stringifier_new::Result, nsresult, true>;
    RefPtr uniFFITaskPromise = new UniFFITaskPromise::Private(__func__);
    nsresult uniFFIDispatchResult = NS_DispatchBackgroundTask(
            NS_NewRunnableFunction(
                "RondpointScaffolding::Rondpoint9336StringifierNew",
                [args = std::move(uniFFIArgs), uniFFITaskPromise]() mutable {
                auto result = rondpoint_9336_stringifier_new::Invoke(args);
                uniFFITaskPromise->Resolve(std::move(result), __func__);
            }),
            NS_DISPATCH_EVENT_MAY_BLOCK);
    if (NS_FAILED(uniFFIDispatchResult)) {
        uniFFITaskPromise->Reject(uniFFIDispatchResult, __func__);
    }

    // When the background task promise completes, resolve the JS promise
    uniFFITaskPromise->Then(GetCurrentSerialEventTarget(), __func__,
            [uniFFIXPCOMGlobal, uniFFIReturnPromise](UniFFITaskPromise::ResolveOrRejectValue&& aResult) {
            if (!aResult.IsResolve()) {
                uniFFIReturnPromise->MaybeRejectWithUnknownError("RondpointScaffolding::Rondpoint9336StringifierNew task dispatch failed");
                return;
            }

            AutoEntryScript aes(uniFFIXPCOMGlobal, "RondpointScaffolding::Rondpoint9336StringifierNew call resolve");
            RootedDictionary<UniFFIRustCallResult> returnValue(aes.cx());

            rondpoint_9336_stringifier_new::ReturnResult(aes.cx(), aResult.ResolveValue(), returnValue);
            uniFFIReturnPromise->MaybeResolve(returnValue);
            }
    );

    // Return the JS promise, using forget() to convert it to already_AddRefed
    return uniFFIReturnPromise.forget();
}
using namespace uniffi::rondpoint;
already_AddRefed<Promise> RondpointScaffolding::Rondpoint9336StringifierWellKnownString(const GlobalObject& aUniFFIGlobal,const UniFFIPointer& ptr, const ArrayBuffer& value,
 ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args

    // Create the promise that we return to JS
    nsCOMPtr<nsIGlobalObject> uniFFIXPCOMGlobal = do_QueryInterface(aUniFFIGlobal.GetAsSupports());
    RefPtr<Promise> uniFFIReturnPromise = Promise::Create(uniFFIXPCOMGlobal, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Prepare arguments to pass to Rust
    auto uniFFIArgs = rondpoint_9336_stringifier_well_known_string::PrepareArgs(ptr, value, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Create a second promise that gets resolved by a background task that calls the scaffolding function
    using UniFFITaskPromise = MozPromise<rondpoint_9336_stringifier_well_known_string::Result, nsresult, true>;
    RefPtr uniFFITaskPromise = new UniFFITaskPromise::Private(__func__);
    nsresult uniFFIDispatchResult = NS_DispatchBackgroundTask(
            NS_NewRunnableFunction(
                "RondpointScaffolding::Rondpoint9336StringifierWellKnownString",
                [args = std::move(uniFFIArgs), uniFFITaskPromise]() mutable {
                auto result = rondpoint_9336_stringifier_well_known_string::Invoke(args);
                uniFFITaskPromise->Resolve(std::move(result), __func__);
            }),
            NS_DISPATCH_EVENT_MAY_BLOCK);
    if (NS_FAILED(uniFFIDispatchResult)) {
        uniFFITaskPromise->Reject(uniFFIDispatchResult, __func__);
    }

    // When the background task promise completes, resolve the JS promise
    uniFFITaskPromise->Then(GetCurrentSerialEventTarget(), __func__,
            [uniFFIXPCOMGlobal, uniFFIReturnPromise](UniFFITaskPromise::ResolveOrRejectValue&& aResult) {
            if (!aResult.IsResolve()) {
                uniFFIReturnPromise->MaybeRejectWithUnknownError("RondpointScaffolding::Rondpoint9336StringifierWellKnownString task dispatch failed");
                return;
            }

            AutoEntryScript aes(uniFFIXPCOMGlobal, "RondpointScaffolding::Rondpoint9336StringifierWellKnownString call resolve");
            RootedDictionary<UniFFIRustCallResult> returnValue(aes.cx());

            rondpoint_9336_stringifier_well_known_string::ReturnResult(aes.cx(), aResult.ResolveValue(), returnValue);
            uniFFIReturnPromise->MaybeResolve(returnValue);
            }
    );

    // Return the JS promise, using forget() to convert it to already_AddRefed
    return uniFFIReturnPromise.forget();
}
using namespace uniffi::rondpoint;
already_AddRefed<Promise> RondpointScaffolding::Rondpoint9336StringifierToStringI8(const GlobalObject& aUniFFIGlobal,const UniFFIPointer& ptr, const int8_t& value,
 ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args

    // Create the promise that we return to JS
    nsCOMPtr<nsIGlobalObject> uniFFIXPCOMGlobal = do_QueryInterface(aUniFFIGlobal.GetAsSupports());
    RefPtr<Promise> uniFFIReturnPromise = Promise::Create(uniFFIXPCOMGlobal, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Prepare arguments to pass to Rust
    auto uniFFIArgs = rondpoint_9336_stringifier_to_string_i8::PrepareArgs(ptr, value, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Create a second promise that gets resolved by a background task that calls the scaffolding function
    using UniFFITaskPromise = MozPromise<rondpoint_9336_stringifier_to_string_i8::Result, nsresult, true>;
    RefPtr uniFFITaskPromise = new UniFFITaskPromise::Private(__func__);
    nsresult uniFFIDispatchResult = NS_DispatchBackgroundTask(
            NS_NewRunnableFunction(
                "RondpointScaffolding::Rondpoint9336StringifierToStringI8",
                [args = std::move(uniFFIArgs), uniFFITaskPromise]() mutable {
                auto result = rondpoint_9336_stringifier_to_string_i8::Invoke(args);
                uniFFITaskPromise->Resolve(std::move(result), __func__);
            }),
            NS_DISPATCH_EVENT_MAY_BLOCK);
    if (NS_FAILED(uniFFIDispatchResult)) {
        uniFFITaskPromise->Reject(uniFFIDispatchResult, __func__);
    }

    // When the background task promise completes, resolve the JS promise
    uniFFITaskPromise->Then(GetCurrentSerialEventTarget(), __func__,
            [uniFFIXPCOMGlobal, uniFFIReturnPromise](UniFFITaskPromise::ResolveOrRejectValue&& aResult) {
            if (!aResult.IsResolve()) {
                uniFFIReturnPromise->MaybeRejectWithUnknownError("RondpointScaffolding::Rondpoint9336StringifierToStringI8 task dispatch failed");
                return;
            }

            AutoEntryScript aes(uniFFIXPCOMGlobal, "RondpointScaffolding::Rondpoint9336StringifierToStringI8 call resolve");
            RootedDictionary<UniFFIRustCallResult> returnValue(aes.cx());

            rondpoint_9336_stringifier_to_string_i8::ReturnResult(aes.cx(), aResult.ResolveValue(), returnValue);
            uniFFIReturnPromise->MaybeResolve(returnValue);
            }
    );

    // Return the JS promise, using forget() to convert it to already_AddRefed
    return uniFFIReturnPromise.forget();
}
using namespace uniffi::rondpoint;
already_AddRefed<Promise> RondpointScaffolding::Rondpoint9336StringifierToStringU8(const GlobalObject& aUniFFIGlobal,const UniFFIPointer& ptr, const uint8_t& value,
 ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args

    // Create the promise that we return to JS
    nsCOMPtr<nsIGlobalObject> uniFFIXPCOMGlobal = do_QueryInterface(aUniFFIGlobal.GetAsSupports());
    RefPtr<Promise> uniFFIReturnPromise = Promise::Create(uniFFIXPCOMGlobal, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Prepare arguments to pass to Rust
    auto uniFFIArgs = rondpoint_9336_stringifier_to_string_u8::PrepareArgs(ptr, value, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Create a second promise that gets resolved by a background task that calls the scaffolding function
    using UniFFITaskPromise = MozPromise<rondpoint_9336_stringifier_to_string_u8::Result, nsresult, true>;
    RefPtr uniFFITaskPromise = new UniFFITaskPromise::Private(__func__);
    nsresult uniFFIDispatchResult = NS_DispatchBackgroundTask(
            NS_NewRunnableFunction(
                "RondpointScaffolding::Rondpoint9336StringifierToStringU8",
                [args = std::move(uniFFIArgs), uniFFITaskPromise]() mutable {
                auto result = rondpoint_9336_stringifier_to_string_u8::Invoke(args);
                uniFFITaskPromise->Resolve(std::move(result), __func__);
            }),
            NS_DISPATCH_EVENT_MAY_BLOCK);
    if (NS_FAILED(uniFFIDispatchResult)) {
        uniFFITaskPromise->Reject(uniFFIDispatchResult, __func__);
    }

    // When the background task promise completes, resolve the JS promise
    uniFFITaskPromise->Then(GetCurrentSerialEventTarget(), __func__,
            [uniFFIXPCOMGlobal, uniFFIReturnPromise](UniFFITaskPromise::ResolveOrRejectValue&& aResult) {
            if (!aResult.IsResolve()) {
                uniFFIReturnPromise->MaybeRejectWithUnknownError("RondpointScaffolding::Rondpoint9336StringifierToStringU8 task dispatch failed");
                return;
            }

            AutoEntryScript aes(uniFFIXPCOMGlobal, "RondpointScaffolding::Rondpoint9336StringifierToStringU8 call resolve");
            RootedDictionary<UniFFIRustCallResult> returnValue(aes.cx());

            rondpoint_9336_stringifier_to_string_u8::ReturnResult(aes.cx(), aResult.ResolveValue(), returnValue);
            uniFFIReturnPromise->MaybeResolve(returnValue);
            }
    );

    // Return the JS promise, using forget() to convert it to already_AddRefed
    return uniFFIReturnPromise.forget();
}
using namespace uniffi::rondpoint;
already_AddRefed<Promise> RondpointScaffolding::Rondpoint9336StringifierToStringI16(const GlobalObject& aUniFFIGlobal,const UniFFIPointer& ptr, const int16_t& value,
 ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args

    // Create the promise that we return to JS
    nsCOMPtr<nsIGlobalObject> uniFFIXPCOMGlobal = do_QueryInterface(aUniFFIGlobal.GetAsSupports());
    RefPtr<Promise> uniFFIReturnPromise = Promise::Create(uniFFIXPCOMGlobal, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Prepare arguments to pass to Rust
    auto uniFFIArgs = rondpoint_9336_stringifier_to_string_i16::PrepareArgs(ptr, value, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Create a second promise that gets resolved by a background task that calls the scaffolding function
    using UniFFITaskPromise = MozPromise<rondpoint_9336_stringifier_to_string_i16::Result, nsresult, true>;
    RefPtr uniFFITaskPromise = new UniFFITaskPromise::Private(__func__);
    nsresult uniFFIDispatchResult = NS_DispatchBackgroundTask(
            NS_NewRunnableFunction(
                "RondpointScaffolding::Rondpoint9336StringifierToStringI16",
                [args = std::move(uniFFIArgs), uniFFITaskPromise]() mutable {
                auto result = rondpoint_9336_stringifier_to_string_i16::Invoke(args);
                uniFFITaskPromise->Resolve(std::move(result), __func__);
            }),
            NS_DISPATCH_EVENT_MAY_BLOCK);
    if (NS_FAILED(uniFFIDispatchResult)) {
        uniFFITaskPromise->Reject(uniFFIDispatchResult, __func__);
    }

    // When the background task promise completes, resolve the JS promise
    uniFFITaskPromise->Then(GetCurrentSerialEventTarget(), __func__,
            [uniFFIXPCOMGlobal, uniFFIReturnPromise](UniFFITaskPromise::ResolveOrRejectValue&& aResult) {
            if (!aResult.IsResolve()) {
                uniFFIReturnPromise->MaybeRejectWithUnknownError("RondpointScaffolding::Rondpoint9336StringifierToStringI16 task dispatch failed");
                return;
            }

            AutoEntryScript aes(uniFFIXPCOMGlobal, "RondpointScaffolding::Rondpoint9336StringifierToStringI16 call resolve");
            RootedDictionary<UniFFIRustCallResult> returnValue(aes.cx());

            rondpoint_9336_stringifier_to_string_i16::ReturnResult(aes.cx(), aResult.ResolveValue(), returnValue);
            uniFFIReturnPromise->MaybeResolve(returnValue);
            }
    );

    // Return the JS promise, using forget() to convert it to already_AddRefed
    return uniFFIReturnPromise.forget();
}
using namespace uniffi::rondpoint;
already_AddRefed<Promise> RondpointScaffolding::Rondpoint9336StringifierToStringU16(const GlobalObject& aUniFFIGlobal,const UniFFIPointer& ptr, const uint16_t& value,
 ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args

    // Create the promise that we return to JS
    nsCOMPtr<nsIGlobalObject> uniFFIXPCOMGlobal = do_QueryInterface(aUniFFIGlobal.GetAsSupports());
    RefPtr<Promise> uniFFIReturnPromise = Promise::Create(uniFFIXPCOMGlobal, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Prepare arguments to pass to Rust
    auto uniFFIArgs = rondpoint_9336_stringifier_to_string_u16::PrepareArgs(ptr, value, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Create a second promise that gets resolved by a background task that calls the scaffolding function
    using UniFFITaskPromise = MozPromise<rondpoint_9336_stringifier_to_string_u16::Result, nsresult, true>;
    RefPtr uniFFITaskPromise = new UniFFITaskPromise::Private(__func__);
    nsresult uniFFIDispatchResult = NS_DispatchBackgroundTask(
            NS_NewRunnableFunction(
                "RondpointScaffolding::Rondpoint9336StringifierToStringU16",
                [args = std::move(uniFFIArgs), uniFFITaskPromise]() mutable {
                auto result = rondpoint_9336_stringifier_to_string_u16::Invoke(args);
                uniFFITaskPromise->Resolve(std::move(result), __func__);
            }),
            NS_DISPATCH_EVENT_MAY_BLOCK);
    if (NS_FAILED(uniFFIDispatchResult)) {
        uniFFITaskPromise->Reject(uniFFIDispatchResult, __func__);
    }

    // When the background task promise completes, resolve the JS promise
    uniFFITaskPromise->Then(GetCurrentSerialEventTarget(), __func__,
            [uniFFIXPCOMGlobal, uniFFIReturnPromise](UniFFITaskPromise::ResolveOrRejectValue&& aResult) {
            if (!aResult.IsResolve()) {
                uniFFIReturnPromise->MaybeRejectWithUnknownError("RondpointScaffolding::Rondpoint9336StringifierToStringU16 task dispatch failed");
                return;
            }

            AutoEntryScript aes(uniFFIXPCOMGlobal, "RondpointScaffolding::Rondpoint9336StringifierToStringU16 call resolve");
            RootedDictionary<UniFFIRustCallResult> returnValue(aes.cx());

            rondpoint_9336_stringifier_to_string_u16::ReturnResult(aes.cx(), aResult.ResolveValue(), returnValue);
            uniFFIReturnPromise->MaybeResolve(returnValue);
            }
    );

    // Return the JS promise, using forget() to convert it to already_AddRefed
    return uniFFIReturnPromise.forget();
}
using namespace uniffi::rondpoint;
already_AddRefed<Promise> RondpointScaffolding::Rondpoint9336StringifierToStringI32(const GlobalObject& aUniFFIGlobal,const UniFFIPointer& ptr, const int32_t& value,
 ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args

    // Create the promise that we return to JS
    nsCOMPtr<nsIGlobalObject> uniFFIXPCOMGlobal = do_QueryInterface(aUniFFIGlobal.GetAsSupports());
    RefPtr<Promise> uniFFIReturnPromise = Promise::Create(uniFFIXPCOMGlobal, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Prepare arguments to pass to Rust
    auto uniFFIArgs = rondpoint_9336_stringifier_to_string_i32::PrepareArgs(ptr, value, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Create a second promise that gets resolved by a background task that calls the scaffolding function
    using UniFFITaskPromise = MozPromise<rondpoint_9336_stringifier_to_string_i32::Result, nsresult, true>;
    RefPtr uniFFITaskPromise = new UniFFITaskPromise::Private(__func__);
    nsresult uniFFIDispatchResult = NS_DispatchBackgroundTask(
            NS_NewRunnableFunction(
                "RondpointScaffolding::Rondpoint9336StringifierToStringI32",
                [args = std::move(uniFFIArgs), uniFFITaskPromise]() mutable {
                auto result = rondpoint_9336_stringifier_to_string_i32::Invoke(args);
                uniFFITaskPromise->Resolve(std::move(result), __func__);
            }),
            NS_DISPATCH_EVENT_MAY_BLOCK);
    if (NS_FAILED(uniFFIDispatchResult)) {
        uniFFITaskPromise->Reject(uniFFIDispatchResult, __func__);
    }

    // When the background task promise completes, resolve the JS promise
    uniFFITaskPromise->Then(GetCurrentSerialEventTarget(), __func__,
            [uniFFIXPCOMGlobal, uniFFIReturnPromise](UniFFITaskPromise::ResolveOrRejectValue&& aResult) {
            if (!aResult.IsResolve()) {
                uniFFIReturnPromise->MaybeRejectWithUnknownError("RondpointScaffolding::Rondpoint9336StringifierToStringI32 task dispatch failed");
                return;
            }

            AutoEntryScript aes(uniFFIXPCOMGlobal, "RondpointScaffolding::Rondpoint9336StringifierToStringI32 call resolve");
            RootedDictionary<UniFFIRustCallResult> returnValue(aes.cx());

            rondpoint_9336_stringifier_to_string_i32::ReturnResult(aes.cx(), aResult.ResolveValue(), returnValue);
            uniFFIReturnPromise->MaybeResolve(returnValue);
            }
    );

    // Return the JS promise, using forget() to convert it to already_AddRefed
    return uniFFIReturnPromise.forget();
}
using namespace uniffi::rondpoint;
already_AddRefed<Promise> RondpointScaffolding::Rondpoint9336StringifierToStringU32(const GlobalObject& aUniFFIGlobal,const UniFFIPointer& ptr, const uint32_t& value,
 ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args

    // Create the promise that we return to JS
    nsCOMPtr<nsIGlobalObject> uniFFIXPCOMGlobal = do_QueryInterface(aUniFFIGlobal.GetAsSupports());
    RefPtr<Promise> uniFFIReturnPromise = Promise::Create(uniFFIXPCOMGlobal, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Prepare arguments to pass to Rust
    auto uniFFIArgs = rondpoint_9336_stringifier_to_string_u32::PrepareArgs(ptr, value, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Create a second promise that gets resolved by a background task that calls the scaffolding function
    using UniFFITaskPromise = MozPromise<rondpoint_9336_stringifier_to_string_u32::Result, nsresult, true>;
    RefPtr uniFFITaskPromise = new UniFFITaskPromise::Private(__func__);
    nsresult uniFFIDispatchResult = NS_DispatchBackgroundTask(
            NS_NewRunnableFunction(
                "RondpointScaffolding::Rondpoint9336StringifierToStringU32",
                [args = std::move(uniFFIArgs), uniFFITaskPromise]() mutable {
                auto result = rondpoint_9336_stringifier_to_string_u32::Invoke(args);
                uniFFITaskPromise->Resolve(std::move(result), __func__);
            }),
            NS_DISPATCH_EVENT_MAY_BLOCK);
    if (NS_FAILED(uniFFIDispatchResult)) {
        uniFFITaskPromise->Reject(uniFFIDispatchResult, __func__);
    }

    // When the background task promise completes, resolve the JS promise
    uniFFITaskPromise->Then(GetCurrentSerialEventTarget(), __func__,
            [uniFFIXPCOMGlobal, uniFFIReturnPromise](UniFFITaskPromise::ResolveOrRejectValue&& aResult) {
            if (!aResult.IsResolve()) {
                uniFFIReturnPromise->MaybeRejectWithUnknownError("RondpointScaffolding::Rondpoint9336StringifierToStringU32 task dispatch failed");
                return;
            }

            AutoEntryScript aes(uniFFIXPCOMGlobal, "RondpointScaffolding::Rondpoint9336StringifierToStringU32 call resolve");
            RootedDictionary<UniFFIRustCallResult> returnValue(aes.cx());

            rondpoint_9336_stringifier_to_string_u32::ReturnResult(aes.cx(), aResult.ResolveValue(), returnValue);
            uniFFIReturnPromise->MaybeResolve(returnValue);
            }
    );

    // Return the JS promise, using forget() to convert it to already_AddRefed
    return uniFFIReturnPromise.forget();
}
using namespace uniffi::rondpoint;
already_AddRefed<Promise> RondpointScaffolding::Rondpoint9336StringifierToStringI64(const GlobalObject& aUniFFIGlobal,const UniFFIPointer& ptr, const int64_t& value,
 ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args

    // Create the promise that we return to JS
    nsCOMPtr<nsIGlobalObject> uniFFIXPCOMGlobal = do_QueryInterface(aUniFFIGlobal.GetAsSupports());
    RefPtr<Promise> uniFFIReturnPromise = Promise::Create(uniFFIXPCOMGlobal, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Prepare arguments to pass to Rust
    auto uniFFIArgs = rondpoint_9336_stringifier_to_string_i64::PrepareArgs(ptr, value, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Create a second promise that gets resolved by a background task that calls the scaffolding function
    using UniFFITaskPromise = MozPromise<rondpoint_9336_stringifier_to_string_i64::Result, nsresult, true>;
    RefPtr uniFFITaskPromise = new UniFFITaskPromise::Private(__func__);
    nsresult uniFFIDispatchResult = NS_DispatchBackgroundTask(
            NS_NewRunnableFunction(
                "RondpointScaffolding::Rondpoint9336StringifierToStringI64",
                [args = std::move(uniFFIArgs), uniFFITaskPromise]() mutable {
                auto result = rondpoint_9336_stringifier_to_string_i64::Invoke(args);
                uniFFITaskPromise->Resolve(std::move(result), __func__);
            }),
            NS_DISPATCH_EVENT_MAY_BLOCK);
    if (NS_FAILED(uniFFIDispatchResult)) {
        uniFFITaskPromise->Reject(uniFFIDispatchResult, __func__);
    }

    // When the background task promise completes, resolve the JS promise
    uniFFITaskPromise->Then(GetCurrentSerialEventTarget(), __func__,
            [uniFFIXPCOMGlobal, uniFFIReturnPromise](UniFFITaskPromise::ResolveOrRejectValue&& aResult) {
            if (!aResult.IsResolve()) {
                uniFFIReturnPromise->MaybeRejectWithUnknownError("RondpointScaffolding::Rondpoint9336StringifierToStringI64 task dispatch failed");
                return;
            }

            AutoEntryScript aes(uniFFIXPCOMGlobal, "RondpointScaffolding::Rondpoint9336StringifierToStringI64 call resolve");
            RootedDictionary<UniFFIRustCallResult> returnValue(aes.cx());

            rondpoint_9336_stringifier_to_string_i64::ReturnResult(aes.cx(), aResult.ResolveValue(), returnValue);
            uniFFIReturnPromise->MaybeResolve(returnValue);
            }
    );

    // Return the JS promise, using forget() to convert it to already_AddRefed
    return uniFFIReturnPromise.forget();
}
using namespace uniffi::rondpoint;
already_AddRefed<Promise> RondpointScaffolding::Rondpoint9336StringifierToStringU64(const GlobalObject& aUniFFIGlobal,const UniFFIPointer& ptr, const uint64_t& value,
 ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args

    // Create the promise that we return to JS
    nsCOMPtr<nsIGlobalObject> uniFFIXPCOMGlobal = do_QueryInterface(aUniFFIGlobal.GetAsSupports());
    RefPtr<Promise> uniFFIReturnPromise = Promise::Create(uniFFIXPCOMGlobal, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Prepare arguments to pass to Rust
    auto uniFFIArgs = rondpoint_9336_stringifier_to_string_u64::PrepareArgs(ptr, value, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Create a second promise that gets resolved by a background task that calls the scaffolding function
    using UniFFITaskPromise = MozPromise<rondpoint_9336_stringifier_to_string_u64::Result, nsresult, true>;
    RefPtr uniFFITaskPromise = new UniFFITaskPromise::Private(__func__);
    nsresult uniFFIDispatchResult = NS_DispatchBackgroundTask(
            NS_NewRunnableFunction(
                "RondpointScaffolding::Rondpoint9336StringifierToStringU64",
                [args = std::move(uniFFIArgs), uniFFITaskPromise]() mutable {
                auto result = rondpoint_9336_stringifier_to_string_u64::Invoke(args);
                uniFFITaskPromise->Resolve(std::move(result), __func__);
            }),
            NS_DISPATCH_EVENT_MAY_BLOCK);
    if (NS_FAILED(uniFFIDispatchResult)) {
        uniFFITaskPromise->Reject(uniFFIDispatchResult, __func__);
    }

    // When the background task promise completes, resolve the JS promise
    uniFFITaskPromise->Then(GetCurrentSerialEventTarget(), __func__,
            [uniFFIXPCOMGlobal, uniFFIReturnPromise](UniFFITaskPromise::ResolveOrRejectValue&& aResult) {
            if (!aResult.IsResolve()) {
                uniFFIReturnPromise->MaybeRejectWithUnknownError("RondpointScaffolding::Rondpoint9336StringifierToStringU64 task dispatch failed");
                return;
            }

            AutoEntryScript aes(uniFFIXPCOMGlobal, "RondpointScaffolding::Rondpoint9336StringifierToStringU64 call resolve");
            RootedDictionary<UniFFIRustCallResult> returnValue(aes.cx());

            rondpoint_9336_stringifier_to_string_u64::ReturnResult(aes.cx(), aResult.ResolveValue(), returnValue);
            uniFFIReturnPromise->MaybeResolve(returnValue);
            }
    );

    // Return the JS promise, using forget() to convert it to already_AddRefed
    return uniFFIReturnPromise.forget();
}
using namespace uniffi::rondpoint;
already_AddRefed<Promise> RondpointScaffolding::Rondpoint9336StringifierToStringFloat(const GlobalObject& aUniFFIGlobal,const UniFFIPointer& ptr, const float& value,
 ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args

    // Create the promise that we return to JS
    nsCOMPtr<nsIGlobalObject> uniFFIXPCOMGlobal = do_QueryInterface(aUniFFIGlobal.GetAsSupports());
    RefPtr<Promise> uniFFIReturnPromise = Promise::Create(uniFFIXPCOMGlobal, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Prepare arguments to pass to Rust
    auto uniFFIArgs = rondpoint_9336_stringifier_to_string_float::PrepareArgs(ptr, value, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Create a second promise that gets resolved by a background task that calls the scaffolding function
    using UniFFITaskPromise = MozPromise<rondpoint_9336_stringifier_to_string_float::Result, nsresult, true>;
    RefPtr uniFFITaskPromise = new UniFFITaskPromise::Private(__func__);
    nsresult uniFFIDispatchResult = NS_DispatchBackgroundTask(
            NS_NewRunnableFunction(
                "RondpointScaffolding::Rondpoint9336StringifierToStringFloat",
                [args = std::move(uniFFIArgs), uniFFITaskPromise]() mutable {
                auto result = rondpoint_9336_stringifier_to_string_float::Invoke(args);
                uniFFITaskPromise->Resolve(std::move(result), __func__);
            }),
            NS_DISPATCH_EVENT_MAY_BLOCK);
    if (NS_FAILED(uniFFIDispatchResult)) {
        uniFFITaskPromise->Reject(uniFFIDispatchResult, __func__);
    }

    // When the background task promise completes, resolve the JS promise
    uniFFITaskPromise->Then(GetCurrentSerialEventTarget(), __func__,
            [uniFFIXPCOMGlobal, uniFFIReturnPromise](UniFFITaskPromise::ResolveOrRejectValue&& aResult) {
            if (!aResult.IsResolve()) {
                uniFFIReturnPromise->MaybeRejectWithUnknownError("RondpointScaffolding::Rondpoint9336StringifierToStringFloat task dispatch failed");
                return;
            }

            AutoEntryScript aes(uniFFIXPCOMGlobal, "RondpointScaffolding::Rondpoint9336StringifierToStringFloat call resolve");
            RootedDictionary<UniFFIRustCallResult> returnValue(aes.cx());

            rondpoint_9336_stringifier_to_string_float::ReturnResult(aes.cx(), aResult.ResolveValue(), returnValue);
            uniFFIReturnPromise->MaybeResolve(returnValue);
            }
    );

    // Return the JS promise, using forget() to convert it to already_AddRefed
    return uniFFIReturnPromise.forget();
}
using namespace uniffi::rondpoint;
already_AddRefed<Promise> RondpointScaffolding::Rondpoint9336StringifierToStringDouble(const GlobalObject& aUniFFIGlobal,const UniFFIPointer& ptr, const double& value,
 ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args

    // Create the promise that we return to JS
    nsCOMPtr<nsIGlobalObject> uniFFIXPCOMGlobal = do_QueryInterface(aUniFFIGlobal.GetAsSupports());
    RefPtr<Promise> uniFFIReturnPromise = Promise::Create(uniFFIXPCOMGlobal, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Prepare arguments to pass to Rust
    auto uniFFIArgs = rondpoint_9336_stringifier_to_string_double::PrepareArgs(ptr, value, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Create a second promise that gets resolved by a background task that calls the scaffolding function
    using UniFFITaskPromise = MozPromise<rondpoint_9336_stringifier_to_string_double::Result, nsresult, true>;
    RefPtr uniFFITaskPromise = new UniFFITaskPromise::Private(__func__);
    nsresult uniFFIDispatchResult = NS_DispatchBackgroundTask(
            NS_NewRunnableFunction(
                "RondpointScaffolding::Rondpoint9336StringifierToStringDouble",
                [args = std::move(uniFFIArgs), uniFFITaskPromise]() mutable {
                auto result = rondpoint_9336_stringifier_to_string_double::Invoke(args);
                uniFFITaskPromise->Resolve(std::move(result), __func__);
            }),
            NS_DISPATCH_EVENT_MAY_BLOCK);
    if (NS_FAILED(uniFFIDispatchResult)) {
        uniFFITaskPromise->Reject(uniFFIDispatchResult, __func__);
    }

    // When the background task promise completes, resolve the JS promise
    uniFFITaskPromise->Then(GetCurrentSerialEventTarget(), __func__,
            [uniFFIXPCOMGlobal, uniFFIReturnPromise](UniFFITaskPromise::ResolveOrRejectValue&& aResult) {
            if (!aResult.IsResolve()) {
                uniFFIReturnPromise->MaybeRejectWithUnknownError("RondpointScaffolding::Rondpoint9336StringifierToStringDouble task dispatch failed");
                return;
            }

            AutoEntryScript aes(uniFFIXPCOMGlobal, "RondpointScaffolding::Rondpoint9336StringifierToStringDouble call resolve");
            RootedDictionary<UniFFIRustCallResult> returnValue(aes.cx());

            rondpoint_9336_stringifier_to_string_double::ReturnResult(aes.cx(), aResult.ResolveValue(), returnValue);
            uniFFIReturnPromise->MaybeResolve(returnValue);
            }
    );

    // Return the JS promise, using forget() to convert it to already_AddRefed
    return uniFFIReturnPromise.forget();
}
using namespace uniffi::rondpoint;
already_AddRefed<Promise> RondpointScaffolding::Rondpoint9336StringifierToStringBoolean(const GlobalObject& aUniFFIGlobal,const UniFFIPointer& ptr, const int8_t& value,
 ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args

    // Create the promise that we return to JS
    nsCOMPtr<nsIGlobalObject> uniFFIXPCOMGlobal = do_QueryInterface(aUniFFIGlobal.GetAsSupports());
    RefPtr<Promise> uniFFIReturnPromise = Promise::Create(uniFFIXPCOMGlobal, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Prepare arguments to pass to Rust
    auto uniFFIArgs = rondpoint_9336_stringifier_to_string_boolean::PrepareArgs(ptr, value, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Create a second promise that gets resolved by a background task that calls the scaffolding function
    using UniFFITaskPromise = MozPromise<rondpoint_9336_stringifier_to_string_boolean::Result, nsresult, true>;
    RefPtr uniFFITaskPromise = new UniFFITaskPromise::Private(__func__);
    nsresult uniFFIDispatchResult = NS_DispatchBackgroundTask(
            NS_NewRunnableFunction(
                "RondpointScaffolding::Rondpoint9336StringifierToStringBoolean",
                [args = std::move(uniFFIArgs), uniFFITaskPromise]() mutable {
                auto result = rondpoint_9336_stringifier_to_string_boolean::Invoke(args);
                uniFFITaskPromise->Resolve(std::move(result), __func__);
            }),
            NS_DISPATCH_EVENT_MAY_BLOCK);
    if (NS_FAILED(uniFFIDispatchResult)) {
        uniFFITaskPromise->Reject(uniFFIDispatchResult, __func__);
    }

    // When the background task promise completes, resolve the JS promise
    uniFFITaskPromise->Then(GetCurrentSerialEventTarget(), __func__,
            [uniFFIXPCOMGlobal, uniFFIReturnPromise](UniFFITaskPromise::ResolveOrRejectValue&& aResult) {
            if (!aResult.IsResolve()) {
                uniFFIReturnPromise->MaybeRejectWithUnknownError("RondpointScaffolding::Rondpoint9336StringifierToStringBoolean task dispatch failed");
                return;
            }

            AutoEntryScript aes(uniFFIXPCOMGlobal, "RondpointScaffolding::Rondpoint9336StringifierToStringBoolean call resolve");
            RootedDictionary<UniFFIRustCallResult> returnValue(aes.cx());

            rondpoint_9336_stringifier_to_string_boolean::ReturnResult(aes.cx(), aResult.ResolveValue(), returnValue);
            uniFFIReturnPromise->MaybeResolve(returnValue);
            }
    );

    // Return the JS promise, using forget() to convert it to already_AddRefed
    return uniFFIReturnPromise.forget();
}
using namespace uniffi::rondpoint;
already_AddRefed<Promise> RondpointScaffolding::FfiRondpoint9336OptionneurObjectFree(const GlobalObject& aUniFFIGlobal,const UniFFIPointer& ptr,
 ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args

    // Create the promise that we return to JS
    nsCOMPtr<nsIGlobalObject> uniFFIXPCOMGlobal = do_QueryInterface(aUniFFIGlobal.GetAsSupports());
    RefPtr<Promise> uniFFIReturnPromise = Promise::Create(uniFFIXPCOMGlobal, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Prepare arguments to pass to Rust
    auto uniFFIArgs = ffi_rondpoint_9336_optionneur_object_free::PrepareArgs(ptr, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Create a second promise that gets resolved by a background task that calls the scaffolding function
    using UniFFITaskPromise = MozPromise<ffi_rondpoint_9336_optionneur_object_free::Result, nsresult, true>;
    RefPtr uniFFITaskPromise = new UniFFITaskPromise::Private(__func__);
    nsresult uniFFIDispatchResult = NS_DispatchBackgroundTask(
            NS_NewRunnableFunction(
                "RondpointScaffolding::FfiRondpoint9336OptionneurObjectFree",
                [args = std::move(uniFFIArgs), uniFFITaskPromise]() mutable {
                auto result = ffi_rondpoint_9336_optionneur_object_free::Invoke(args);
                uniFFITaskPromise->Resolve(std::move(result), __func__);
            }),
            NS_DISPATCH_EVENT_MAY_BLOCK);
    if (NS_FAILED(uniFFIDispatchResult)) {
        uniFFITaskPromise->Reject(uniFFIDispatchResult, __func__);
    }

    // When the background task promise completes, resolve the JS promise
    uniFFITaskPromise->Then(GetCurrentSerialEventTarget(), __func__,
            [uniFFIXPCOMGlobal, uniFFIReturnPromise](UniFFITaskPromise::ResolveOrRejectValue&& aResult) {
            if (!aResult.IsResolve()) {
                uniFFIReturnPromise->MaybeRejectWithUnknownError("RondpointScaffolding::FfiRondpoint9336OptionneurObjectFree task dispatch failed");
                return;
            }

            AutoEntryScript aes(uniFFIXPCOMGlobal, "RondpointScaffolding::FfiRondpoint9336OptionneurObjectFree call resolve");
            RootedDictionary<UniFFIRustCallResult> returnValue(aes.cx());

            ffi_rondpoint_9336_optionneur_object_free::ReturnResult(aes.cx(), aResult.ResolveValue(), returnValue);
            uniFFIReturnPromise->MaybeResolve(returnValue);
            }
    );

    // Return the JS promise, using forget() to convert it to already_AddRefed
    return uniFFIReturnPromise.forget();
}
using namespace uniffi::rondpoint;
already_AddRefed<Promise> RondpointScaffolding::Rondpoint9336OptionneurNew(const GlobalObject& aUniFFIGlobal,
 ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args

    // Create the promise that we return to JS
    nsCOMPtr<nsIGlobalObject> uniFFIXPCOMGlobal = do_QueryInterface(aUniFFIGlobal.GetAsSupports());
    RefPtr<Promise> uniFFIReturnPromise = Promise::Create(uniFFIXPCOMGlobal, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Prepare arguments to pass to Rust
    auto uniFFIArgs = rondpoint_9336_optionneur_new::PrepareArgs(aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Create a second promise that gets resolved by a background task that calls the scaffolding function
    using UniFFITaskPromise = MozPromise<rondpoint_9336_optionneur_new::Result, nsresult, true>;
    RefPtr uniFFITaskPromise = new UniFFITaskPromise::Private(__func__);
    nsresult uniFFIDispatchResult = NS_DispatchBackgroundTask(
            NS_NewRunnableFunction(
                "RondpointScaffolding::Rondpoint9336OptionneurNew",
                [args = std::move(uniFFIArgs), uniFFITaskPromise]() mutable {
                auto result = rondpoint_9336_optionneur_new::Invoke(args);
                uniFFITaskPromise->Resolve(std::move(result), __func__);
            }),
            NS_DISPATCH_EVENT_MAY_BLOCK);
    if (NS_FAILED(uniFFIDispatchResult)) {
        uniFFITaskPromise->Reject(uniFFIDispatchResult, __func__);
    }

    // When the background task promise completes, resolve the JS promise
    uniFFITaskPromise->Then(GetCurrentSerialEventTarget(), __func__,
            [uniFFIXPCOMGlobal, uniFFIReturnPromise](UniFFITaskPromise::ResolveOrRejectValue&& aResult) {
            if (!aResult.IsResolve()) {
                uniFFIReturnPromise->MaybeRejectWithUnknownError("RondpointScaffolding::Rondpoint9336OptionneurNew task dispatch failed");
                return;
            }

            AutoEntryScript aes(uniFFIXPCOMGlobal, "RondpointScaffolding::Rondpoint9336OptionneurNew call resolve");
            RootedDictionary<UniFFIRustCallResult> returnValue(aes.cx());

            rondpoint_9336_optionneur_new::ReturnResult(aes.cx(), aResult.ResolveValue(), returnValue);
            uniFFIReturnPromise->MaybeResolve(returnValue);
            }
    );

    // Return the JS promise, using forget() to convert it to already_AddRefed
    return uniFFIReturnPromise.forget();
}
using namespace uniffi::rondpoint;
already_AddRefed<Promise> RondpointScaffolding::Rondpoint9336OptionneurSinonBoolean(const GlobalObject& aUniFFIGlobal,const UniFFIPointer& ptr, const int8_t& value,
 ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args

    // Create the promise that we return to JS
    nsCOMPtr<nsIGlobalObject> uniFFIXPCOMGlobal = do_QueryInterface(aUniFFIGlobal.GetAsSupports());
    RefPtr<Promise> uniFFIReturnPromise = Promise::Create(uniFFIXPCOMGlobal, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Prepare arguments to pass to Rust
    auto uniFFIArgs = rondpoint_9336_optionneur_sinon_boolean::PrepareArgs(ptr, value, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Create a second promise that gets resolved by a background task that calls the scaffolding function
    using UniFFITaskPromise = MozPromise<rondpoint_9336_optionneur_sinon_boolean::Result, nsresult, true>;
    RefPtr uniFFITaskPromise = new UniFFITaskPromise::Private(__func__);
    nsresult uniFFIDispatchResult = NS_DispatchBackgroundTask(
            NS_NewRunnableFunction(
                "RondpointScaffolding::Rondpoint9336OptionneurSinonBoolean",
                [args = std::move(uniFFIArgs), uniFFITaskPromise]() mutable {
                auto result = rondpoint_9336_optionneur_sinon_boolean::Invoke(args);
                uniFFITaskPromise->Resolve(std::move(result), __func__);
            }),
            NS_DISPATCH_EVENT_MAY_BLOCK);
    if (NS_FAILED(uniFFIDispatchResult)) {
        uniFFITaskPromise->Reject(uniFFIDispatchResult, __func__);
    }

    // When the background task promise completes, resolve the JS promise
    uniFFITaskPromise->Then(GetCurrentSerialEventTarget(), __func__,
            [uniFFIXPCOMGlobal, uniFFIReturnPromise](UniFFITaskPromise::ResolveOrRejectValue&& aResult) {
            if (!aResult.IsResolve()) {
                uniFFIReturnPromise->MaybeRejectWithUnknownError("RondpointScaffolding::Rondpoint9336OptionneurSinonBoolean task dispatch failed");
                return;
            }

            AutoEntryScript aes(uniFFIXPCOMGlobal, "RondpointScaffolding::Rondpoint9336OptionneurSinonBoolean call resolve");
            RootedDictionary<UniFFIRustCallResult> returnValue(aes.cx());

            rondpoint_9336_optionneur_sinon_boolean::ReturnResult(aes.cx(), aResult.ResolveValue(), returnValue);
            uniFFIReturnPromise->MaybeResolve(returnValue);
            }
    );

    // Return the JS promise, using forget() to convert it to already_AddRefed
    return uniFFIReturnPromise.forget();
}
using namespace uniffi::rondpoint;
already_AddRefed<Promise> RondpointScaffolding::Rondpoint9336OptionneurSinonString(const GlobalObject& aUniFFIGlobal,const UniFFIPointer& ptr, const ArrayBuffer& value,
 ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args

    // Create the promise that we return to JS
    nsCOMPtr<nsIGlobalObject> uniFFIXPCOMGlobal = do_QueryInterface(aUniFFIGlobal.GetAsSupports());
    RefPtr<Promise> uniFFIReturnPromise = Promise::Create(uniFFIXPCOMGlobal, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Prepare arguments to pass to Rust
    auto uniFFIArgs = rondpoint_9336_optionneur_sinon_string::PrepareArgs(ptr, value, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Create a second promise that gets resolved by a background task that calls the scaffolding function
    using UniFFITaskPromise = MozPromise<rondpoint_9336_optionneur_sinon_string::Result, nsresult, true>;
    RefPtr uniFFITaskPromise = new UniFFITaskPromise::Private(__func__);
    nsresult uniFFIDispatchResult = NS_DispatchBackgroundTask(
            NS_NewRunnableFunction(
                "RondpointScaffolding::Rondpoint9336OptionneurSinonString",
                [args = std::move(uniFFIArgs), uniFFITaskPromise]() mutable {
                auto result = rondpoint_9336_optionneur_sinon_string::Invoke(args);
                uniFFITaskPromise->Resolve(std::move(result), __func__);
            }),
            NS_DISPATCH_EVENT_MAY_BLOCK);
    if (NS_FAILED(uniFFIDispatchResult)) {
        uniFFITaskPromise->Reject(uniFFIDispatchResult, __func__);
    }

    // When the background task promise completes, resolve the JS promise
    uniFFITaskPromise->Then(GetCurrentSerialEventTarget(), __func__,
            [uniFFIXPCOMGlobal, uniFFIReturnPromise](UniFFITaskPromise::ResolveOrRejectValue&& aResult) {
            if (!aResult.IsResolve()) {
                uniFFIReturnPromise->MaybeRejectWithUnknownError("RondpointScaffolding::Rondpoint9336OptionneurSinonString task dispatch failed");
                return;
            }

            AutoEntryScript aes(uniFFIXPCOMGlobal, "RondpointScaffolding::Rondpoint9336OptionneurSinonString call resolve");
            RootedDictionary<UniFFIRustCallResult> returnValue(aes.cx());

            rondpoint_9336_optionneur_sinon_string::ReturnResult(aes.cx(), aResult.ResolveValue(), returnValue);
            uniFFIReturnPromise->MaybeResolve(returnValue);
            }
    );

    // Return the JS promise, using forget() to convert it to already_AddRefed
    return uniFFIReturnPromise.forget();
}
using namespace uniffi::rondpoint;
already_AddRefed<Promise> RondpointScaffolding::Rondpoint9336OptionneurSinonSequence(const GlobalObject& aUniFFIGlobal,const UniFFIPointer& ptr, const ArrayBuffer& value,
 ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args

    // Create the promise that we return to JS
    nsCOMPtr<nsIGlobalObject> uniFFIXPCOMGlobal = do_QueryInterface(aUniFFIGlobal.GetAsSupports());
    RefPtr<Promise> uniFFIReturnPromise = Promise::Create(uniFFIXPCOMGlobal, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Prepare arguments to pass to Rust
    auto uniFFIArgs = rondpoint_9336_optionneur_sinon_sequence::PrepareArgs(ptr, value, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Create a second promise that gets resolved by a background task that calls the scaffolding function
    using UniFFITaskPromise = MozPromise<rondpoint_9336_optionneur_sinon_sequence::Result, nsresult, true>;
    RefPtr uniFFITaskPromise = new UniFFITaskPromise::Private(__func__);
    nsresult uniFFIDispatchResult = NS_DispatchBackgroundTask(
            NS_NewRunnableFunction(
                "RondpointScaffolding::Rondpoint9336OptionneurSinonSequence",
                [args = std::move(uniFFIArgs), uniFFITaskPromise]() mutable {
                auto result = rondpoint_9336_optionneur_sinon_sequence::Invoke(args);
                uniFFITaskPromise->Resolve(std::move(result), __func__);
            }),
            NS_DISPATCH_EVENT_MAY_BLOCK);
    if (NS_FAILED(uniFFIDispatchResult)) {
        uniFFITaskPromise->Reject(uniFFIDispatchResult, __func__);
    }

    // When the background task promise completes, resolve the JS promise
    uniFFITaskPromise->Then(GetCurrentSerialEventTarget(), __func__,
            [uniFFIXPCOMGlobal, uniFFIReturnPromise](UniFFITaskPromise::ResolveOrRejectValue&& aResult) {
            if (!aResult.IsResolve()) {
                uniFFIReturnPromise->MaybeRejectWithUnknownError("RondpointScaffolding::Rondpoint9336OptionneurSinonSequence task dispatch failed");
                return;
            }

            AutoEntryScript aes(uniFFIXPCOMGlobal, "RondpointScaffolding::Rondpoint9336OptionneurSinonSequence call resolve");
            RootedDictionary<UniFFIRustCallResult> returnValue(aes.cx());

            rondpoint_9336_optionneur_sinon_sequence::ReturnResult(aes.cx(), aResult.ResolveValue(), returnValue);
            uniFFIReturnPromise->MaybeResolve(returnValue);
            }
    );

    // Return the JS promise, using forget() to convert it to already_AddRefed
    return uniFFIReturnPromise.forget();
}
using namespace uniffi::rondpoint;
already_AddRefed<Promise> RondpointScaffolding::Rondpoint9336OptionneurSinonNull(const GlobalObject& aUniFFIGlobal,const UniFFIPointer& ptr, const ArrayBuffer& value,
 ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args

    // Create the promise that we return to JS
    nsCOMPtr<nsIGlobalObject> uniFFIXPCOMGlobal = do_QueryInterface(aUniFFIGlobal.GetAsSupports());
    RefPtr<Promise> uniFFIReturnPromise = Promise::Create(uniFFIXPCOMGlobal, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Prepare arguments to pass to Rust
    auto uniFFIArgs = rondpoint_9336_optionneur_sinon_null::PrepareArgs(ptr, value, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Create a second promise that gets resolved by a background task that calls the scaffolding function
    using UniFFITaskPromise = MozPromise<rondpoint_9336_optionneur_sinon_null::Result, nsresult, true>;
    RefPtr uniFFITaskPromise = new UniFFITaskPromise::Private(__func__);
    nsresult uniFFIDispatchResult = NS_DispatchBackgroundTask(
            NS_NewRunnableFunction(
                "RondpointScaffolding::Rondpoint9336OptionneurSinonNull",
                [args = std::move(uniFFIArgs), uniFFITaskPromise]() mutable {
                auto result = rondpoint_9336_optionneur_sinon_null::Invoke(args);
                uniFFITaskPromise->Resolve(std::move(result), __func__);
            }),
            NS_DISPATCH_EVENT_MAY_BLOCK);
    if (NS_FAILED(uniFFIDispatchResult)) {
        uniFFITaskPromise->Reject(uniFFIDispatchResult, __func__);
    }

    // When the background task promise completes, resolve the JS promise
    uniFFITaskPromise->Then(GetCurrentSerialEventTarget(), __func__,
            [uniFFIXPCOMGlobal, uniFFIReturnPromise](UniFFITaskPromise::ResolveOrRejectValue&& aResult) {
            if (!aResult.IsResolve()) {
                uniFFIReturnPromise->MaybeRejectWithUnknownError("RondpointScaffolding::Rondpoint9336OptionneurSinonNull task dispatch failed");
                return;
            }

            AutoEntryScript aes(uniFFIXPCOMGlobal, "RondpointScaffolding::Rondpoint9336OptionneurSinonNull call resolve");
            RootedDictionary<UniFFIRustCallResult> returnValue(aes.cx());

            rondpoint_9336_optionneur_sinon_null::ReturnResult(aes.cx(), aResult.ResolveValue(), returnValue);
            uniFFIReturnPromise->MaybeResolve(returnValue);
            }
    );

    // Return the JS promise, using forget() to convert it to already_AddRefed
    return uniFFIReturnPromise.forget();
}
using namespace uniffi::rondpoint;
already_AddRefed<Promise> RondpointScaffolding::Rondpoint9336OptionneurSinonZero(const GlobalObject& aUniFFIGlobal,const UniFFIPointer& ptr, const ArrayBuffer& value,
 ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args

    // Create the promise that we return to JS
    nsCOMPtr<nsIGlobalObject> uniFFIXPCOMGlobal = do_QueryInterface(aUniFFIGlobal.GetAsSupports());
    RefPtr<Promise> uniFFIReturnPromise = Promise::Create(uniFFIXPCOMGlobal, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Prepare arguments to pass to Rust
    auto uniFFIArgs = rondpoint_9336_optionneur_sinon_zero::PrepareArgs(ptr, value, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Create a second promise that gets resolved by a background task that calls the scaffolding function
    using UniFFITaskPromise = MozPromise<rondpoint_9336_optionneur_sinon_zero::Result, nsresult, true>;
    RefPtr uniFFITaskPromise = new UniFFITaskPromise::Private(__func__);
    nsresult uniFFIDispatchResult = NS_DispatchBackgroundTask(
            NS_NewRunnableFunction(
                "RondpointScaffolding::Rondpoint9336OptionneurSinonZero",
                [args = std::move(uniFFIArgs), uniFFITaskPromise]() mutable {
                auto result = rondpoint_9336_optionneur_sinon_zero::Invoke(args);
                uniFFITaskPromise->Resolve(std::move(result), __func__);
            }),
            NS_DISPATCH_EVENT_MAY_BLOCK);
    if (NS_FAILED(uniFFIDispatchResult)) {
        uniFFITaskPromise->Reject(uniFFIDispatchResult, __func__);
    }

    // When the background task promise completes, resolve the JS promise
    uniFFITaskPromise->Then(GetCurrentSerialEventTarget(), __func__,
            [uniFFIXPCOMGlobal, uniFFIReturnPromise](UniFFITaskPromise::ResolveOrRejectValue&& aResult) {
            if (!aResult.IsResolve()) {
                uniFFIReturnPromise->MaybeRejectWithUnknownError("RondpointScaffolding::Rondpoint9336OptionneurSinonZero task dispatch failed");
                return;
            }

            AutoEntryScript aes(uniFFIXPCOMGlobal, "RondpointScaffolding::Rondpoint9336OptionneurSinonZero call resolve");
            RootedDictionary<UniFFIRustCallResult> returnValue(aes.cx());

            rondpoint_9336_optionneur_sinon_zero::ReturnResult(aes.cx(), aResult.ResolveValue(), returnValue);
            uniFFIReturnPromise->MaybeResolve(returnValue);
            }
    );

    // Return the JS promise, using forget() to convert it to already_AddRefed
    return uniFFIReturnPromise.forget();
}
using namespace uniffi::rondpoint;
already_AddRefed<Promise> RondpointScaffolding::Rondpoint9336OptionneurSinonU8Dec(const GlobalObject& aUniFFIGlobal,const UniFFIPointer& ptr, const uint8_t& value,
 ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args

    // Create the promise that we return to JS
    nsCOMPtr<nsIGlobalObject> uniFFIXPCOMGlobal = do_QueryInterface(aUniFFIGlobal.GetAsSupports());
    RefPtr<Promise> uniFFIReturnPromise = Promise::Create(uniFFIXPCOMGlobal, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Prepare arguments to pass to Rust
    auto uniFFIArgs = rondpoint_9336_optionneur_sinon_u8_dec::PrepareArgs(ptr, value, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Create a second promise that gets resolved by a background task that calls the scaffolding function
    using UniFFITaskPromise = MozPromise<rondpoint_9336_optionneur_sinon_u8_dec::Result, nsresult, true>;
    RefPtr uniFFITaskPromise = new UniFFITaskPromise::Private(__func__);
    nsresult uniFFIDispatchResult = NS_DispatchBackgroundTask(
            NS_NewRunnableFunction(
                "RondpointScaffolding::Rondpoint9336OptionneurSinonU8Dec",
                [args = std::move(uniFFIArgs), uniFFITaskPromise]() mutable {
                auto result = rondpoint_9336_optionneur_sinon_u8_dec::Invoke(args);
                uniFFITaskPromise->Resolve(std::move(result), __func__);
            }),
            NS_DISPATCH_EVENT_MAY_BLOCK);
    if (NS_FAILED(uniFFIDispatchResult)) {
        uniFFITaskPromise->Reject(uniFFIDispatchResult, __func__);
    }

    // When the background task promise completes, resolve the JS promise
    uniFFITaskPromise->Then(GetCurrentSerialEventTarget(), __func__,
            [uniFFIXPCOMGlobal, uniFFIReturnPromise](UniFFITaskPromise::ResolveOrRejectValue&& aResult) {
            if (!aResult.IsResolve()) {
                uniFFIReturnPromise->MaybeRejectWithUnknownError("RondpointScaffolding::Rondpoint9336OptionneurSinonU8Dec task dispatch failed");
                return;
            }

            AutoEntryScript aes(uniFFIXPCOMGlobal, "RondpointScaffolding::Rondpoint9336OptionneurSinonU8Dec call resolve");
            RootedDictionary<UniFFIRustCallResult> returnValue(aes.cx());

            rondpoint_9336_optionneur_sinon_u8_dec::ReturnResult(aes.cx(), aResult.ResolveValue(), returnValue);
            uniFFIReturnPromise->MaybeResolve(returnValue);
            }
    );

    // Return the JS promise, using forget() to convert it to already_AddRefed
    return uniFFIReturnPromise.forget();
}
using namespace uniffi::rondpoint;
already_AddRefed<Promise> RondpointScaffolding::Rondpoint9336OptionneurSinonI8Dec(const GlobalObject& aUniFFIGlobal,const UniFFIPointer& ptr, const int8_t& value,
 ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args

    // Create the promise that we return to JS
    nsCOMPtr<nsIGlobalObject> uniFFIXPCOMGlobal = do_QueryInterface(aUniFFIGlobal.GetAsSupports());
    RefPtr<Promise> uniFFIReturnPromise = Promise::Create(uniFFIXPCOMGlobal, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Prepare arguments to pass to Rust
    auto uniFFIArgs = rondpoint_9336_optionneur_sinon_i8_dec::PrepareArgs(ptr, value, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Create a second promise that gets resolved by a background task that calls the scaffolding function
    using UniFFITaskPromise = MozPromise<rondpoint_9336_optionneur_sinon_i8_dec::Result, nsresult, true>;
    RefPtr uniFFITaskPromise = new UniFFITaskPromise::Private(__func__);
    nsresult uniFFIDispatchResult = NS_DispatchBackgroundTask(
            NS_NewRunnableFunction(
                "RondpointScaffolding::Rondpoint9336OptionneurSinonI8Dec",
                [args = std::move(uniFFIArgs), uniFFITaskPromise]() mutable {
                auto result = rondpoint_9336_optionneur_sinon_i8_dec::Invoke(args);
                uniFFITaskPromise->Resolve(std::move(result), __func__);
            }),
            NS_DISPATCH_EVENT_MAY_BLOCK);
    if (NS_FAILED(uniFFIDispatchResult)) {
        uniFFITaskPromise->Reject(uniFFIDispatchResult, __func__);
    }

    // When the background task promise completes, resolve the JS promise
    uniFFITaskPromise->Then(GetCurrentSerialEventTarget(), __func__,
            [uniFFIXPCOMGlobal, uniFFIReturnPromise](UniFFITaskPromise::ResolveOrRejectValue&& aResult) {
            if (!aResult.IsResolve()) {
                uniFFIReturnPromise->MaybeRejectWithUnknownError("RondpointScaffolding::Rondpoint9336OptionneurSinonI8Dec task dispatch failed");
                return;
            }

            AutoEntryScript aes(uniFFIXPCOMGlobal, "RondpointScaffolding::Rondpoint9336OptionneurSinonI8Dec call resolve");
            RootedDictionary<UniFFIRustCallResult> returnValue(aes.cx());

            rondpoint_9336_optionneur_sinon_i8_dec::ReturnResult(aes.cx(), aResult.ResolveValue(), returnValue);
            uniFFIReturnPromise->MaybeResolve(returnValue);
            }
    );

    // Return the JS promise, using forget() to convert it to already_AddRefed
    return uniFFIReturnPromise.forget();
}
using namespace uniffi::rondpoint;
already_AddRefed<Promise> RondpointScaffolding::Rondpoint9336OptionneurSinonU16Dec(const GlobalObject& aUniFFIGlobal,const UniFFIPointer& ptr, const uint16_t& value,
 ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args

    // Create the promise that we return to JS
    nsCOMPtr<nsIGlobalObject> uniFFIXPCOMGlobal = do_QueryInterface(aUniFFIGlobal.GetAsSupports());
    RefPtr<Promise> uniFFIReturnPromise = Promise::Create(uniFFIXPCOMGlobal, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Prepare arguments to pass to Rust
    auto uniFFIArgs = rondpoint_9336_optionneur_sinon_u16_dec::PrepareArgs(ptr, value, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Create a second promise that gets resolved by a background task that calls the scaffolding function
    using UniFFITaskPromise = MozPromise<rondpoint_9336_optionneur_sinon_u16_dec::Result, nsresult, true>;
    RefPtr uniFFITaskPromise = new UniFFITaskPromise::Private(__func__);
    nsresult uniFFIDispatchResult = NS_DispatchBackgroundTask(
            NS_NewRunnableFunction(
                "RondpointScaffolding::Rondpoint9336OptionneurSinonU16Dec",
                [args = std::move(uniFFIArgs), uniFFITaskPromise]() mutable {
                auto result = rondpoint_9336_optionneur_sinon_u16_dec::Invoke(args);
                uniFFITaskPromise->Resolve(std::move(result), __func__);
            }),
            NS_DISPATCH_EVENT_MAY_BLOCK);
    if (NS_FAILED(uniFFIDispatchResult)) {
        uniFFITaskPromise->Reject(uniFFIDispatchResult, __func__);
    }

    // When the background task promise completes, resolve the JS promise
    uniFFITaskPromise->Then(GetCurrentSerialEventTarget(), __func__,
            [uniFFIXPCOMGlobal, uniFFIReturnPromise](UniFFITaskPromise::ResolveOrRejectValue&& aResult) {
            if (!aResult.IsResolve()) {
                uniFFIReturnPromise->MaybeRejectWithUnknownError("RondpointScaffolding::Rondpoint9336OptionneurSinonU16Dec task dispatch failed");
                return;
            }

            AutoEntryScript aes(uniFFIXPCOMGlobal, "RondpointScaffolding::Rondpoint9336OptionneurSinonU16Dec call resolve");
            RootedDictionary<UniFFIRustCallResult> returnValue(aes.cx());

            rondpoint_9336_optionneur_sinon_u16_dec::ReturnResult(aes.cx(), aResult.ResolveValue(), returnValue);
            uniFFIReturnPromise->MaybeResolve(returnValue);
            }
    );

    // Return the JS promise, using forget() to convert it to already_AddRefed
    return uniFFIReturnPromise.forget();
}
using namespace uniffi::rondpoint;
already_AddRefed<Promise> RondpointScaffolding::Rondpoint9336OptionneurSinonI16Dec(const GlobalObject& aUniFFIGlobal,const UniFFIPointer& ptr, const int16_t& value,
 ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args

    // Create the promise that we return to JS
    nsCOMPtr<nsIGlobalObject> uniFFIXPCOMGlobal = do_QueryInterface(aUniFFIGlobal.GetAsSupports());
    RefPtr<Promise> uniFFIReturnPromise = Promise::Create(uniFFIXPCOMGlobal, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Prepare arguments to pass to Rust
    auto uniFFIArgs = rondpoint_9336_optionneur_sinon_i16_dec::PrepareArgs(ptr, value, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Create a second promise that gets resolved by a background task that calls the scaffolding function
    using UniFFITaskPromise = MozPromise<rondpoint_9336_optionneur_sinon_i16_dec::Result, nsresult, true>;
    RefPtr uniFFITaskPromise = new UniFFITaskPromise::Private(__func__);
    nsresult uniFFIDispatchResult = NS_DispatchBackgroundTask(
            NS_NewRunnableFunction(
                "RondpointScaffolding::Rondpoint9336OptionneurSinonI16Dec",
                [args = std::move(uniFFIArgs), uniFFITaskPromise]() mutable {
                auto result = rondpoint_9336_optionneur_sinon_i16_dec::Invoke(args);
                uniFFITaskPromise->Resolve(std::move(result), __func__);
            }),
            NS_DISPATCH_EVENT_MAY_BLOCK);
    if (NS_FAILED(uniFFIDispatchResult)) {
        uniFFITaskPromise->Reject(uniFFIDispatchResult, __func__);
    }

    // When the background task promise completes, resolve the JS promise
    uniFFITaskPromise->Then(GetCurrentSerialEventTarget(), __func__,
            [uniFFIXPCOMGlobal, uniFFIReturnPromise](UniFFITaskPromise::ResolveOrRejectValue&& aResult) {
            if (!aResult.IsResolve()) {
                uniFFIReturnPromise->MaybeRejectWithUnknownError("RondpointScaffolding::Rondpoint9336OptionneurSinonI16Dec task dispatch failed");
                return;
            }

            AutoEntryScript aes(uniFFIXPCOMGlobal, "RondpointScaffolding::Rondpoint9336OptionneurSinonI16Dec call resolve");
            RootedDictionary<UniFFIRustCallResult> returnValue(aes.cx());

            rondpoint_9336_optionneur_sinon_i16_dec::ReturnResult(aes.cx(), aResult.ResolveValue(), returnValue);
            uniFFIReturnPromise->MaybeResolve(returnValue);
            }
    );

    // Return the JS promise, using forget() to convert it to already_AddRefed
    return uniFFIReturnPromise.forget();
}
using namespace uniffi::rondpoint;
already_AddRefed<Promise> RondpointScaffolding::Rondpoint9336OptionneurSinonU32Dec(const GlobalObject& aUniFFIGlobal,const UniFFIPointer& ptr, const uint32_t& value,
 ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args

    // Create the promise that we return to JS
    nsCOMPtr<nsIGlobalObject> uniFFIXPCOMGlobal = do_QueryInterface(aUniFFIGlobal.GetAsSupports());
    RefPtr<Promise> uniFFIReturnPromise = Promise::Create(uniFFIXPCOMGlobal, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Prepare arguments to pass to Rust
    auto uniFFIArgs = rondpoint_9336_optionneur_sinon_u32_dec::PrepareArgs(ptr, value, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Create a second promise that gets resolved by a background task that calls the scaffolding function
    using UniFFITaskPromise = MozPromise<rondpoint_9336_optionneur_sinon_u32_dec::Result, nsresult, true>;
    RefPtr uniFFITaskPromise = new UniFFITaskPromise::Private(__func__);
    nsresult uniFFIDispatchResult = NS_DispatchBackgroundTask(
            NS_NewRunnableFunction(
                "RondpointScaffolding::Rondpoint9336OptionneurSinonU32Dec",
                [args = std::move(uniFFIArgs), uniFFITaskPromise]() mutable {
                auto result = rondpoint_9336_optionneur_sinon_u32_dec::Invoke(args);
                uniFFITaskPromise->Resolve(std::move(result), __func__);
            }),
            NS_DISPATCH_EVENT_MAY_BLOCK);
    if (NS_FAILED(uniFFIDispatchResult)) {
        uniFFITaskPromise->Reject(uniFFIDispatchResult, __func__);
    }

    // When the background task promise completes, resolve the JS promise
    uniFFITaskPromise->Then(GetCurrentSerialEventTarget(), __func__,
            [uniFFIXPCOMGlobal, uniFFIReturnPromise](UniFFITaskPromise::ResolveOrRejectValue&& aResult) {
            if (!aResult.IsResolve()) {
                uniFFIReturnPromise->MaybeRejectWithUnknownError("RondpointScaffolding::Rondpoint9336OptionneurSinonU32Dec task dispatch failed");
                return;
            }

            AutoEntryScript aes(uniFFIXPCOMGlobal, "RondpointScaffolding::Rondpoint9336OptionneurSinonU32Dec call resolve");
            RootedDictionary<UniFFIRustCallResult> returnValue(aes.cx());

            rondpoint_9336_optionneur_sinon_u32_dec::ReturnResult(aes.cx(), aResult.ResolveValue(), returnValue);
            uniFFIReturnPromise->MaybeResolve(returnValue);
            }
    );

    // Return the JS promise, using forget() to convert it to already_AddRefed
    return uniFFIReturnPromise.forget();
}
using namespace uniffi::rondpoint;
already_AddRefed<Promise> RondpointScaffolding::Rondpoint9336OptionneurSinonI32Dec(const GlobalObject& aUniFFIGlobal,const UniFFIPointer& ptr, const int32_t& value,
 ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args

    // Create the promise that we return to JS
    nsCOMPtr<nsIGlobalObject> uniFFIXPCOMGlobal = do_QueryInterface(aUniFFIGlobal.GetAsSupports());
    RefPtr<Promise> uniFFIReturnPromise = Promise::Create(uniFFIXPCOMGlobal, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Prepare arguments to pass to Rust
    auto uniFFIArgs = rondpoint_9336_optionneur_sinon_i32_dec::PrepareArgs(ptr, value, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Create a second promise that gets resolved by a background task that calls the scaffolding function
    using UniFFITaskPromise = MozPromise<rondpoint_9336_optionneur_sinon_i32_dec::Result, nsresult, true>;
    RefPtr uniFFITaskPromise = new UniFFITaskPromise::Private(__func__);
    nsresult uniFFIDispatchResult = NS_DispatchBackgroundTask(
            NS_NewRunnableFunction(
                "RondpointScaffolding::Rondpoint9336OptionneurSinonI32Dec",
                [args = std::move(uniFFIArgs), uniFFITaskPromise]() mutable {
                auto result = rondpoint_9336_optionneur_sinon_i32_dec::Invoke(args);
                uniFFITaskPromise->Resolve(std::move(result), __func__);
            }),
            NS_DISPATCH_EVENT_MAY_BLOCK);
    if (NS_FAILED(uniFFIDispatchResult)) {
        uniFFITaskPromise->Reject(uniFFIDispatchResult, __func__);
    }

    // When the background task promise completes, resolve the JS promise
    uniFFITaskPromise->Then(GetCurrentSerialEventTarget(), __func__,
            [uniFFIXPCOMGlobal, uniFFIReturnPromise](UniFFITaskPromise::ResolveOrRejectValue&& aResult) {
            if (!aResult.IsResolve()) {
                uniFFIReturnPromise->MaybeRejectWithUnknownError("RondpointScaffolding::Rondpoint9336OptionneurSinonI32Dec task dispatch failed");
                return;
            }

            AutoEntryScript aes(uniFFIXPCOMGlobal, "RondpointScaffolding::Rondpoint9336OptionneurSinonI32Dec call resolve");
            RootedDictionary<UniFFIRustCallResult> returnValue(aes.cx());

            rondpoint_9336_optionneur_sinon_i32_dec::ReturnResult(aes.cx(), aResult.ResolveValue(), returnValue);
            uniFFIReturnPromise->MaybeResolve(returnValue);
            }
    );

    // Return the JS promise, using forget() to convert it to already_AddRefed
    return uniFFIReturnPromise.forget();
}
using namespace uniffi::rondpoint;
already_AddRefed<Promise> RondpointScaffolding::Rondpoint9336OptionneurSinonU64Dec(const GlobalObject& aUniFFIGlobal,const UniFFIPointer& ptr, const uint64_t& value,
 ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args

    // Create the promise that we return to JS
    nsCOMPtr<nsIGlobalObject> uniFFIXPCOMGlobal = do_QueryInterface(aUniFFIGlobal.GetAsSupports());
    RefPtr<Promise> uniFFIReturnPromise = Promise::Create(uniFFIXPCOMGlobal, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Prepare arguments to pass to Rust
    auto uniFFIArgs = rondpoint_9336_optionneur_sinon_u64_dec::PrepareArgs(ptr, value, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Create a second promise that gets resolved by a background task that calls the scaffolding function
    using UniFFITaskPromise = MozPromise<rondpoint_9336_optionneur_sinon_u64_dec::Result, nsresult, true>;
    RefPtr uniFFITaskPromise = new UniFFITaskPromise::Private(__func__);
    nsresult uniFFIDispatchResult = NS_DispatchBackgroundTask(
            NS_NewRunnableFunction(
                "RondpointScaffolding::Rondpoint9336OptionneurSinonU64Dec",
                [args = std::move(uniFFIArgs), uniFFITaskPromise]() mutable {
                auto result = rondpoint_9336_optionneur_sinon_u64_dec::Invoke(args);
                uniFFITaskPromise->Resolve(std::move(result), __func__);
            }),
            NS_DISPATCH_EVENT_MAY_BLOCK);
    if (NS_FAILED(uniFFIDispatchResult)) {
        uniFFITaskPromise->Reject(uniFFIDispatchResult, __func__);
    }

    // When the background task promise completes, resolve the JS promise
    uniFFITaskPromise->Then(GetCurrentSerialEventTarget(), __func__,
            [uniFFIXPCOMGlobal, uniFFIReturnPromise](UniFFITaskPromise::ResolveOrRejectValue&& aResult) {
            if (!aResult.IsResolve()) {
                uniFFIReturnPromise->MaybeRejectWithUnknownError("RondpointScaffolding::Rondpoint9336OptionneurSinonU64Dec task dispatch failed");
                return;
            }

            AutoEntryScript aes(uniFFIXPCOMGlobal, "RondpointScaffolding::Rondpoint9336OptionneurSinonU64Dec call resolve");
            RootedDictionary<UniFFIRustCallResult> returnValue(aes.cx());

            rondpoint_9336_optionneur_sinon_u64_dec::ReturnResult(aes.cx(), aResult.ResolveValue(), returnValue);
            uniFFIReturnPromise->MaybeResolve(returnValue);
            }
    );

    // Return the JS promise, using forget() to convert it to already_AddRefed
    return uniFFIReturnPromise.forget();
}
using namespace uniffi::rondpoint;
already_AddRefed<Promise> RondpointScaffolding::Rondpoint9336OptionneurSinonI64Dec(const GlobalObject& aUniFFIGlobal,const UniFFIPointer& ptr, const int64_t& value,
 ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args

    // Create the promise that we return to JS
    nsCOMPtr<nsIGlobalObject> uniFFIXPCOMGlobal = do_QueryInterface(aUniFFIGlobal.GetAsSupports());
    RefPtr<Promise> uniFFIReturnPromise = Promise::Create(uniFFIXPCOMGlobal, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Prepare arguments to pass to Rust
    auto uniFFIArgs = rondpoint_9336_optionneur_sinon_i64_dec::PrepareArgs(ptr, value, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Create a second promise that gets resolved by a background task that calls the scaffolding function
    using UniFFITaskPromise = MozPromise<rondpoint_9336_optionneur_sinon_i64_dec::Result, nsresult, true>;
    RefPtr uniFFITaskPromise = new UniFFITaskPromise::Private(__func__);
    nsresult uniFFIDispatchResult = NS_DispatchBackgroundTask(
            NS_NewRunnableFunction(
                "RondpointScaffolding::Rondpoint9336OptionneurSinonI64Dec",
                [args = std::move(uniFFIArgs), uniFFITaskPromise]() mutable {
                auto result = rondpoint_9336_optionneur_sinon_i64_dec::Invoke(args);
                uniFFITaskPromise->Resolve(std::move(result), __func__);
            }),
            NS_DISPATCH_EVENT_MAY_BLOCK);
    if (NS_FAILED(uniFFIDispatchResult)) {
        uniFFITaskPromise->Reject(uniFFIDispatchResult, __func__);
    }

    // When the background task promise completes, resolve the JS promise
    uniFFITaskPromise->Then(GetCurrentSerialEventTarget(), __func__,
            [uniFFIXPCOMGlobal, uniFFIReturnPromise](UniFFITaskPromise::ResolveOrRejectValue&& aResult) {
            if (!aResult.IsResolve()) {
                uniFFIReturnPromise->MaybeRejectWithUnknownError("RondpointScaffolding::Rondpoint9336OptionneurSinonI64Dec task dispatch failed");
                return;
            }

            AutoEntryScript aes(uniFFIXPCOMGlobal, "RondpointScaffolding::Rondpoint9336OptionneurSinonI64Dec call resolve");
            RootedDictionary<UniFFIRustCallResult> returnValue(aes.cx());

            rondpoint_9336_optionneur_sinon_i64_dec::ReturnResult(aes.cx(), aResult.ResolveValue(), returnValue);
            uniFFIReturnPromise->MaybeResolve(returnValue);
            }
    );

    // Return the JS promise, using forget() to convert it to already_AddRefed
    return uniFFIReturnPromise.forget();
}
using namespace uniffi::rondpoint;
already_AddRefed<Promise> RondpointScaffolding::Rondpoint9336OptionneurSinonU8Hex(const GlobalObject& aUniFFIGlobal,const UniFFIPointer& ptr, const uint8_t& value,
 ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args

    // Create the promise that we return to JS
    nsCOMPtr<nsIGlobalObject> uniFFIXPCOMGlobal = do_QueryInterface(aUniFFIGlobal.GetAsSupports());
    RefPtr<Promise> uniFFIReturnPromise = Promise::Create(uniFFIXPCOMGlobal, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Prepare arguments to pass to Rust
    auto uniFFIArgs = rondpoint_9336_optionneur_sinon_u8_hex::PrepareArgs(ptr, value, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Create a second promise that gets resolved by a background task that calls the scaffolding function
    using UniFFITaskPromise = MozPromise<rondpoint_9336_optionneur_sinon_u8_hex::Result, nsresult, true>;
    RefPtr uniFFITaskPromise = new UniFFITaskPromise::Private(__func__);
    nsresult uniFFIDispatchResult = NS_DispatchBackgroundTask(
            NS_NewRunnableFunction(
                "RondpointScaffolding::Rondpoint9336OptionneurSinonU8Hex",
                [args = std::move(uniFFIArgs), uniFFITaskPromise]() mutable {
                auto result = rondpoint_9336_optionneur_sinon_u8_hex::Invoke(args);
                uniFFITaskPromise->Resolve(std::move(result), __func__);
            }),
            NS_DISPATCH_EVENT_MAY_BLOCK);
    if (NS_FAILED(uniFFIDispatchResult)) {
        uniFFITaskPromise->Reject(uniFFIDispatchResult, __func__);
    }

    // When the background task promise completes, resolve the JS promise
    uniFFITaskPromise->Then(GetCurrentSerialEventTarget(), __func__,
            [uniFFIXPCOMGlobal, uniFFIReturnPromise](UniFFITaskPromise::ResolveOrRejectValue&& aResult) {
            if (!aResult.IsResolve()) {
                uniFFIReturnPromise->MaybeRejectWithUnknownError("RondpointScaffolding::Rondpoint9336OptionneurSinonU8Hex task dispatch failed");
                return;
            }

            AutoEntryScript aes(uniFFIXPCOMGlobal, "RondpointScaffolding::Rondpoint9336OptionneurSinonU8Hex call resolve");
            RootedDictionary<UniFFIRustCallResult> returnValue(aes.cx());

            rondpoint_9336_optionneur_sinon_u8_hex::ReturnResult(aes.cx(), aResult.ResolveValue(), returnValue);
            uniFFIReturnPromise->MaybeResolve(returnValue);
            }
    );

    // Return the JS promise, using forget() to convert it to already_AddRefed
    return uniFFIReturnPromise.forget();
}
using namespace uniffi::rondpoint;
already_AddRefed<Promise> RondpointScaffolding::Rondpoint9336OptionneurSinonI8Hex(const GlobalObject& aUniFFIGlobal,const UniFFIPointer& ptr, const int8_t& value,
 ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args

    // Create the promise that we return to JS
    nsCOMPtr<nsIGlobalObject> uniFFIXPCOMGlobal = do_QueryInterface(aUniFFIGlobal.GetAsSupports());
    RefPtr<Promise> uniFFIReturnPromise = Promise::Create(uniFFIXPCOMGlobal, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Prepare arguments to pass to Rust
    auto uniFFIArgs = rondpoint_9336_optionneur_sinon_i8_hex::PrepareArgs(ptr, value, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Create a second promise that gets resolved by a background task that calls the scaffolding function
    using UniFFITaskPromise = MozPromise<rondpoint_9336_optionneur_sinon_i8_hex::Result, nsresult, true>;
    RefPtr uniFFITaskPromise = new UniFFITaskPromise::Private(__func__);
    nsresult uniFFIDispatchResult = NS_DispatchBackgroundTask(
            NS_NewRunnableFunction(
                "RondpointScaffolding::Rondpoint9336OptionneurSinonI8Hex",
                [args = std::move(uniFFIArgs), uniFFITaskPromise]() mutable {
                auto result = rondpoint_9336_optionneur_sinon_i8_hex::Invoke(args);
                uniFFITaskPromise->Resolve(std::move(result), __func__);
            }),
            NS_DISPATCH_EVENT_MAY_BLOCK);
    if (NS_FAILED(uniFFIDispatchResult)) {
        uniFFITaskPromise->Reject(uniFFIDispatchResult, __func__);
    }

    // When the background task promise completes, resolve the JS promise
    uniFFITaskPromise->Then(GetCurrentSerialEventTarget(), __func__,
            [uniFFIXPCOMGlobal, uniFFIReturnPromise](UniFFITaskPromise::ResolveOrRejectValue&& aResult) {
            if (!aResult.IsResolve()) {
                uniFFIReturnPromise->MaybeRejectWithUnknownError("RondpointScaffolding::Rondpoint9336OptionneurSinonI8Hex task dispatch failed");
                return;
            }

            AutoEntryScript aes(uniFFIXPCOMGlobal, "RondpointScaffolding::Rondpoint9336OptionneurSinonI8Hex call resolve");
            RootedDictionary<UniFFIRustCallResult> returnValue(aes.cx());

            rondpoint_9336_optionneur_sinon_i8_hex::ReturnResult(aes.cx(), aResult.ResolveValue(), returnValue);
            uniFFIReturnPromise->MaybeResolve(returnValue);
            }
    );

    // Return the JS promise, using forget() to convert it to already_AddRefed
    return uniFFIReturnPromise.forget();
}
using namespace uniffi::rondpoint;
already_AddRefed<Promise> RondpointScaffolding::Rondpoint9336OptionneurSinonU16Hex(const GlobalObject& aUniFFIGlobal,const UniFFIPointer& ptr, const uint16_t& value,
 ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args

    // Create the promise that we return to JS
    nsCOMPtr<nsIGlobalObject> uniFFIXPCOMGlobal = do_QueryInterface(aUniFFIGlobal.GetAsSupports());
    RefPtr<Promise> uniFFIReturnPromise = Promise::Create(uniFFIXPCOMGlobal, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Prepare arguments to pass to Rust
    auto uniFFIArgs = rondpoint_9336_optionneur_sinon_u16_hex::PrepareArgs(ptr, value, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Create a second promise that gets resolved by a background task that calls the scaffolding function
    using UniFFITaskPromise = MozPromise<rondpoint_9336_optionneur_sinon_u16_hex::Result, nsresult, true>;
    RefPtr uniFFITaskPromise = new UniFFITaskPromise::Private(__func__);
    nsresult uniFFIDispatchResult = NS_DispatchBackgroundTask(
            NS_NewRunnableFunction(
                "RondpointScaffolding::Rondpoint9336OptionneurSinonU16Hex",
                [args = std::move(uniFFIArgs), uniFFITaskPromise]() mutable {
                auto result = rondpoint_9336_optionneur_sinon_u16_hex::Invoke(args);
                uniFFITaskPromise->Resolve(std::move(result), __func__);
            }),
            NS_DISPATCH_EVENT_MAY_BLOCK);
    if (NS_FAILED(uniFFIDispatchResult)) {
        uniFFITaskPromise->Reject(uniFFIDispatchResult, __func__);
    }

    // When the background task promise completes, resolve the JS promise
    uniFFITaskPromise->Then(GetCurrentSerialEventTarget(), __func__,
            [uniFFIXPCOMGlobal, uniFFIReturnPromise](UniFFITaskPromise::ResolveOrRejectValue&& aResult) {
            if (!aResult.IsResolve()) {
                uniFFIReturnPromise->MaybeRejectWithUnknownError("RondpointScaffolding::Rondpoint9336OptionneurSinonU16Hex task dispatch failed");
                return;
            }

            AutoEntryScript aes(uniFFIXPCOMGlobal, "RondpointScaffolding::Rondpoint9336OptionneurSinonU16Hex call resolve");
            RootedDictionary<UniFFIRustCallResult> returnValue(aes.cx());

            rondpoint_9336_optionneur_sinon_u16_hex::ReturnResult(aes.cx(), aResult.ResolveValue(), returnValue);
            uniFFIReturnPromise->MaybeResolve(returnValue);
            }
    );

    // Return the JS promise, using forget() to convert it to already_AddRefed
    return uniFFIReturnPromise.forget();
}
using namespace uniffi::rondpoint;
already_AddRefed<Promise> RondpointScaffolding::Rondpoint9336OptionneurSinonI16Hex(const GlobalObject& aUniFFIGlobal,const UniFFIPointer& ptr, const int16_t& value,
 ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args

    // Create the promise that we return to JS
    nsCOMPtr<nsIGlobalObject> uniFFIXPCOMGlobal = do_QueryInterface(aUniFFIGlobal.GetAsSupports());
    RefPtr<Promise> uniFFIReturnPromise = Promise::Create(uniFFIXPCOMGlobal, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Prepare arguments to pass to Rust
    auto uniFFIArgs = rondpoint_9336_optionneur_sinon_i16_hex::PrepareArgs(ptr, value, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Create a second promise that gets resolved by a background task that calls the scaffolding function
    using UniFFITaskPromise = MozPromise<rondpoint_9336_optionneur_sinon_i16_hex::Result, nsresult, true>;
    RefPtr uniFFITaskPromise = new UniFFITaskPromise::Private(__func__);
    nsresult uniFFIDispatchResult = NS_DispatchBackgroundTask(
            NS_NewRunnableFunction(
                "RondpointScaffolding::Rondpoint9336OptionneurSinonI16Hex",
                [args = std::move(uniFFIArgs), uniFFITaskPromise]() mutable {
                auto result = rondpoint_9336_optionneur_sinon_i16_hex::Invoke(args);
                uniFFITaskPromise->Resolve(std::move(result), __func__);
            }),
            NS_DISPATCH_EVENT_MAY_BLOCK);
    if (NS_FAILED(uniFFIDispatchResult)) {
        uniFFITaskPromise->Reject(uniFFIDispatchResult, __func__);
    }

    // When the background task promise completes, resolve the JS promise
    uniFFITaskPromise->Then(GetCurrentSerialEventTarget(), __func__,
            [uniFFIXPCOMGlobal, uniFFIReturnPromise](UniFFITaskPromise::ResolveOrRejectValue&& aResult) {
            if (!aResult.IsResolve()) {
                uniFFIReturnPromise->MaybeRejectWithUnknownError("RondpointScaffolding::Rondpoint9336OptionneurSinonI16Hex task dispatch failed");
                return;
            }

            AutoEntryScript aes(uniFFIXPCOMGlobal, "RondpointScaffolding::Rondpoint9336OptionneurSinonI16Hex call resolve");
            RootedDictionary<UniFFIRustCallResult> returnValue(aes.cx());

            rondpoint_9336_optionneur_sinon_i16_hex::ReturnResult(aes.cx(), aResult.ResolveValue(), returnValue);
            uniFFIReturnPromise->MaybeResolve(returnValue);
            }
    );

    // Return the JS promise, using forget() to convert it to already_AddRefed
    return uniFFIReturnPromise.forget();
}
using namespace uniffi::rondpoint;
already_AddRefed<Promise> RondpointScaffolding::Rondpoint9336OptionneurSinonU32Hex(const GlobalObject& aUniFFIGlobal,const UniFFIPointer& ptr, const uint32_t& value,
 ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args

    // Create the promise that we return to JS
    nsCOMPtr<nsIGlobalObject> uniFFIXPCOMGlobal = do_QueryInterface(aUniFFIGlobal.GetAsSupports());
    RefPtr<Promise> uniFFIReturnPromise = Promise::Create(uniFFIXPCOMGlobal, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Prepare arguments to pass to Rust
    auto uniFFIArgs = rondpoint_9336_optionneur_sinon_u32_hex::PrepareArgs(ptr, value, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Create a second promise that gets resolved by a background task that calls the scaffolding function
    using UniFFITaskPromise = MozPromise<rondpoint_9336_optionneur_sinon_u32_hex::Result, nsresult, true>;
    RefPtr uniFFITaskPromise = new UniFFITaskPromise::Private(__func__);
    nsresult uniFFIDispatchResult = NS_DispatchBackgroundTask(
            NS_NewRunnableFunction(
                "RondpointScaffolding::Rondpoint9336OptionneurSinonU32Hex",
                [args = std::move(uniFFIArgs), uniFFITaskPromise]() mutable {
                auto result = rondpoint_9336_optionneur_sinon_u32_hex::Invoke(args);
                uniFFITaskPromise->Resolve(std::move(result), __func__);
            }),
            NS_DISPATCH_EVENT_MAY_BLOCK);
    if (NS_FAILED(uniFFIDispatchResult)) {
        uniFFITaskPromise->Reject(uniFFIDispatchResult, __func__);
    }

    // When the background task promise completes, resolve the JS promise
    uniFFITaskPromise->Then(GetCurrentSerialEventTarget(), __func__,
            [uniFFIXPCOMGlobal, uniFFIReturnPromise](UniFFITaskPromise::ResolveOrRejectValue&& aResult) {
            if (!aResult.IsResolve()) {
                uniFFIReturnPromise->MaybeRejectWithUnknownError("RondpointScaffolding::Rondpoint9336OptionneurSinonU32Hex task dispatch failed");
                return;
            }

            AutoEntryScript aes(uniFFIXPCOMGlobal, "RondpointScaffolding::Rondpoint9336OptionneurSinonU32Hex call resolve");
            RootedDictionary<UniFFIRustCallResult> returnValue(aes.cx());

            rondpoint_9336_optionneur_sinon_u32_hex::ReturnResult(aes.cx(), aResult.ResolveValue(), returnValue);
            uniFFIReturnPromise->MaybeResolve(returnValue);
            }
    );

    // Return the JS promise, using forget() to convert it to already_AddRefed
    return uniFFIReturnPromise.forget();
}
using namespace uniffi::rondpoint;
already_AddRefed<Promise> RondpointScaffolding::Rondpoint9336OptionneurSinonI32Hex(const GlobalObject& aUniFFIGlobal,const UniFFIPointer& ptr, const int32_t& value,
 ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args

    // Create the promise that we return to JS
    nsCOMPtr<nsIGlobalObject> uniFFIXPCOMGlobal = do_QueryInterface(aUniFFIGlobal.GetAsSupports());
    RefPtr<Promise> uniFFIReturnPromise = Promise::Create(uniFFIXPCOMGlobal, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Prepare arguments to pass to Rust
    auto uniFFIArgs = rondpoint_9336_optionneur_sinon_i32_hex::PrepareArgs(ptr, value, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Create a second promise that gets resolved by a background task that calls the scaffolding function
    using UniFFITaskPromise = MozPromise<rondpoint_9336_optionneur_sinon_i32_hex::Result, nsresult, true>;
    RefPtr uniFFITaskPromise = new UniFFITaskPromise::Private(__func__);
    nsresult uniFFIDispatchResult = NS_DispatchBackgroundTask(
            NS_NewRunnableFunction(
                "RondpointScaffolding::Rondpoint9336OptionneurSinonI32Hex",
                [args = std::move(uniFFIArgs), uniFFITaskPromise]() mutable {
                auto result = rondpoint_9336_optionneur_sinon_i32_hex::Invoke(args);
                uniFFITaskPromise->Resolve(std::move(result), __func__);
            }),
            NS_DISPATCH_EVENT_MAY_BLOCK);
    if (NS_FAILED(uniFFIDispatchResult)) {
        uniFFITaskPromise->Reject(uniFFIDispatchResult, __func__);
    }

    // When the background task promise completes, resolve the JS promise
    uniFFITaskPromise->Then(GetCurrentSerialEventTarget(), __func__,
            [uniFFIXPCOMGlobal, uniFFIReturnPromise](UniFFITaskPromise::ResolveOrRejectValue&& aResult) {
            if (!aResult.IsResolve()) {
                uniFFIReturnPromise->MaybeRejectWithUnknownError("RondpointScaffolding::Rondpoint9336OptionneurSinonI32Hex task dispatch failed");
                return;
            }

            AutoEntryScript aes(uniFFIXPCOMGlobal, "RondpointScaffolding::Rondpoint9336OptionneurSinonI32Hex call resolve");
            RootedDictionary<UniFFIRustCallResult> returnValue(aes.cx());

            rondpoint_9336_optionneur_sinon_i32_hex::ReturnResult(aes.cx(), aResult.ResolveValue(), returnValue);
            uniFFIReturnPromise->MaybeResolve(returnValue);
            }
    );

    // Return the JS promise, using forget() to convert it to already_AddRefed
    return uniFFIReturnPromise.forget();
}
using namespace uniffi::rondpoint;
already_AddRefed<Promise> RondpointScaffolding::Rondpoint9336OptionneurSinonU64Hex(const GlobalObject& aUniFFIGlobal,const UniFFIPointer& ptr, const uint64_t& value,
 ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args

    // Create the promise that we return to JS
    nsCOMPtr<nsIGlobalObject> uniFFIXPCOMGlobal = do_QueryInterface(aUniFFIGlobal.GetAsSupports());
    RefPtr<Promise> uniFFIReturnPromise = Promise::Create(uniFFIXPCOMGlobal, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Prepare arguments to pass to Rust
    auto uniFFIArgs = rondpoint_9336_optionneur_sinon_u64_hex::PrepareArgs(ptr, value, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Create a second promise that gets resolved by a background task that calls the scaffolding function
    using UniFFITaskPromise = MozPromise<rondpoint_9336_optionneur_sinon_u64_hex::Result, nsresult, true>;
    RefPtr uniFFITaskPromise = new UniFFITaskPromise::Private(__func__);
    nsresult uniFFIDispatchResult = NS_DispatchBackgroundTask(
            NS_NewRunnableFunction(
                "RondpointScaffolding::Rondpoint9336OptionneurSinonU64Hex",
                [args = std::move(uniFFIArgs), uniFFITaskPromise]() mutable {
                auto result = rondpoint_9336_optionneur_sinon_u64_hex::Invoke(args);
                uniFFITaskPromise->Resolve(std::move(result), __func__);
            }),
            NS_DISPATCH_EVENT_MAY_BLOCK);
    if (NS_FAILED(uniFFIDispatchResult)) {
        uniFFITaskPromise->Reject(uniFFIDispatchResult, __func__);
    }

    // When the background task promise completes, resolve the JS promise
    uniFFITaskPromise->Then(GetCurrentSerialEventTarget(), __func__,
            [uniFFIXPCOMGlobal, uniFFIReturnPromise](UniFFITaskPromise::ResolveOrRejectValue&& aResult) {
            if (!aResult.IsResolve()) {
                uniFFIReturnPromise->MaybeRejectWithUnknownError("RondpointScaffolding::Rondpoint9336OptionneurSinonU64Hex task dispatch failed");
                return;
            }

            AutoEntryScript aes(uniFFIXPCOMGlobal, "RondpointScaffolding::Rondpoint9336OptionneurSinonU64Hex call resolve");
            RootedDictionary<UniFFIRustCallResult> returnValue(aes.cx());

            rondpoint_9336_optionneur_sinon_u64_hex::ReturnResult(aes.cx(), aResult.ResolveValue(), returnValue);
            uniFFIReturnPromise->MaybeResolve(returnValue);
            }
    );

    // Return the JS promise, using forget() to convert it to already_AddRefed
    return uniFFIReturnPromise.forget();
}
using namespace uniffi::rondpoint;
already_AddRefed<Promise> RondpointScaffolding::Rondpoint9336OptionneurSinonI64Hex(const GlobalObject& aUniFFIGlobal,const UniFFIPointer& ptr, const int64_t& value,
 ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args

    // Create the promise that we return to JS
    nsCOMPtr<nsIGlobalObject> uniFFIXPCOMGlobal = do_QueryInterface(aUniFFIGlobal.GetAsSupports());
    RefPtr<Promise> uniFFIReturnPromise = Promise::Create(uniFFIXPCOMGlobal, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Prepare arguments to pass to Rust
    auto uniFFIArgs = rondpoint_9336_optionneur_sinon_i64_hex::PrepareArgs(ptr, value, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Create a second promise that gets resolved by a background task that calls the scaffolding function
    using UniFFITaskPromise = MozPromise<rondpoint_9336_optionneur_sinon_i64_hex::Result, nsresult, true>;
    RefPtr uniFFITaskPromise = new UniFFITaskPromise::Private(__func__);
    nsresult uniFFIDispatchResult = NS_DispatchBackgroundTask(
            NS_NewRunnableFunction(
                "RondpointScaffolding::Rondpoint9336OptionneurSinonI64Hex",
                [args = std::move(uniFFIArgs), uniFFITaskPromise]() mutable {
                auto result = rondpoint_9336_optionneur_sinon_i64_hex::Invoke(args);
                uniFFITaskPromise->Resolve(std::move(result), __func__);
            }),
            NS_DISPATCH_EVENT_MAY_BLOCK);
    if (NS_FAILED(uniFFIDispatchResult)) {
        uniFFITaskPromise->Reject(uniFFIDispatchResult, __func__);
    }

    // When the background task promise completes, resolve the JS promise
    uniFFITaskPromise->Then(GetCurrentSerialEventTarget(), __func__,
            [uniFFIXPCOMGlobal, uniFFIReturnPromise](UniFFITaskPromise::ResolveOrRejectValue&& aResult) {
            if (!aResult.IsResolve()) {
                uniFFIReturnPromise->MaybeRejectWithUnknownError("RondpointScaffolding::Rondpoint9336OptionneurSinonI64Hex task dispatch failed");
                return;
            }

            AutoEntryScript aes(uniFFIXPCOMGlobal, "RondpointScaffolding::Rondpoint9336OptionneurSinonI64Hex call resolve");
            RootedDictionary<UniFFIRustCallResult> returnValue(aes.cx());

            rondpoint_9336_optionneur_sinon_i64_hex::ReturnResult(aes.cx(), aResult.ResolveValue(), returnValue);
            uniFFIReturnPromise->MaybeResolve(returnValue);
            }
    );

    // Return the JS promise, using forget() to convert it to already_AddRefed
    return uniFFIReturnPromise.forget();
}
using namespace uniffi::rondpoint;
already_AddRefed<Promise> RondpointScaffolding::Rondpoint9336OptionneurSinonU32Oct(const GlobalObject& aUniFFIGlobal,const UniFFIPointer& ptr, const uint32_t& value,
 ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args

    // Create the promise that we return to JS
    nsCOMPtr<nsIGlobalObject> uniFFIXPCOMGlobal = do_QueryInterface(aUniFFIGlobal.GetAsSupports());
    RefPtr<Promise> uniFFIReturnPromise = Promise::Create(uniFFIXPCOMGlobal, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Prepare arguments to pass to Rust
    auto uniFFIArgs = rondpoint_9336_optionneur_sinon_u32_oct::PrepareArgs(ptr, value, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Create a second promise that gets resolved by a background task that calls the scaffolding function
    using UniFFITaskPromise = MozPromise<rondpoint_9336_optionneur_sinon_u32_oct::Result, nsresult, true>;
    RefPtr uniFFITaskPromise = new UniFFITaskPromise::Private(__func__);
    nsresult uniFFIDispatchResult = NS_DispatchBackgroundTask(
            NS_NewRunnableFunction(
                "RondpointScaffolding::Rondpoint9336OptionneurSinonU32Oct",
                [args = std::move(uniFFIArgs), uniFFITaskPromise]() mutable {
                auto result = rondpoint_9336_optionneur_sinon_u32_oct::Invoke(args);
                uniFFITaskPromise->Resolve(std::move(result), __func__);
            }),
            NS_DISPATCH_EVENT_MAY_BLOCK);
    if (NS_FAILED(uniFFIDispatchResult)) {
        uniFFITaskPromise->Reject(uniFFIDispatchResult, __func__);
    }

    // When the background task promise completes, resolve the JS promise
    uniFFITaskPromise->Then(GetCurrentSerialEventTarget(), __func__,
            [uniFFIXPCOMGlobal, uniFFIReturnPromise](UniFFITaskPromise::ResolveOrRejectValue&& aResult) {
            if (!aResult.IsResolve()) {
                uniFFIReturnPromise->MaybeRejectWithUnknownError("RondpointScaffolding::Rondpoint9336OptionneurSinonU32Oct task dispatch failed");
                return;
            }

            AutoEntryScript aes(uniFFIXPCOMGlobal, "RondpointScaffolding::Rondpoint9336OptionneurSinonU32Oct call resolve");
            RootedDictionary<UniFFIRustCallResult> returnValue(aes.cx());

            rondpoint_9336_optionneur_sinon_u32_oct::ReturnResult(aes.cx(), aResult.ResolveValue(), returnValue);
            uniFFIReturnPromise->MaybeResolve(returnValue);
            }
    );

    // Return the JS promise, using forget() to convert it to already_AddRefed
    return uniFFIReturnPromise.forget();
}
using namespace uniffi::rondpoint;
already_AddRefed<Promise> RondpointScaffolding::Rondpoint9336OptionneurSinonF32(const GlobalObject& aUniFFIGlobal,const UniFFIPointer& ptr, const float& value,
 ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args

    // Create the promise that we return to JS
    nsCOMPtr<nsIGlobalObject> uniFFIXPCOMGlobal = do_QueryInterface(aUniFFIGlobal.GetAsSupports());
    RefPtr<Promise> uniFFIReturnPromise = Promise::Create(uniFFIXPCOMGlobal, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Prepare arguments to pass to Rust
    auto uniFFIArgs = rondpoint_9336_optionneur_sinon_f32::PrepareArgs(ptr, value, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Create a second promise that gets resolved by a background task that calls the scaffolding function
    using UniFFITaskPromise = MozPromise<rondpoint_9336_optionneur_sinon_f32::Result, nsresult, true>;
    RefPtr uniFFITaskPromise = new UniFFITaskPromise::Private(__func__);
    nsresult uniFFIDispatchResult = NS_DispatchBackgroundTask(
            NS_NewRunnableFunction(
                "RondpointScaffolding::Rondpoint9336OptionneurSinonF32",
                [args = std::move(uniFFIArgs), uniFFITaskPromise]() mutable {
                auto result = rondpoint_9336_optionneur_sinon_f32::Invoke(args);
                uniFFITaskPromise->Resolve(std::move(result), __func__);
            }),
            NS_DISPATCH_EVENT_MAY_BLOCK);
    if (NS_FAILED(uniFFIDispatchResult)) {
        uniFFITaskPromise->Reject(uniFFIDispatchResult, __func__);
    }

    // When the background task promise completes, resolve the JS promise
    uniFFITaskPromise->Then(GetCurrentSerialEventTarget(), __func__,
            [uniFFIXPCOMGlobal, uniFFIReturnPromise](UniFFITaskPromise::ResolveOrRejectValue&& aResult) {
            if (!aResult.IsResolve()) {
                uniFFIReturnPromise->MaybeRejectWithUnknownError("RondpointScaffolding::Rondpoint9336OptionneurSinonF32 task dispatch failed");
                return;
            }

            AutoEntryScript aes(uniFFIXPCOMGlobal, "RondpointScaffolding::Rondpoint9336OptionneurSinonF32 call resolve");
            RootedDictionary<UniFFIRustCallResult> returnValue(aes.cx());

            rondpoint_9336_optionneur_sinon_f32::ReturnResult(aes.cx(), aResult.ResolveValue(), returnValue);
            uniFFIReturnPromise->MaybeResolve(returnValue);
            }
    );

    // Return the JS promise, using forget() to convert it to already_AddRefed
    return uniFFIReturnPromise.forget();
}
using namespace uniffi::rondpoint;
already_AddRefed<Promise> RondpointScaffolding::Rondpoint9336OptionneurSinonF64(const GlobalObject& aUniFFIGlobal,const UniFFIPointer& ptr, const double& value,
 ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args

    // Create the promise that we return to JS
    nsCOMPtr<nsIGlobalObject> uniFFIXPCOMGlobal = do_QueryInterface(aUniFFIGlobal.GetAsSupports());
    RefPtr<Promise> uniFFIReturnPromise = Promise::Create(uniFFIXPCOMGlobal, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Prepare arguments to pass to Rust
    auto uniFFIArgs = rondpoint_9336_optionneur_sinon_f64::PrepareArgs(ptr, value, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Create a second promise that gets resolved by a background task that calls the scaffolding function
    using UniFFITaskPromise = MozPromise<rondpoint_9336_optionneur_sinon_f64::Result, nsresult, true>;
    RefPtr uniFFITaskPromise = new UniFFITaskPromise::Private(__func__);
    nsresult uniFFIDispatchResult = NS_DispatchBackgroundTask(
            NS_NewRunnableFunction(
                "RondpointScaffolding::Rondpoint9336OptionneurSinonF64",
                [args = std::move(uniFFIArgs), uniFFITaskPromise]() mutable {
                auto result = rondpoint_9336_optionneur_sinon_f64::Invoke(args);
                uniFFITaskPromise->Resolve(std::move(result), __func__);
            }),
            NS_DISPATCH_EVENT_MAY_BLOCK);
    if (NS_FAILED(uniFFIDispatchResult)) {
        uniFFITaskPromise->Reject(uniFFIDispatchResult, __func__);
    }

    // When the background task promise completes, resolve the JS promise
    uniFFITaskPromise->Then(GetCurrentSerialEventTarget(), __func__,
            [uniFFIXPCOMGlobal, uniFFIReturnPromise](UniFFITaskPromise::ResolveOrRejectValue&& aResult) {
            if (!aResult.IsResolve()) {
                uniFFIReturnPromise->MaybeRejectWithUnknownError("RondpointScaffolding::Rondpoint9336OptionneurSinonF64 task dispatch failed");
                return;
            }

            AutoEntryScript aes(uniFFIXPCOMGlobal, "RondpointScaffolding::Rondpoint9336OptionneurSinonF64 call resolve");
            RootedDictionary<UniFFIRustCallResult> returnValue(aes.cx());

            rondpoint_9336_optionneur_sinon_f64::ReturnResult(aes.cx(), aResult.ResolveValue(), returnValue);
            uniFFIReturnPromise->MaybeResolve(returnValue);
            }
    );

    // Return the JS promise, using forget() to convert it to already_AddRefed
    return uniFFIReturnPromise.forget();
}
using namespace uniffi::rondpoint;
already_AddRefed<Promise> RondpointScaffolding::Rondpoint9336OptionneurSinonEnum(const GlobalObject& aUniFFIGlobal,const UniFFIPointer& ptr, const ArrayBuffer& value,
 ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args

    // Create the promise that we return to JS
    nsCOMPtr<nsIGlobalObject> uniFFIXPCOMGlobal = do_QueryInterface(aUniFFIGlobal.GetAsSupports());
    RefPtr<Promise> uniFFIReturnPromise = Promise::Create(uniFFIXPCOMGlobal, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Prepare arguments to pass to Rust
    auto uniFFIArgs = rondpoint_9336_optionneur_sinon_enum::PrepareArgs(ptr, value, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Create a second promise that gets resolved by a background task that calls the scaffolding function
    using UniFFITaskPromise = MozPromise<rondpoint_9336_optionneur_sinon_enum::Result, nsresult, true>;
    RefPtr uniFFITaskPromise = new UniFFITaskPromise::Private(__func__);
    nsresult uniFFIDispatchResult = NS_DispatchBackgroundTask(
            NS_NewRunnableFunction(
                "RondpointScaffolding::Rondpoint9336OptionneurSinonEnum",
                [args = std::move(uniFFIArgs), uniFFITaskPromise]() mutable {
                auto result = rondpoint_9336_optionneur_sinon_enum::Invoke(args);
                uniFFITaskPromise->Resolve(std::move(result), __func__);
            }),
            NS_DISPATCH_EVENT_MAY_BLOCK);
    if (NS_FAILED(uniFFIDispatchResult)) {
        uniFFITaskPromise->Reject(uniFFIDispatchResult, __func__);
    }

    // When the background task promise completes, resolve the JS promise
    uniFFITaskPromise->Then(GetCurrentSerialEventTarget(), __func__,
            [uniFFIXPCOMGlobal, uniFFIReturnPromise](UniFFITaskPromise::ResolveOrRejectValue&& aResult) {
            if (!aResult.IsResolve()) {
                uniFFIReturnPromise->MaybeRejectWithUnknownError("RondpointScaffolding::Rondpoint9336OptionneurSinonEnum task dispatch failed");
                return;
            }

            AutoEntryScript aes(uniFFIXPCOMGlobal, "RondpointScaffolding::Rondpoint9336OptionneurSinonEnum call resolve");
            RootedDictionary<UniFFIRustCallResult> returnValue(aes.cx());

            rondpoint_9336_optionneur_sinon_enum::ReturnResult(aes.cx(), aResult.ResolveValue(), returnValue);
            uniFFIReturnPromise->MaybeResolve(returnValue);
            }
    );

    // Return the JS promise, using forget() to convert it to already_AddRefed
    return uniFFIReturnPromise.forget();
}
using namespace uniffi::rondpoint;
already_AddRefed<Promise> RondpointScaffolding::Rondpoint9336CopieDictionnaire(const GlobalObject& aUniFFIGlobal,const ArrayBuffer& d,
 ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args

    // Create the promise that we return to JS
    nsCOMPtr<nsIGlobalObject> uniFFIXPCOMGlobal = do_QueryInterface(aUniFFIGlobal.GetAsSupports());
    RefPtr<Promise> uniFFIReturnPromise = Promise::Create(uniFFIXPCOMGlobal, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Prepare arguments to pass to Rust
    auto uniFFIArgs = rondpoint_9336_copie_dictionnaire::PrepareArgs(d, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Create a second promise that gets resolved by a background task that calls the scaffolding function
    using UniFFITaskPromise = MozPromise<rondpoint_9336_copie_dictionnaire::Result, nsresult, true>;
    RefPtr uniFFITaskPromise = new UniFFITaskPromise::Private(__func__);
    nsresult uniFFIDispatchResult = NS_DispatchBackgroundTask(
            NS_NewRunnableFunction(
                "RondpointScaffolding::Rondpoint9336CopieDictionnaire",
                [args = std::move(uniFFIArgs), uniFFITaskPromise]() mutable {
                auto result = rondpoint_9336_copie_dictionnaire::Invoke(args);
                uniFFITaskPromise->Resolve(std::move(result), __func__);
            }),
            NS_DISPATCH_EVENT_MAY_BLOCK);
    if (NS_FAILED(uniFFIDispatchResult)) {
        uniFFITaskPromise->Reject(uniFFIDispatchResult, __func__);
    }

    // When the background task promise completes, resolve the JS promise
    uniFFITaskPromise->Then(GetCurrentSerialEventTarget(), __func__,
            [uniFFIXPCOMGlobal, uniFFIReturnPromise](UniFFITaskPromise::ResolveOrRejectValue&& aResult) {
            if (!aResult.IsResolve()) {
                uniFFIReturnPromise->MaybeRejectWithUnknownError("RondpointScaffolding::Rondpoint9336CopieDictionnaire task dispatch failed");
                return;
            }

            AutoEntryScript aes(uniFFIXPCOMGlobal, "RondpointScaffolding::Rondpoint9336CopieDictionnaire call resolve");
            RootedDictionary<UniFFIRustCallResult> returnValue(aes.cx());

            rondpoint_9336_copie_dictionnaire::ReturnResult(aes.cx(), aResult.ResolveValue(), returnValue);
            uniFFIReturnPromise->MaybeResolve(returnValue);
            }
    );

    // Return the JS promise, using forget() to convert it to already_AddRefed
    return uniFFIReturnPromise.forget();
}
using namespace uniffi::rondpoint;
already_AddRefed<Promise> RondpointScaffolding::Rondpoint9336CopieEnumeration(const GlobalObject& aUniFFIGlobal,const ArrayBuffer& e,
 ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args

    // Create the promise that we return to JS
    nsCOMPtr<nsIGlobalObject> uniFFIXPCOMGlobal = do_QueryInterface(aUniFFIGlobal.GetAsSupports());
    RefPtr<Promise> uniFFIReturnPromise = Promise::Create(uniFFIXPCOMGlobal, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Prepare arguments to pass to Rust
    auto uniFFIArgs = rondpoint_9336_copie_enumeration::PrepareArgs(e, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Create a second promise that gets resolved by a background task that calls the scaffolding function
    using UniFFITaskPromise = MozPromise<rondpoint_9336_copie_enumeration::Result, nsresult, true>;
    RefPtr uniFFITaskPromise = new UniFFITaskPromise::Private(__func__);
    nsresult uniFFIDispatchResult = NS_DispatchBackgroundTask(
            NS_NewRunnableFunction(
                "RondpointScaffolding::Rondpoint9336CopieEnumeration",
                [args = std::move(uniFFIArgs), uniFFITaskPromise]() mutable {
                auto result = rondpoint_9336_copie_enumeration::Invoke(args);
                uniFFITaskPromise->Resolve(std::move(result), __func__);
            }),
            NS_DISPATCH_EVENT_MAY_BLOCK);
    if (NS_FAILED(uniFFIDispatchResult)) {
        uniFFITaskPromise->Reject(uniFFIDispatchResult, __func__);
    }

    // When the background task promise completes, resolve the JS promise
    uniFFITaskPromise->Then(GetCurrentSerialEventTarget(), __func__,
            [uniFFIXPCOMGlobal, uniFFIReturnPromise](UniFFITaskPromise::ResolveOrRejectValue&& aResult) {
            if (!aResult.IsResolve()) {
                uniFFIReturnPromise->MaybeRejectWithUnknownError("RondpointScaffolding::Rondpoint9336CopieEnumeration task dispatch failed");
                return;
            }

            AutoEntryScript aes(uniFFIXPCOMGlobal, "RondpointScaffolding::Rondpoint9336CopieEnumeration call resolve");
            RootedDictionary<UniFFIRustCallResult> returnValue(aes.cx());

            rondpoint_9336_copie_enumeration::ReturnResult(aes.cx(), aResult.ResolveValue(), returnValue);
            uniFFIReturnPromise->MaybeResolve(returnValue);
            }
    );

    // Return the JS promise, using forget() to convert it to already_AddRefed
    return uniFFIReturnPromise.forget();
}
using namespace uniffi::rondpoint;
already_AddRefed<Promise> RondpointScaffolding::Rondpoint9336CopieEnumerations(const GlobalObject& aUniFFIGlobal,const ArrayBuffer& e,
 ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args

    // Create the promise that we return to JS
    nsCOMPtr<nsIGlobalObject> uniFFIXPCOMGlobal = do_QueryInterface(aUniFFIGlobal.GetAsSupports());
    RefPtr<Promise> uniFFIReturnPromise = Promise::Create(uniFFIXPCOMGlobal, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Prepare arguments to pass to Rust
    auto uniFFIArgs = rondpoint_9336_copie_enumerations::PrepareArgs(e, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Create a second promise that gets resolved by a background task that calls the scaffolding function
    using UniFFITaskPromise = MozPromise<rondpoint_9336_copie_enumerations::Result, nsresult, true>;
    RefPtr uniFFITaskPromise = new UniFFITaskPromise::Private(__func__);
    nsresult uniFFIDispatchResult = NS_DispatchBackgroundTask(
            NS_NewRunnableFunction(
                "RondpointScaffolding::Rondpoint9336CopieEnumerations",
                [args = std::move(uniFFIArgs), uniFFITaskPromise]() mutable {
                auto result = rondpoint_9336_copie_enumerations::Invoke(args);
                uniFFITaskPromise->Resolve(std::move(result), __func__);
            }),
            NS_DISPATCH_EVENT_MAY_BLOCK);
    if (NS_FAILED(uniFFIDispatchResult)) {
        uniFFITaskPromise->Reject(uniFFIDispatchResult, __func__);
    }

    // When the background task promise completes, resolve the JS promise
    uniFFITaskPromise->Then(GetCurrentSerialEventTarget(), __func__,
            [uniFFIXPCOMGlobal, uniFFIReturnPromise](UniFFITaskPromise::ResolveOrRejectValue&& aResult) {
            if (!aResult.IsResolve()) {
                uniFFIReturnPromise->MaybeRejectWithUnknownError("RondpointScaffolding::Rondpoint9336CopieEnumerations task dispatch failed");
                return;
            }

            AutoEntryScript aes(uniFFIXPCOMGlobal, "RondpointScaffolding::Rondpoint9336CopieEnumerations call resolve");
            RootedDictionary<UniFFIRustCallResult> returnValue(aes.cx());

            rondpoint_9336_copie_enumerations::ReturnResult(aes.cx(), aResult.ResolveValue(), returnValue);
            uniFFIReturnPromise->MaybeResolve(returnValue);
            }
    );

    // Return the JS promise, using forget() to convert it to already_AddRefed
    return uniFFIReturnPromise.forget();
}
using namespace uniffi::rondpoint;
already_AddRefed<Promise> RondpointScaffolding::Rondpoint9336CopieCarte(const GlobalObject& aUniFFIGlobal,const ArrayBuffer& c,
 ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args

    // Create the promise that we return to JS
    nsCOMPtr<nsIGlobalObject> uniFFIXPCOMGlobal = do_QueryInterface(aUniFFIGlobal.GetAsSupports());
    RefPtr<Promise> uniFFIReturnPromise = Promise::Create(uniFFIXPCOMGlobal, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Prepare arguments to pass to Rust
    auto uniFFIArgs = rondpoint_9336_copie_carte::PrepareArgs(c, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Create a second promise that gets resolved by a background task that calls the scaffolding function
    using UniFFITaskPromise = MozPromise<rondpoint_9336_copie_carte::Result, nsresult, true>;
    RefPtr uniFFITaskPromise = new UniFFITaskPromise::Private(__func__);
    nsresult uniFFIDispatchResult = NS_DispatchBackgroundTask(
            NS_NewRunnableFunction(
                "RondpointScaffolding::Rondpoint9336CopieCarte",
                [args = std::move(uniFFIArgs), uniFFITaskPromise]() mutable {
                auto result = rondpoint_9336_copie_carte::Invoke(args);
                uniFFITaskPromise->Resolve(std::move(result), __func__);
            }),
            NS_DISPATCH_EVENT_MAY_BLOCK);
    if (NS_FAILED(uniFFIDispatchResult)) {
        uniFFITaskPromise->Reject(uniFFIDispatchResult, __func__);
    }

    // When the background task promise completes, resolve the JS promise
    uniFFITaskPromise->Then(GetCurrentSerialEventTarget(), __func__,
            [uniFFIXPCOMGlobal, uniFFIReturnPromise](UniFFITaskPromise::ResolveOrRejectValue&& aResult) {
            if (!aResult.IsResolve()) {
                uniFFIReturnPromise->MaybeRejectWithUnknownError("RondpointScaffolding::Rondpoint9336CopieCarte task dispatch failed");
                return;
            }

            AutoEntryScript aes(uniFFIXPCOMGlobal, "RondpointScaffolding::Rondpoint9336CopieCarte call resolve");
            RootedDictionary<UniFFIRustCallResult> returnValue(aes.cx());

            rondpoint_9336_copie_carte::ReturnResult(aes.cx(), aResult.ResolveValue(), returnValue);
            uniFFIReturnPromise->MaybeResolve(returnValue);
            }
    );

    // Return the JS promise, using forget() to convert it to already_AddRefed
    return uniFFIReturnPromise.forget();
}
using namespace uniffi::rondpoint;
already_AddRefed<Promise> RondpointScaffolding::Rondpoint9336Switcheroo(const GlobalObject& aUniFFIGlobal,const int8_t& b,
 ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args

    // Create the promise that we return to JS
    nsCOMPtr<nsIGlobalObject> uniFFIXPCOMGlobal = do_QueryInterface(aUniFFIGlobal.GetAsSupports());
    RefPtr<Promise> uniFFIReturnPromise = Promise::Create(uniFFIXPCOMGlobal, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Prepare arguments to pass to Rust
    auto uniFFIArgs = rondpoint_9336_switcheroo::PrepareArgs(b, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Create a second promise that gets resolved by a background task that calls the scaffolding function
    using UniFFITaskPromise = MozPromise<rondpoint_9336_switcheroo::Result, nsresult, true>;
    RefPtr uniFFITaskPromise = new UniFFITaskPromise::Private(__func__);
    nsresult uniFFIDispatchResult = NS_DispatchBackgroundTask(
            NS_NewRunnableFunction(
                "RondpointScaffolding::Rondpoint9336Switcheroo",
                [args = std::move(uniFFIArgs), uniFFITaskPromise]() mutable {
                auto result = rondpoint_9336_switcheroo::Invoke(args);
                uniFFITaskPromise->Resolve(std::move(result), __func__);
            }),
            NS_DISPATCH_EVENT_MAY_BLOCK);
    if (NS_FAILED(uniFFIDispatchResult)) {
        uniFFITaskPromise->Reject(uniFFIDispatchResult, __func__);
    }

    // When the background task promise completes, resolve the JS promise
    uniFFITaskPromise->Then(GetCurrentSerialEventTarget(), __func__,
            [uniFFIXPCOMGlobal, uniFFIReturnPromise](UniFFITaskPromise::ResolveOrRejectValue&& aResult) {
            if (!aResult.IsResolve()) {
                uniFFIReturnPromise->MaybeRejectWithUnknownError("RondpointScaffolding::Rondpoint9336Switcheroo task dispatch failed");
                return;
            }

            AutoEntryScript aes(uniFFIXPCOMGlobal, "RondpointScaffolding::Rondpoint9336Switcheroo call resolve");
            RootedDictionary<UniFFIRustCallResult> returnValue(aes.cx());

            rondpoint_9336_switcheroo::ReturnResult(aes.cx(), aResult.ResolveValue(), returnValue);
            uniFFIReturnPromise->MaybeResolve(returnValue);
            }
    );

    // Return the JS promise, using forget() to convert it to already_AddRefed
    return uniFFIReturnPromise.forget();
}
  already_AddRefed<UniFFIPointer> RondpointScaffolding::ReadPointerRetourneur(const GlobalObject& aUniFFIGlobal, const ArrayBuffer& aArrayBuff, long aPosition) {
      MOZ_LOG(sUniFFIRondpointScaffoldingLogger, LogLevel::Info, ("[UniFFI] Reading Pointer from buffer"));
      aArrayBuff.ComputeState();

      // in Rust and in the write function, a pointer is converted to a void* then written as u64 BigEndian
      // we do the reverse here
      uint8_t* data_ptr = aArrayBuff.Data() + aPosition; // Pointer arithmetic, move by position bytes
      void* ptr = (void*)mozilla::BigEndian::readUint64(data_ptr);
      return UniFFIPointer::Create(ptr, &RetourneurPointerType::getInstance());
  }
  void RondpointScaffolding::WritePointerRetourneur(const GlobalObject& aUniFFIGlobal, const UniFFIPointer& aPtr, const ArrayBuffer& aArrayBuff, long aPosition) {
      MOZ_LOG(sUniFFIRondpointScaffoldingLogger, LogLevel::Info, ("[UniFFI] Writing Pointer to buffer"));
      aArrayBuff.ComputeState();

      // in Rust and in the read function, a u64 is read as BigEndian and then converted to a pointer
      // we do the reverse here
      uint8_t* data_ptr = aArrayBuff.Data() + aPosition; // Pointer arithmetic, move by position bytes
      mozilla::BigEndian::writeUint64(data_ptr, (uint64_t)aPtr.getPtr());
  }

  
  already_AddRefed<UniFFIPointer> RondpointScaffolding::ReadPointerStringifier(const GlobalObject& aUniFFIGlobal, const ArrayBuffer& aArrayBuff, long aPosition) {
      MOZ_LOG(sUniFFIRondpointScaffoldingLogger, LogLevel::Info, ("[UniFFI] Reading Pointer from buffer"));
      aArrayBuff.ComputeState();

      // in Rust and in the write function, a pointer is converted to a void* then written as u64 BigEndian
      // we do the reverse here
      uint8_t* data_ptr = aArrayBuff.Data() + aPosition; // Pointer arithmetic, move by position bytes
      void* ptr = (void*)mozilla::BigEndian::readUint64(data_ptr);
      return UniFFIPointer::Create(ptr, &StringifierPointerType::getInstance());
  }
  void RondpointScaffolding::WritePointerStringifier(const GlobalObject& aUniFFIGlobal, const UniFFIPointer& aPtr, const ArrayBuffer& aArrayBuff, long aPosition) {
      MOZ_LOG(sUniFFIRondpointScaffoldingLogger, LogLevel::Info, ("[UniFFI] Writing Pointer to buffer"));
      aArrayBuff.ComputeState();

      // in Rust and in the read function, a u64 is read as BigEndian and then converted to a pointer
      // we do the reverse here
      uint8_t* data_ptr = aArrayBuff.Data() + aPosition; // Pointer arithmetic, move by position bytes
      mozilla::BigEndian::writeUint64(data_ptr, (uint64_t)aPtr.getPtr());
  }

  
  already_AddRefed<UniFFIPointer> RondpointScaffolding::ReadPointerOptionneur(const GlobalObject& aUniFFIGlobal, const ArrayBuffer& aArrayBuff, long aPosition) {
      MOZ_LOG(sUniFFIRondpointScaffoldingLogger, LogLevel::Info, ("[UniFFI] Reading Pointer from buffer"));
      aArrayBuff.ComputeState();

      // in Rust and in the write function, a pointer is converted to a void* then written as u64 BigEndian
      // we do the reverse here
      uint8_t* data_ptr = aArrayBuff.Data() + aPosition; // Pointer arithmetic, move by position bytes
      void* ptr = (void*)mozilla::BigEndian::readUint64(data_ptr);
      return UniFFIPointer::Create(ptr, &OptionneurPointerType::getInstance());
  }
  void RondpointScaffolding::WritePointerOptionneur(const GlobalObject& aUniFFIGlobal, const UniFFIPointer& aPtr, const ArrayBuffer& aArrayBuff, long aPosition) {
      MOZ_LOG(sUniFFIRondpointScaffoldingLogger, LogLevel::Info, ("[UniFFI] Writing Pointer to buffer"));
      aArrayBuff.ComputeState();

      // in Rust and in the read function, a u64 is read as BigEndian and then converted to a pointer
      // we do the reverse here
      uint8_t* data_ptr = aArrayBuff.Data() + aPosition; // Pointer arithmetic, move by position bytes
      mozilla::BigEndian::writeUint64(data_ptr, (uint64_t)aPtr.getPtr());
  }

  
}  // namespace mozilla::dom