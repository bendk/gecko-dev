// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!



"use strict";

var EXPORTED_SYMBOLS = [];

// UniFFIRustCallResult.code values
const CALL_SUCCESS = 0;
const CALL_ERROR = 1;
const CALL_INTERNAL_ERROR = 2;

// Write/Read data to/from an ArrayBuffer
class ArrayBufferDataStream {
    constructor(arrayBuffer) {
        this.dataView = new DataView(arrayBuffer);
        this.pos = 0;
    }

    readUint8() {
        let rv = this.dataView.getUint8(this.pos);
        this.pos += 1;
        return rv;
    }

    writeUint8(value) {
        this.dataView.setUint8(this.pos, value);
        this.pos += 1;
    }

    readUint16() {
        let rv = this.dataView.getUint16(this.pos);
        this.pos += 2;
        return rv;
    }

    writeUint16(value) {
        this.dataView.setUint16(this.pos, value);
        this.pos += 2;
    }

    readUint32() {
        let rv = this.dataView.getUint32(this.pos);
        this.pos += 4;
        return rv;
    }

    writeUint32(value) {
        this.dataView.setUint32(this.pos, value);
        this.pos += 4;
    }

    readUint64() {
        let rv = this.dataView.getBigUint64(this.pos);
        this.pos += 8;
        return Number(rv);
    }

    writeUint64(value) {
        this.dataView.setBigUint64(this.pos, BigInt(value));
        this.pos += 8;
    }


    readInt8() {
        let rv = this.dataView.getInt8(this.pos);
        this.pos += 1;
        return rv;
    }

    writeInt8(value) {
        this.dataView.setInt8(this.pos, value);
        this.pos += 1;
    }

    readInt16() {
        let rv = this.dataView.getInt16(this.pos);
        this.pos += 2;
        return rv;
    }

    writeInt16(value) {
        this.dataView.setInt16(this.pos, value);
        this.pos += 2;
    }

    readInt32() {
        let rv = this.dataView.getInt32(this.pos);
        this.pos += 4;
        return rv;
    }

    writeInt32(value) {
        this.dataView.setInt32(this.pos, value);
        this.pos += 4;
    }

    readInt64() {
        let rv = this.dataView.getBigInt64(this.pos);
        this.pos += 8;
        return Number(rv);
    }

    writeInt64(value) {
        this.dataView.setBigInt64(this.pos, BigInt(value));
        this.pos += 8;
    }


    readFloat32() {
        let rv = this.dataView.getFloat32(this.pos);
        this.pos += 4;
        return rv;
    }

    writeFloat32(value) {
        this.dataView.setFloat32(this.pos, value);
        this.pos += 4;
    }

    readFloat64() {
        let rv = this.dataView.getFloat64(this.pos);
        this.pos += 8;
        return rv;
    }

    writeFloat64(value) {
        this.dataView.setFloat64(this.pos, value);
        this.pos += 8;
    }


    writeString(value) {
      const encoder = new TextEncoder();
      // Note: in order to efficiently write this data, we first write the
      // string data, reserving 4 bytes for the size.
      const dest = new Uint8Array(this.dataView.buffer, this.pos + 4);
      const encodeResult = encoder.encodeInto(value, dest);
      if (encodeResult.read != value.length) {
        throw new UniFFIError(
            "writeString: out of space when writing to ArrayBuffer.  Did the computeSize() method returned the wrong result?"
        );
      }
      const size = encodeResult.written;
      // Next, go back and write the size before the string data
      this.dataView.setUint32(this.pos, size);
      // Finally, advance our position past both the size and string data
      this.pos += size + 4;
    }

    readString() {
      const decoder = new TextDecoder();
      const size = this.readUint32();
      const source = new Uint8Array(this.dataView.buffer, this.pos, size)
      const value = decoder.decode(source);
      this.pos += size;
      return value;
    }
}

function handleRustResult(result, liftCallback, liftErrCallback) {
    switch (result.code) {
        case CALL_SUCCESS:
            return liftCallback(result.data);

        case CALL_ERROR:
            throw liftErrCallback(result.data);

        case CALL_INTERNAL_ERROR:
            let message = result.internalErrorMessage;
            if (message) {
                throw new UniFFIInternalError(message);
            } else {
                throw new UniFFIInternalError("Unknown error");
            }

        default:
            throw new UniFFIError(`Unexpected status code: ${result.code}`);
    }
}

class UniFFIError {
    constructor(message) {
        this.message = message;
    }
}

class UniFFIInternalError extends UniFFIError {}

// Base class for FFI converters
class FfiConverter {
    static checkType(name, value) {
        if (value === undefined ) {
            throw TypeError(`${name} is undefined`);
        }
        if (value === null ) {
            throw TypeError(`${name} is null`);
        }
    }
}

// Base class for FFI converters that lift/lower by reading/writing to an ArrayBuffer
class FfiConverterArrayBuffer extends FfiConverter {
    static lift(buf) {
        return this.read(new ArrayBufferDataStream(buf));
    }

    static lower(value) {
        const buf = new ArrayBuffer(this.computeSize(value));
        const dataStream = new ArrayBufferDataStream(buf);
        this.write(dataStream, value);
        return buf;
    }
}



class FfiConverterString extends FfiConverter {
    static lift(buf) {
        const decoder = new TextDecoder();
        const utf8Arr = new Uint8Array(buf);
        return decoder.decode(utf8Arr);
    }
    static lower(value) {
        const encoder = new TextEncoder();
        return encoder.encode(value).buffer;
    }

    static write(dataStream, value) {
        dataStream.writeString(value);
    }

    static read(dataStream) {
        return dataStream.readString();
    }

    static computeSize(value) {
        const encoder = new TextEncoder();
        return 4 + encoder.encode(value).length
    }
}


class TodoList {
    // Use `init` to instantiate this class.
    // DO NOT USE THIS CONSTRUCTOR DIRECTLY
    constructor(ptr) {
        if (!ptr) {
            throw new UniFFIError("Attempting to construct an object using the JavaScript constructor directly" +
            "Please use a UDL defined constructor, or the init function for the primary constructor")
        }
        this.ptr = ptr;
        this.destroyed = false;
        this.callCounter = 0;
    }
    /**
     * An async constructor for TodoList.
     * 
     * @returns {Promise<TodoList>}: A promise that resolves
     *      to a newly constructed TodoList
     */
    static init() {
        

    const liftResult = (result) => FfiConverterTypeTodoList.lift(result);
    const liftError = null;

    const functionCall = () => {

        return TodolistScaffolding.todolist126TodoListNew(
        )
    }
    try {
        return functionCall().then((result) => handleRustResult(result,  liftResult, liftError));
    }  catch (error) {
        return Promise.reject(error)
    }
    }
    addItem(todo) {
        return this.runMethod(() => {
            

    const liftResult = (result) => undefined;
    const liftError = (data) => FfiConverterTypeTodoError.lift(data);

    const functionCall = () => {
        FfiConverterString.checkType("todo", todo);

        return TodolistScaffolding.todolist126TodoListAddItem(FfiConverterTypeTodoList.lower(this),
            FfiConverterString.lower(todo),
        )
    }
    try {
        return functionCall().then((result) => handleRustResult(result,  liftResult, liftError));
    }  catch (error) {
        return Promise.reject(error)
    }
        });
    }
    addEntry(entry) {
        return this.runMethod(() => {
            

    const liftResult = (result) => undefined;
    const liftError = (data) => FfiConverterTypeTodoError.lift(data);

    const functionCall = () => {
        FfiConverterTypeTodoEntry.checkType("entry", entry);

        return TodolistScaffolding.todolist126TodoListAddEntry(FfiConverterTypeTodoList.lower(this),
            FfiConverterTypeTodoEntry.lower(entry),
        )
    }
    try {
        return functionCall().then((result) => handleRustResult(result,  liftResult, liftError));
    }  catch (error) {
        return Promise.reject(error)
    }
        });
    }
    getEntries() {
        return this.runMethod(() => {
            

    const liftResult = (result) => FfiConverterSequenceTypeTodoEntry.lift(result);
    const liftError = null;

    const functionCall = () => {

        return TodolistScaffolding.todolist126TodoListGetEntries(FfiConverterTypeTodoList.lower(this),
            
        )
    }
    try {
        return functionCall().then((result) => handleRustResult(result,  liftResult, liftError));
    }  catch (error) {
        return Promise.reject(error)
    }
        });
    }
    getItems() {
        return this.runMethod(() => {
            

    const liftResult = (result) => FfiConverterSequencestring.lift(result);
    const liftError = null;

    const functionCall = () => {

        return TodolistScaffolding.todolist126TodoListGetItems(FfiConverterTypeTodoList.lower(this),
            
        )
    }
    try {
        return functionCall().then((result) => handleRustResult(result,  liftResult, liftError));
    }  catch (error) {
        return Promise.reject(error)
    }
        });
    }
    addEntries(entries) {
        return this.runMethod(() => {
            

    const liftResult = (result) => undefined;
    const liftError = null;

    const functionCall = () => {
        FfiConverterSequenceTypeTodoEntry.checkType("entries", entries);

        return TodolistScaffolding.todolist126TodoListAddEntries(FfiConverterTypeTodoList.lower(this),
            FfiConverterSequenceTypeTodoEntry.lower(entries),
        )
    }
    try {
        return functionCall().then((result) => handleRustResult(result,  liftResult, liftError));
    }  catch (error) {
        return Promise.reject(error)
    }
        });
    }
    addItems(items) {
        return this.runMethod(() => {
            

    const liftResult = (result) => undefined;
    const liftError = null;

    const functionCall = () => {
        FfiConverterSequencestring.checkType("items", items);

        return TodolistScaffolding.todolist126TodoListAddItems(FfiConverterTypeTodoList.lower(this),
            FfiConverterSequencestring.lower(items),
        )
    }
    try {
        return functionCall().then((result) => handleRustResult(result,  liftResult, liftError));
    }  catch (error) {
        return Promise.reject(error)
    }
        });
    }
    getLastEntry() {
        return this.runMethod(() => {
            

    const liftResult = (result) => FfiConverterTypeTodoEntry.lift(result);
    const liftError = (data) => FfiConverterTypeTodoError.lift(data);

    const functionCall = () => {

        return TodolistScaffolding.todolist126TodoListGetLastEntry(FfiConverterTypeTodoList.lower(this),
            
        )
    }
    try {
        return functionCall().then((result) => handleRustResult(result,  liftResult, liftError));
    }  catch (error) {
        return Promise.reject(error)
    }
        });
    }
    getLast() {
        return this.runMethod(() => {
            

    const liftResult = (result) => FfiConverterString.lift(result);
    const liftError = (data) => FfiConverterTypeTodoError.lift(data);

    const functionCall = () => {

        return TodolistScaffolding.todolist126TodoListGetLast(FfiConverterTypeTodoList.lower(this),
            
        )
    }
    try {
        return functionCall().then((result) => handleRustResult(result,  liftResult, liftError));
    }  catch (error) {
        return Promise.reject(error)
    }
        });
    }
    getFirst() {
        return this.runMethod(() => {
            

    const liftResult = (result) => FfiConverterString.lift(result);
    const liftError = (data) => FfiConverterTypeTodoError.lift(data);

    const functionCall = () => {

        return TodolistScaffolding.todolist126TodoListGetFirst(FfiConverterTypeTodoList.lower(this),
            
        )
    }
    try {
        return functionCall().then((result) => handleRustResult(result,  liftResult, liftError));
    }  catch (error) {
        return Promise.reject(error)
    }
        });
    }
    clearItem(todo) {
        return this.runMethod(() => {
            

    const liftResult = (result) => undefined;
    const liftError = (data) => FfiConverterTypeTodoError.lift(data);

    const functionCall = () => {
        FfiConverterString.checkType("todo", todo);

        return TodolistScaffolding.todolist126TodoListClearItem(FfiConverterTypeTodoList.lower(this),
            FfiConverterString.lower(todo),
        )
    }
    try {
        return functionCall().then((result) => handleRustResult(result,  liftResult, liftError));
    }  catch (error) {
        return Promise.reject(error)
    }
        });
    }
    makeDefault() {
        return this.runMethod(() => {
            

    const liftResult = (result) => undefined;
    const liftError = null;

    const functionCall = () => {

        return TodolistScaffolding.todolist126TodoListMakeDefault(FfiConverterTypeTodoList.lower(this),
            
        )
    }
    try {
        return functionCall().then((result) => handleRustResult(result,  liftResult, liftError));
    }  catch (error) {
        return Promise.reject(error)
    }
        });
    }

    destroy() {
        this.destroyed = true;
        // If the call counter is not zero, there are ongoing calls that haven't concluded
        // yet. The function calls themselves will make sure to deallocate the object once the last
        // one concludes and we will prevent any new calls by throwing a UniFFIError
        if (this.callCounter === 0) {
            TodolistScaffolding.ffiTodolist126TodoListObjectFree(this.ptr);
        }
    }

    runMethod(callback) {
        if (this.destroyed) {
            throw new UniFFIError("Attempting to call method on Object that is already destroyed")
        }
        try {
            this.callCounter += 1;
            return callback();
        } finally {
            this.callCounter -=1;
            if (this.destroyed && this.callCounter === 0) {
                TodolistScaffolding.ffiTodolist126TodoListObjectFree(this.ptr);
            }
        }
    }
}

class FfiConverterTypeTodoList extends FfiConverter {
    static lift(value) {
        return new TodoList(value);
    }

    static lower(value) {
        return value.ptr;
    }

    // Note: We store the object pointer using the `setPrivate` JS API.  From
    // the JS side, this appears as a 64-bit float value.

    static read(dataStream) {
        return this.lift(dataStream.readFloat64());
    }

    static write(dataStream, value) {
        dataStream.writeFloat64(this.lower(value));
    }

    static computeSize(value) {
        return 8;
    }
}

EXPORTED_SYMBOLS.push("TodoList");

class TodoEntry {
    constructor(text) {
        FfiConverterString.checkType("text", text);
        this.text = text;
    }
    equals(other) {
        return (
            this.text == other.text
        )
    }
}

class FfiConverterTypeTodoEntry extends FfiConverter {
    static lift(buf) {
        return this.read(new ArrayBufferDataStream(buf));
    }
    static lower(value) {
        const buf = new ArrayBuffer(this.computeSize(value));
        const dataStream = new ArrayBufferDataStream(buf);
        this.write(dataStream, value);
        return buf;
    }
    static read(dataStream) {
        return new TodoEntry(
            FfiConverterString.read(dataStream)
        );
    }
    static write(dataStream, value) {
        FfiConverterString.write(dataStream, value.text);
    }

    static computeSize(value) {
        let totalSize = 0;
        totalSize += FfiConverterString.computeSize(value.text);
        return totalSize
    }
}

EXPORTED_SYMBOLS.push("TodoEntry");


class TodoError extends Error {}
EXPORTED_SYMBOLS.push("TodoError");


class TodoDoesNotExist extends TodoError {
    
    constructor(message, ...params) {
        super(...params);
        this.message = message;
    }
}
EXPORTED_SYMBOLS.push("TodoDoesNotExist");
class EmptyTodoList extends TodoError {
    
    constructor(message, ...params) {
        super(...params);
        this.message = message;
    }
}
EXPORTED_SYMBOLS.push("EmptyTodoList");
class DuplicateTodo extends TodoError {
    
    constructor(message, ...params) {
        super(...params);
        this.message = message;
    }
}
EXPORTED_SYMBOLS.push("DuplicateTodo");
class EmptyString extends TodoError {
    
    constructor(message, ...params) {
        super(...params);
        this.message = message;
    }
}
EXPORTED_SYMBOLS.push("EmptyString");
class DeligatedError extends TodoError {
    
    constructor(message, ...params) {
        super(...params);
        this.message = message;
    }
}
EXPORTED_SYMBOLS.push("DeligatedError");

class FfiConverterTypeTodoError extends FfiConverterArrayBuffer {
    static read(dataStream) {
        switch (dataStream.readInt32()) {
            case 1:
                return new TodoDoesNotExist(FfiConverterString.read(dataStream));
            case 2:
                return new EmptyTodoList(FfiConverterString.read(dataStream));
            case 3:
                return new DuplicateTodo(FfiConverterString.read(dataStream));
            case 4:
                return new EmptyString(FfiConverterString.read(dataStream));
            case 5:
                return new DeligatedError(FfiConverterString.read(dataStream));
            default:
                return new Error("Unknown TodoError variant");
        }
    }
}

class FfiConverterOptionalTypeTodoList extends FfiConverterArrayBuffer {
    static checkType(name, value) {
        if (value !== undefined && value !== null) {
            FfiConverterTypeTodoList.checkType(name, value)
        }
    }

    static read(dataStream) {
        const code = dataStream.readUint8(0);
        switch (code) {
            case 0:
                return null
            case 1:
                return FfiConverterTypeTodoList.read(dataStream)
            default:
                throw UniFFIError(`Unexpected code: ${code}`);
        }
    }

    static write(dataStream, value) {
        if (value === null || value === undefined) {
            dataStream.writeUint8(0);
            return;
        }
        dataStream.writeUint8(1);
        FfiConverterTypeTodoList.write(dataStream, value)
    }

    static computeSize(value) {
        if (value === null || value === undefined) {
            return 1;
        }
        return 1 + FfiConverterTypeTodoList.computeSize(value)
    }
}class FfiConverterSequencestring extends FfiConverterArrayBuffer {
    static read(dataStream) {
        const len = dataStream.readInt32();
        const arr = [];
        for (let i = 0; i < len; i++) {
            arr.push(FfiConverterString.read(dataStream));
        }
        return arr;
    }

    static write(dataStream, value) {
        dataStream.writeInt32(value.length);
        value.forEach((innerValue) => {
            FfiConverterString.write(dataStream, innerValue);
        })
    }

    static computeSize(value) {
        // The size of the length
        let size = 4;
        for (const innerValue of value) {
            size += FfiConverterString.computeSize(innerValue);
        }
        return size;
    }
}class FfiConverterSequenceTypeTodoEntry extends FfiConverterArrayBuffer {
    static read(dataStream) {
        const len = dataStream.readInt32();
        const arr = [];
        for (let i = 0; i < len; i++) {
            arr.push(FfiConverterTypeTodoEntry.read(dataStream));
        }
        return arr;
    }

    static write(dataStream, value) {
        dataStream.writeInt32(value.length);
        value.forEach((innerValue) => {
            FfiConverterTypeTodoEntry.write(dataStream, innerValue);
        })
    }

    static computeSize(value) {
        // The size of the length
        let size = 4;
        for (const innerValue of value) {
            size += FfiConverterTypeTodoEntry.computeSize(innerValue);
        }
        return size;
    }
}


function getDefaultList() {
    

    const liftResult = (result) => FfiConverterOptionalTypeTodoList.lift(result);
    const liftError = null;

    const functionCall = () => {

        return TodolistScaffolding.todolist126GetDefaultList(
        )
    }
    try {
        return functionCall().then((result) => handleRustResult(result,  liftResult, liftError));
    }  catch (error) {
        return Promise.reject(error)
    }
}

EXPORTED_SYMBOLS.push("getDefaultList");
function setDefaultList(list) {
    

    const liftResult = (result) => undefined;
    const liftError = null;

    const functionCall = () => {
        FfiConverterTypeTodoList.checkType("list", list);

        return TodolistScaffolding.todolist126SetDefaultList(FfiConverterTypeTodoList.lower(list),
        )
    }
    try {
        return functionCall().then((result) => handleRustResult(result,  liftResult, liftError));
    }  catch (error) {
        return Promise.reject(error)
    }
}

EXPORTED_SYMBOLS.push("setDefaultList");
function createEntryWith(todo) {
    

    const liftResult = (result) => FfiConverterTypeTodoEntry.lift(result);
    const liftError = (data) => FfiConverterTypeTodoError.lift(data);

    const functionCall = () => {
        FfiConverterString.checkType("todo", todo);

        return TodolistScaffolding.todolist126CreateEntryWith(FfiConverterString.lower(todo),
        )
    }
    try {
        return functionCall().then((result) => handleRustResult(result,  liftResult, liftError));
    }  catch (error) {
        return Promise.reject(error)
    }
}

EXPORTED_SYMBOLS.push("createEntryWith");