// This file was autogenerated by some hot garbage in the `uniffi-bindgen-gecko-js` crate.
// Trust me, you don't want to mess with it!

#include "nsIGlobalObject.h"
#include "mozilla/MozPromise.h"
#include "mozilla/dom/ArithmeticScaffolding.h"
#include "mozilla/dom/OwnedRustBuffer.h"
#include "mozilla/dom/Promise.h"

namespace uniffi::arithmetic {
// For each Rust scaffolding function, define types and functions for calling it
namespace arithmetic_475f_add {
using namespace mozilla::dom;
// Arguments to pass to the scaffolding function
//
// RustBuffer arguments are stored as OwnedRustBuffer instances.  That class takes care of
// freeing the buffer if the arguments don't get passed to Rust (i.e. intoRustBuffer()
// isn't called).  This can happen if some of the ArrayBuffer arguments are succuessfully
// converted, but one fails to convert.
struct Args {
    uint64_t a;
    uint64_t b;
};

// Return values from the scaffolding function
struct Result {
    uint64_t mReturnValue;
    RustCallStatus mCallStatus = {};
};

// Convert the arguments we get from JS to arguments to pass to Rust.
//
// On error, an error code will be stored in result.  Make sure to check this before
// passing the args to Invoke().
//
// For async calls this should be called in the main thread, since the GC can
// move the ArrayBuffer pointers while the background task is waiting.
Args PrepareArgs(const uint64_t& a, const uint64_t& b, mozilla::ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args
    Args uniFFIArgs;
    uniFFIArgs.a = a;
    uniFFIArgs.b = b;

    return uniFFIArgs;
}

// Call the scaffolding function
//
// For async calls this should be called in the worker thread
Result Invoke(Args& aArgs) {
    Result result = {};
<<<<<<< HEAD:toolkit/components/uniffi-bindgen-gecko-js/fixtures/ArithmeticScaffolding.cpp
    result.mReturnValue = ::arithmetic_475f_add(
         aArgs.a,
         aArgs.b,
    result.mReturnValue = ::geometry_4b5d_gradient(
         aArgs.ln.intoRustBuffer(),
>>>>>>> 91e1d041ccf0 (Adds support for enums):toolkit/components/geometry/js/GeometryScaffolding.cpp

// Return the result of the scaffolding call back to JS
void ReturnResult(JSContext* aContext, const Result& aCallResult, RootedDictionary<UniFFIRustCallResult>& aReturnValue) {
    switch (aCallResult.mCallStatus.code) {
        case uniffi::CALL_SUCCESS:
            // Successful call.  Populate data with the return value
            aReturnValue.mCode = uniffi::CALL_SUCCESS;
            // All other return values (ints, floats, pointers) are handled as a JS number value
            aReturnValue.mData.setNumber(aCallResult.mReturnValue);
            break;

        case uniffi::CALL_ERROR:
            // Rust Err() value.  Populate data with the `RustBuffer` containing the error
            aReturnValue.mCode = uniffi::CALL_ERROR;
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mCallStatus.error_buf).intoArrayBuffer(aContext));
            break;

        default:
            // This indicates a RustError, which shouldn't happen in practice since FF sets panic=abort
            aReturnValue.mCode = uniffi::CALL_INTERNAL_ERROR;
            aReturnValue.mInternalErrorMessage.AssignLiteral(u"Unexpected Error");
            break;
    }
}
}
// For each Rust scaffolding function, define types and functions for calling it
namespace arithmetic_475f_sub {
using namespace mozilla::dom;
// Arguments to pass to the scaffolding function
//
// RustBuffer arguments are stored as OwnedRustBuffer instances.  That class takes care of
//
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args
    Args uniFFIArgs;
    map.ComputeState();
    uniFFIArgs.map = OwnedRustBuffer(map, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return uniFFIArgs;
    }
    uniFFIArgs.size = size;

    return uniFFIArgs;
}

// Call the scaffolding function
//
// For async calls this should be called in the worker thread
Result Invoke(Args& aArgs) {
    Result result = {};
    result.mReturnValue = ::geometry_4b5d_map_round(
         aArgs.map.intoRustBuffer(),
         aArgs.size,
         &result.mCallStatus
     );
    return result;
}

// Return the result of the scaffolding call back to JS
void ReturnResult(JSContext* aContext, const Result& aCallResult, RootedDictionary<UniFFIRustCallResult>& aReturnValue) {
    switch (aCallResult.mCallStatus.code) {
        case uniffi::CALL_SUCCESS:
            // Successful call.  Populate data with the return value
            aReturnValue.mCode = uniffi::CALL_SUCCESS;
            // Convert result RustBuffer into an ArrayBuffer and set the data field
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mReturnValue).intoArrayBuffer(aContext));
            break;

        case uniffi::CALL_ERROR:
            // Rust Err() value.  Populate data with the `RustBuffer` containing the error
            aReturnValue.mCode = uniffi::CALL_ERROR;
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mCallStatus.error_buf).intoArrayBuffer(aContext));
            break;

        default:
            // This indicates a RustError, which shouldn't happen in practice since FF sets panic=abort
            aReturnValue.mCode = uniffi::CALL_INTERNAL_ERROR;
            aReturnValue.mInternalErrorMessage.AssignLiteral(u"Unexpected Error");
            break;
    }
}
}
// For each Rust scaffolding function, define types and functions for calling it
namespace geometry_4b5d_enum_round {
using namespace mozilla::dom;
// Arguments to pass to the scaffolding function
//
// RustBuffer arguments are stored as OwnedRustBuffer instances.  That class takes care of
// freeing the buffer if the arguments don't get passed to Rust (i.e. intoRustBuffer()
// isn't called).  This can happen if some of the ArrayBuffer arguments are succuessfully
// converted, but one fails to convert.
struct Args {
    mozilla::dom::OwnedRustBuffer e;
};

// Return values from the scaffolding function
struct Result {
    RustBuffer mReturnValue;
    RustCallStatus mCallStatus = {};
};

// Convert the arguments we get from JS to arguments to pass to Rust.
//
// On error, an error code will be stored in result.  Make sure to check this before
// passing the args to Invoke().
//
// For async calls this should be called in the main thread, since the GC can
// move the ArrayBuffer pointers while the background task is waiting.
Args PrepareArgs(const ArrayBuffer& e, mozilla::ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args
    Args uniFFIArgs;
    e.ComputeState();
    uniFFIArgs.e = OwnedRustBuffer(e, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return uniFFIArgs;
    }

    return uniFFIArgs;
}

// Call the scaffolding function
//
// For async calls this should be called in the worker thread
Result Invoke(Args& aArgs) {
    Result result = {};
    result.mReturnValue = ::geometry_4b5d_enum_round(
         aArgs.e.intoRustBuffer(),
         &result.mCallStatus
     );
    return result;
}

// Return the result of the scaffolding call back to JS
void ReturnResult(JSContext* aContext, const Result& aCallResult, RootedDictionary<UniFFIRustCallResult>& aReturnValue) {
    switch (aCallResult.mCallStatus.code) {
        case uniffi::CALL_SUCCESS:
            // Successful call.  Populate data with the return value
            aReturnValue.mCode = uniffi::CALL_SUCCESS;
            // Convert result RustBuffer into an ArrayBuffer and set the data field
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mReturnValue).intoArrayBuffer(aContext));
            break;

        case uniffi::CALL_ERROR:
            // Rust Err() value.  Populate data with the `RustBuffer` containing the error
            aReturnValue.mCode = uniffi::CALL_ERROR;
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mCallStatus.error_buf).intoArrayBuffer(aContext));
            break;

        default:
            // This indicates a RustError, which shouldn't happen in practice since FF sets panic=abort
            aReturnValue.mCode = uniffi::CALL_INTERNAL_ERROR;
            aReturnValue.mInternalErrorMessage.AssignLiteral(u"Unexpected Error");
            break;
    }
}
}
// For each Rust scaffolding function, define types and functions for calling it
namespace geometry_4b5d_complex_enum_round {
using namespace mozilla::dom;
// Arguments to pass to the scaffolding function
//
// RustBuffer arguments are stored as OwnedRustBuffer instances.  That class takes care of
// freeing the buffer if the arguments don't get passed to Rust (i.e. intoRustBuffer()
// isn't called).  This can happen if some of the ArrayBuffer arguments are succuessfully
// converted, but one fails to convert.
struct Args {
    mozilla::dom::OwnedRustBuffer ce;
};

// Return values from the scaffolding function
struct Result {
    RustBuffer mReturnValue;
    RustCallStatus mCallStatus = {};
};

// Convert the arguments we get from JS to arguments to pass to Rust.
//
// On error, an error code will be stored in result.  Make sure to check this before
// passing the args to Invoke().
//
// For async calls this should be called in the main thread, since the GC can
// move the ArrayBuffer pointers while the background task is waiting.
Args PrepareArgs(const ArrayBuffer& ce, mozilla::ErrorResult& aUniFFIError) {
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args
    Args uniFFIArgs;
    ce.ComputeState();
    uniFFIArgs.ce = OwnedRustBuffer(ce, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return uniFFIArgs;
    }

    return uniFFIArgs;
}

// Call the scaffolding function
//
// For async calls this should be called in the worker thread
Result Invoke(Args& aArgs) {
    Result result = {};
    result.mReturnValue = ::geometry_4b5d_complex_enum_round(
         aArgs.ce.intoRustBuffer(),
         &result.mCallStatus
     );
    return result;
}

// Return the result of the scaffolding call back to JS
void ReturnResult(JSContext* aContext, const Result& aCallResult, RootedDictionary<UniFFIRustCallResult>& aReturnValue) {
    switch (aCallResult.mCallStatus.code) {
        case uniffi::CALL_SUCCESS:
            // Successful call.  Populate data with the return value
            aReturnValue.mCode = uniffi::CALL_SUCCESS;
            // Convert result RustBuffer into an ArrayBuffer and set the data field
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mReturnValue).intoArrayBuffer(aContext));
            break;

        case uniffi::CALL_ERROR:
            // Rust Err() value.  Populate data with the `RustBuffer` containing the error
            aReturnValue.mCode = uniffi::CALL_ERROR;
            aReturnValue.mData.setObjectOrNull(OwnedRustBuffer(aCallResult.mCallStatus.error_buf).intoArrayBuffer(aContext));
            break;

        default:
            // This indicates a RustError, which shouldn't happen in practice since FF sets panic=abort
            aReturnValue.mCode = uniffi::CALL_INTERNAL_ERROR;
            aReturnValue.mInternalErrorMessage.AssignLiteral(u"Unexpected Error");
            break;
    }
}
}
}

namespace mozilla::dom {
                auto result = geometry_4b5d_gradient::Invoke(args);
            NS_DISPATCH_EVENT_MAY_BLOCK);

    // When the background task promise completes, resolve the JS promise
    uniFFITaskPromise->Then(GetCurrentSerialEventTarget(), __func__,
            [uniFFIXPCOMGlobal, uniFFIReturnPromise](UniFFITaskPromise::ResolveOrRejectValue&& aResult) {
            if (!aResult.IsResolve()) {
                uniFFIReturnPromise->MaybeRejectWithUnknownError("ArithmeticScaffolding::Arithmetic475fAdd task dispatch failed");
                return;
            }

            AutoEntryScript aes(uniFFIXPCOMGlobal, "ArithmeticScaffolding::Arithmetic475fAdd call resolve");
            RootedDictionary<UniFFIRustCallResult> returnValue(aes.cx());

            arithmetic_475f_add::ReturnResult(aes.cx(), aResult.ResolveValue(), returnValue);
            uniFFIReturnPromise->MaybeResolve(returnValue);
            }
    );
    // Note: Prefix our params and local variables with "uniffi" to avoid name
    // conflicts with the scaffolding function args

    // Create the promise that we return to JS
    nsCOMPtr<nsIGlobalObject> uniFFIXPCOMGlobal = do_QueryInterface(aUniFFIGlobal.GetAsSupports());
    RefPtr<Promise> uniFFIReturnPromise = Promise::Create(uniFFIXPCOMGlobal, aUniFFIError);
    if (aUniFFIError.Failed()) {
        return nullptr;
    }

    // Prepare arguments to pass to Rust
    if (aUniFFIError.Failed()) {
